<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Study – SICP Textbook Notes</title>
  <style>
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link rel="stylesheet" href="assets/style.css">
</head>
<body>
<header class="header">
  <a class="title" href="index.html">SICP Study</a>
  <span class="header__gap"></span>
  <nav>
    <ul class="nav">
      <li class="nav__item nav__item--active"><a class="nav__link" href="textbook.html">Text</a></li><!--
      --><li class="nav__item"><a class="nav__link" href="lecture.html">Lectures</a></li>
      <li class="nav__item"><a class="nav__link" href="quote.html">Quotes</a></li>
      <li class="nav__item"><a class="nav__link" href="exercise.html">Exercises</a></li>
      <li class="nav__item"><a class="nav__link" href="https://github.com/mk12/sicp">Source <svg class="github-mark" width="25" height="25" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g transform="matrix(1,0,0,1,-568.001,-447.669)">
      <g transform="matrix(4.16667,0,0,4.16667,0,0)">
          <g transform="matrix(1,0,0,1,152.608,139.345)">
              <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.778 -11.354,-8.279 -11.354,-8.279C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.154 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.237C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.839 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.839 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904"/>
          </g>
      </g>
  </g>
</svg></a></li>
    </ul>
  </nav>
</header>
<h1>SICP Textbook Notes</h1>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#dedication">Dedication</a></li>
<li><a href="#foreword">Foreword</a></li>
<li><a href="#preface">Preface</a></li>
<li><a href="#chapter-1-building-abstractions-with-procedures">Chapter 1: Building Abstractions with Procedures</a>
<ul>
<li><a href="#the-elements-of-programming">The Elements of Programming</a>
<ul>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#naming-and-the-environment">Naming and the Environment</a></li>
<li><a href="#evaluating-combinations">Evaluating Combinations</a></li>
<li><a href="#compound-procedures">Compound Procedures</a></li>
<li><a href="#the-substitution-model-for-procedure-application">The Substitution Model for Procedure Application</a></li>
<li><a href="#conditional-expressions-and-predicates">Conditional Expressions and Predicates</a></li>
<li><a href="#example-square-roots-by-newtons-method">Example: Square Roots by Newton’s Method</a></li>
<li><a href="#procedures-as-black-box-abstractions">Procedures as Black-Box Abstractions</a></li>
</ul></li>
<li><a href="#procedures-and-the-processes-they-generate">Procedures and the Processes They Generate</a>
<ul>
<li><a href="#linear-recursion-and-iteration">Linear Recursion and Iteration</a></li>
<li><a href="#tree-recursion">Tree Recursion</a></li>
<li><a href="#orders-of-growth">Orders of Growth</a></li>
<li><a href="#exponentiation">Exponentiation</a></li>
<li><a href="#greatest-common-divisors">Greatest Common Divisors</a></li>
<li><a href="#example-testing-for-primality">Example: Testing for Primality</a></li>
</ul></li>
<li><a href="#formulating-abstractions-with-higher-order-procedures">Formulating Abstractions with Higher-Order Procedures</a>
<ul>
<li><a href="#procedures-as-arguments">Procedures as Arguments</a></li>
<li><a href="#constructing-procedures-using-lambda">Constructing Procedures Using <code>Lambda</code></a></li>
<li><a href="#procedures-as-general-methods">Procedures as General Methods</a></li>
<li><a href="#procedures-as-returned-values">Procedures as Returned Values</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-2-building-abstractions-with-data">Chapter 2: Building Abstractions with Data</a>
<ul>
<li><a href="#introduction-to-data-abstraction">Introduction to Data Abstraction</a>
<ul>
<li><a href="#example-arithmetic-operations-for-rational-numbers">Example: Arithmetic Operations for Rational Numbers</a></li>
<li><a href="#abstractions-barriers">Abstractions Barriers</a></li>
<li><a href="#what-is-meant-by-data">What Is Meant by Data?</a></li>
<li><a href="#extended-exercise-interval-arithmetic">Extended Exercise: Interval Arithmetic</a></li>
</ul></li>
<li><a href="#hierarchical-data-and-the-closure-property">Hierarchical Data and the Closure Property</a>
<ul>
<li><a href="#representing-sequences">Representing Sequences</a></li>
<li><a href="#hierarchical-structures">Hierarchical Structures</a></li>
<li><a href="#sequences-as-conventional-interfaces">Sequences as Conventional Interfaces</a></li>
<li><a href="#example-a-picture-language">Example: A Picture Language</a></li>
</ul></li>
<li><a href="#symbolic-data">Symbolic Data</a>
<ul>
<li><a href="#quotation">Quotation</a></li>
<li><a href="#example-symbolic-differentiation">Example: Symbolic Differentiation</a></li>
<li><a href="#example-representing-sets">Example: Representing Sets</a></li>
<li><a href="#example-huffman-encoding-trees">Example: Huffman Encoding Trees</a></li>
</ul></li>
<li><a href="#multiple-representations-for-abstract-data">Multiple Representations for Abstract Data</a>
<ul>
<li><a href="#representations-for-complex-numbers">Representations for Complex Numbers</a></li>
<li><a href="#tagged-data">Tagged Data</a></li>
<li><a href="#data-directed-programming-and-additivity">Data-Directed Programming and Additivity</a></li>
</ul></li>
<li><a href="#systems-with-generic-operations">Systems with Generic Operations</a>
<ul>
<li><a href="#generic-arithmetic-operations">Generic Arithmetic Operations</a></li>
<li><a href="#combining-data-of-different-types">Combining Data of Different Types</a></li>
<li><a href="#example-symbolic-algebra">Example: Symbolic Algebra</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-3-modularity-objects-and-state">Chapter 3: Modularity, Objects, and State</a>
<ul>
<li><a href="#assignment-and-local-state">Assignment and Local State</a>
<ul>
<li><a href="#local-state-variables">Local State Variables</a></li>
<li><a href="#the-benefits-of-introducing-assignment">The Benefits of Introducing Assignment</a></li>
<li><a href="#the-costs-of-introducing-assignment">The Costs of Introducing Assignment</a></li>
</ul></li>
<li><a href="#the-environment-model-of-evaluation">The Environment Model of Evaluation</a>
<ul>
<li><a href="#the-rules-for-evaluation">The Rules for Evaluation</a></li>
<li><a href="#applying-simple-procedures">Applying Simple Procedures</a></li>
<li><a href="#frames-as-the-repository-of-local-state">Frames as the Repository of Local State</a></li>
<li><a href="#internal-definitions">Internal Definitions</a></li>
</ul></li>
<li><a href="#modeling-with-mutable-data">Modeling with Mutable Data</a>
<ul>
<li><a href="#mutable-list-structure">Mutable List Structure</a></li>
<li><a href="#representing-queues">Representing Queues</a></li>
<li><a href="#representing-tables">Representing Tables</a></li>
<li><a href="#a-simulator-for-digital-circuits">A Simulator for Digital Circuits</a></li>
<li><a href="#propagation-of-constraints">Propagation of Constraints</a></li>
</ul></li>
<li><a href="#concurrency-time-is-of-the-essence">Concurrency: Time Is of the Essence</a>
<ul>
<li><a href="#the-nature-of-time-in-concurrent-systems">The Nature of Time in Concurrent Systems</a></li>
<li><a href="#mechanisms-for-controlling-concurrency">Mechanisms for Controlling Concurrency</a></li>
</ul></li>
<li><a href="#streams">Streams</a>
<ul>
<li><a href="#streams-are-delayed-lists">Streams Are Delayed Lists</a></li>
<li><a href="#infinite-streams">Infinite Streams</a></li>
<li><a href="#exploiting-the-stream-paradigm">Exploiting the Stream Paradigm</a></li>
<li><a href="#streams-and-delayed-evaluation">Streams and Delayed Evaluation</a></li>
<li><a href="#modularity-of-functional-programs-and-modularity-of-objects">Modularity of Functional Programs and Modularity of Objects</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-4-metalinguistic-abstraction">Chapter 4: Metalinguistic Abstraction</a>
<ul>
<li><a href="#the-metacircular-evaluator">The Metacircular Evaluator</a>
<ul>
<li><a href="#the-core-of-the-evaluator">The Core of the Evaluator</a></li>
<li><a href="#representing-expressions">Representing Expressions</a></li>
<li><a href="#evaluator-data-structures">Evaluator Data Structures</a></li>
<li><a href="#running-the-evaluator-as-a-program">Running the Evaluator as a Program</a></li>
<li><a href="#data-as-programs">Data as Programs</a></li>
<li><a href="#internal-definitions-1">Internal Definitions</a></li>
<li><a href="#separating-syntactic-analysis-from-execution">Separating Syntactic Analysis from Execution</a></li>
</ul></li>
<li><a href="#variations-on-a-scheme-lazy-evaluation">Variations on a Scheme — Lazy Evaluation</a>
<ul>
<li><a href="#normal-order-and-applicative-order">Normal Order and Applicative Order</a></li>
<li><a href="#an-interpreter-with-lazy-evaluation">An Interpreter with Lazy Evaluation</a></li>
<li><a href="#streams-as-lazy-lists">Streams as Lazy Lists</a></li>
</ul></li>
<li><a href="#variations-on-a-scheme-nondeterministic-computing">Variations on a Scheme — Nondeterministic Computing</a></li>
</ul></li>
</ul>
</nav>
<h1 id="dedication">Dedication</h1>
<blockquote>
<p>What’s in your hands, I think and hope, is intelligence: the ability to see the machine as more than when you were first led up to it, that you can make it more. (xii)</p>
</blockquote>
<h1 id="foreword">Foreword</h1>
<ul>
<li>Three foci: the human mind, collections of computer programs, and the computer.</li>
<li>Idioms form “an arsenal of standard program structures of whose correctness we have become sure” (xiv).</li>
<li>Algorithms are programs that perform a precise mathematical function (optimized for execution time and data storage).</li>
</ul>
<blockquote>
<p>Lisp is for building organisms – imposing, breathtaking, dynamic structures built by squads fitting fluctuating myriads of simpler organisms into place. (xvii)</p>
</blockquote>
<blockquote>
<p>It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures. (xvii)</p>
</blockquote>
<h1 id="preface">Preface</h1>
<ul>
<li>Computer language: a novel formal medium for expressing ideas about methodology.</li>
</ul>
<blockquote>
<p>Thus, programs must be written for people to read, and only incidentally for machines to execute. (xxii)</p>
</blockquote>
<blockquote>
<p>Underlying our approach to this subject is our conviction that “computer science” is not a science and that its significance has little to do with computers. (xxiii)</p>
</blockquote>
<blockquote>
<p>Mathematics provides a framework for dealing precisely with notions of “what is.” Computation provides a framework for dealing precisely with notions of “how to.” (xxiii)</p>
</blockquote>
<h1 id="chapter-1-building-abstractions-with-procedures">Chapter 1: Building Abstractions with Procedures</h1>
<ul>
<li>A computational process evolves to manipulate data.</li>
<li>The evolution is controlled by a program, a pattern of rules.</li>
<li>Well-designed computational systems are modular.</li>
<li>This book uses the Scheme dialect of Lisp.</li>
<li>Lisp represents procedures as data.</li>
</ul>
<h2 id="the-elements-of-programming">The Elements of Programming</h2>
<p>There are three mechanisms for combining simple ideas to form more complex ideas in every powerful programming language:</p>
<ul>
<li>primitive expressions,</li>
<li>means of combination,</li>
<li>means of abstraction.</li>
</ul>
<p>Programming deals with <em>procedures</em> and <em>data</em> (which are almost the same thing in Lisp). Procedures manipulate data.</p>
<h3 id="expressions">Expressions</h3>
<ul>
<li>The REPL reads an expression, evaluates it, prints the result, and repeats.</li>
<li>A number is one kind of primitive expression.</li>
<li>An application of a primitive procedure is a compound expression.</li>
<li>Combination: list of expressions inside parentheses to denote procedure application.</li>
<li>The first element is the operator; the rest are the operands.</li>
<li>The value of the combination is the result of applying the value of the operator to the value of the operands.</li>
<li>Lisp combinations use prefix notation.</li>
<li>Combinations can be nested: an operator or operand can itself be another combination.</li>
</ul>
<h3 id="naming-and-the-environment">Naming and the Environment</h3>
<ul>
<li>Scheme names things with the <code>define</code>. This is the simplest means of abstraction.</li>
<li>The name-value pairs are stored in an <em>environment</em>.</li>
</ul>
<h3 id="evaluating-combinations">Evaluating Combinations</h3>
<ul>
<li>To evaluate a combination, do the following:
<ol type="1">
<li>Evaluate the subexpressions of the combination.</li>
<li>Apply the procedure (value of left more subexpression, the operator) to the arguments (values of other subexpressions, the operands).</li>
</ol></li>
<li>Before evaluating a combination, we must first evaluate each element inside it.</li>
<li>Evaluation is recursive in nature – one of its steps is invoking itself.</li>
<li>The evaluation of a combination can be represents with a tree.</li>
<li>Recursion is a powerful technique for dealing with hierarchical, tree-like objects.</li>
<li>To end the recursion, we stipulate the following:
<ol type="1">
<li>Numbers evaluate to themselves.</li>
<li>Built-in operators evaluate to machine instruction sequences.</li>
<li>Names evaluate to the values associated with them in the environment.</li>
</ol></li>
<li>Rule 2 is a special case of rule 3 if we consider the arithmetic operators to be names in the environment.</li>
<li>Evaluating <code>(define x 3)</code> does not apply <code>define</code> to two arguments; this is not a combination.</li>
<li>Exceptions such as these are <em>special forms</em>. Each one has its own evaluation rule.</li>
</ul>
<blockquote>
<p>Syntactic sugar causes cancer of the semicolon. (Alan Perlis)</p>
</blockquote>
<h3 id="compound-procedures">Compound Procedures</h3>
<ul>
<li>Procedure definitions are very powerful for abstraction.</li>
<li>A squaring procedure: <code>(define (square x) (* x x))</code>.</li>
<li>This is a compound procedure given the name <em>square</em>.</li>
<li>The general form of a procedure definition is <code>(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)</code>.</li>
<li>If the body contains more than one expression, each is evaluated in sequence and the value of the last one is returned.</li>
</ul>
<h3 id="the-substitution-model-for-procedure-application">The Substitution Model for Procedure Application</h3>
<p>This is the substation model:</p>
<blockquote>
<p>To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.</p>
</blockquote>
<p>An example of procedure application:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(f <span class="dv">5</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(sum-of-squares (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>) (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(sum-of-squares <span class="dv">6</span> <span class="dv">10</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> (square <span class="dv">6</span>) (square <span class="dv">10</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> <span class="dv">36</span> <span class="dv">100</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">136</span></span></code></pre></div>
<h4 id="applicative-order-versus-normal-order">Applicative order versus normal order</h4>
<ul>
<li>That example used <em>applicative order</em>: evaluate everything first, then apply the procedure to the arguments.</li>
<li>With <em>normal order</em>, operands are substituted in the procedure unevaluated. Only when it reaches primitive operators do combinations reduce to values.</li>
</ul>
<p>An example of normal order procedure application:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(f <span class="dv">5</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>(sum-of-squares (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>) (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> (square (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>)) (square (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>)))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> (<span class="op">*</span> (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>) (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>)) (<span class="op">*</span> (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>) (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>)))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> (<span class="op">*</span> <span class="dv">6</span> <span class="dv">6</span>) (<span class="op">*</span> <span class="dv">10</span> <span class="dv">10</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> <span class="dv">36</span> <span class="dv">100</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dv">136</span></span></code></pre></div>
<ul>
<li>In this example, normal order causes a few combinations to be evaluated multiple times.</li>
<li>Applicative: evaluate the arguments and then apply.</li>
<li>Normal: fully expand and then reduce.</li>
</ul>
<h3 id="conditional-expressions-and-predicates">Conditional Expressions and Predicates</h3>
<ul>
<li>To make more useful procedures, we need to be able to make tests and perform different operations accordingly.</li>
<li>We do <em>case analysis</em> in Scheme using <code>cond</code>.</li>
<li>Those conditional expressions work by testing each predicate. The consequent expression of the first clause with a true predicate is returned, and the other clauses are ignored.</li>
<li>A predicate is an expression that evaluates to true or false, or a procedure that returns true or false.</li>
<li>The symbol <code>else</code> can be used as the last clause – it will always evaluate to true.</li>
<li>The <code>if</code> conditional can be used when there are two cases.</li>
<li>Logical values can be combined with <code>and</code>, <code>or</code>, and <code>not</code>. The first two are special forms, not procedures.</li>
</ul>
<h3 id="example-square-roots-by-newtons-method">Example: Square Roots by Newton’s Method</h3>
<blockquote>
<p>But there is an important difference between mathematical functions and computer procedures. Procedures must be effective. (28)</p>
</blockquote>
<ul>
<li>In mathematics, you can say “the square root of <span class="math inline">x</span> is the nonnegative <span class="math inline">y</span> such that <span class="math inline">y^2 = x</span>.” This is not a procedure.</li>
<li>Mathematical functions describes things (declarative knowledge); procedures describe how to do things (imperative knowledge).</li>
<li>Declarative is <em>what is</em>, imperative is <em>how to</em>.</li>
</ul>
<h3 id="procedures-as-black-box-abstractions">Procedures as Black-Box Abstractions</h3>
<ul>
<li>Each procedure in a program should accomplish and identifiable task that can be used as a module in defining other procedures.</li>
<li>When we use a procedure as a “black box,” we are concerned with <em>what</em> it is doing but not <em>how</em> it is doing it.</li>
<li>This is called procedural abstraction. Its purpose is to suppress detail.</li>
</ul>
<blockquote>
<p>A user should not need to know how the procedure is implemented in order to use it. (35)</p>
</blockquote>
<h4 id="local-names">Local names</h4>
<ul>
<li>The choice of names for the procedure’s formal parameters should not matter to the user of the procedure.</li>
<li>Consequentially, the parameter names must be local to the body of the procedure.</li>
<li>The name of the formal parameter doesn’t matter; it is called a <em>bound variable</em>. The procedure <em>binds</em> its formal parameters.</li>
<li>If a variable is not bound, it is <em>free</em>.</li>
<li>The expressions in which a binding exists is called the <em>scope</em> of the name. For parameters of procedures, this is the body.</li>
<li>Using the same name for a bound variable and an existing free variable is called <em>capturing</em> the variable.</li>
<li>The names of the free variables <em>do</em> matter for the meaning of the procedure.</li>
</ul>
<h4 id="internal-definitions-and-block-structure">Internal definitions and block structure</h4>
<ul>
<li>Putting a definition in the body of a procedure makes it local to that procedure. This nesting is called <em>block structure</em>.</li>
<li>Now we have two kinds of name isolation: formal parameters and internal definitions.</li>
<li>By internalizing auxiliary procedures, we can often eliminate bindings by allowing variables to remain free.</li>
<li>Lexical scoping: free variables in a procedure refer to bindings in enclosing procedure definitions.</li>
</ul>
<h2 id="procedures-and-the-processes-they-generate">Procedures and the Processes They Generate</h2>
<blockquote>
<p>To become experts, we must learn to visualize the processes generated by various types of procedures. Only after we have developed such a skill can we learn to reliably construct programs that exhibit the desired behavior. (40)</p>
</blockquote>
<ul>
<li>A procedure is a pattern for the <em>local evolution</em> of a computation process: how one stage is built on the previous.</li>
<li>The global behavior of a computational process is much harder to reason about.</li>
<li>Processes governed by different types of procedures generate different “shapes” of evolution.</li>
<li>There are two important resources that computational processes consume: time and space.</li>
</ul>
<h3 id="linear-recursion-and-iteration">Linear Recursion and Iteration</h3>
<ul>
<li>The factorial of <span class="math inline">N</span> is defined as the product of the integers on the interval <span class="math inline">[1,N]</span>.</li>
<li>The naive <em>recursive</em> implementation creates a curved shape:</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(factorial <span class="dv">4</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (factorial <span class="dv">3</span>))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (factorial <span class="dv">2</span>)))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (<span class="op">*</span> <span class="dv">2</span> (factorial <span class="dv">1</span>))))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (<span class="op">*</span> <span class="dv">2</span> <span class="dv">1</span>)))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> <span class="dv">2</span>))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> <span class="dv">6</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span></span></code></pre></div>
<ul>
<li>The <em>iterative</em> implementation maintains a running product and multiplies the numbers from 1 to <span class="math inline">N</span> to it.</li>
<li>This creates a shape with a straight edge:</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(factorial <span class="dv">4</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">1</span> <span class="dv">1</span> <span class="dv">4</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">6</span> <span class="dv">4</span> <span class="dv">4</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">24</span> <span class="dv">5</span> <span class="dv">4</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span></span></code></pre></div>
<ul>
<li>Both compute the same mathematical function, but the computational processes evolve very differently.</li>
<li>The first one is a <em>linear recursive process</em>. The chain of deferred operations causes an expansion (as more operations are added) and a contraction (as the operations are performed).
<ul>
<li>The interpreter must keep track of all these operations.</li>
<li>It is a <em>linear</em> recursive process because the information it must keep track of (the call stack) grows linearly with <span class="math inline">N</span>.</li>
</ul></li>
<li>The second is a <em>linear iterative process</em>. It is iterative because it does not grow and shrink.
<ul>
<li>It is summarized by a fixed number of state variables and a rule to describe how they should update and when the process should terminate.</li>
<li>It is a <em>linear</em> iterative process because the number of steps grows linearly with <span class="math inline">N</span>.</li>
</ul></li>
<li>In the iterative process, the variables provide a complete description of the state of the process at any point.</li>
<li>In the recursive process, their is “hidden” information that makes it impossible to resume the process midway through.</li>
<li>The longer the chain of deferred operations, the more information must be maintained (in a stack, as we will see).</li>
<li>A recursive <em>procedure</em> is simply a procedure that refers to itself directly or indirectly.</li>
<li>A recursive <em>process</em> refers to the evolution of the process described above.</li>
<li>A recursive procedure can generate an iterative process in Scheme thanks to tail-call optimization. In other languages, special-purpose looping constructs are needed for this.</li>
</ul>
<h3 id="tree-recursion">Tree Recursion</h3>
<ul>
<li>With tree recursion, the procedure invokes itself more than once, causing the process to evolve in the shape of a tree.</li>
<li>The naive Fibonacci procedure calls itself twice each time it is invoked, so each branch splits into two at each level.</li>
</ul>
<blockquote>
<p>In general, the number of steps required by a tree-recursive process will be proportional to the number of nodes in the tree, while the space required will be proportional to the maximum depth of the tree. (49)</p>
</blockquote>
<ul>
<li>The iterative implementation of the Fibonacci procedure is vastly more efficient in space and in time.</li>
</ul>
<h4 id="example-counting-change">Example: Counting change</h4>
<p>Let <span class="math inline">f(A,N)</span> represent the number of ways of changing the amount A using <span class="math inline">N</span> kinds of coins. If the first kind of coin has denomination <span class="math inline">N</span>, then <span class="math inline">f(A,N) = f(A,N−1) + f(A−D,N)</span>. In words, there are two situations: where you do not use any of the first kind of coin, and when you do. The value of <span class="math inline">f(A,N−1)</span> assumes we don’t use the first kind at all; the value of <span class="math inline">f(A−D,N)</span> assumes we use one or more of the first kind.</p>
<p>That rule and a few degenerate cases is sufficient to describe an algorithm for counting the number of ways of changing amounts of money. We can define it with the following piecewise function:</p>
<p><span class="math display">
f(A,N) = \begin{cases}
1, &amp; \text{if $A = 0$,} \\
0, &amp; \text{if $A &lt; 0$ or $N = 0$,} \\
f(A,N-1) + f(A-D,N), &amp; \text{if $A &gt; 0$ and $N &gt; 0$.}
\end{cases}
</span></p>
<p>Like Fibonacci, the easy tree-recursive implementation involves a lot of redundancy. Unlike it, there is no obvious iterative solution (it is possible, just harder). One way to improve the performance of the tree-recursive process is to use <em>memoization</em> (maintaining a lookup table).</p>
<h3 id="orders-of-growth">Orders of Growth</h3>
<ul>
<li>Some processes consume more or less computational resources than others.</li>
<li>We compare this using <em>order of growth</em>, a gross measure of the resources required by a process as the inputs becomes larger.</li>
<li>Let <span class="math inline">n</span> be a parameter that measures the size of a problem – it could be the input itself, the tolerance, the number of rows in the matrix, etc. There are many properties that <span class="math inline">n</span> can measure.</li>
<li>Let <span class="math inline">R(n)</span> be the amount of resources the process requires for a problem of size <span class="math inline">n</span>. This could be time, space (amount of memory), number of registers used, etc.</li>
<li>We say that <span class="math inline">R(n)</span> has order of growth <span class="math inline">Θ(f(n))</span>, or <span class="math inline">R(n) = Θ(f(n))</span>, if there are positive constants <span class="math inline">A</span> and <span class="math inline">B</span> independent of <span class="math inline">n</span> such that <span class="math inline">Af(n) ≤ R(n) ≤ Bf(n)</span> for any sufficiently large value of <span class="math inline">n</span>.</li>
<li>The value <span class="math inline">R(n)</span> is sandwiched between <span class="math inline">Af(n)</span> and <span class="math inline">Bf(n)</span>.</li>
<li>The linear recursive process for computing factorials had <span class="math inline">Θ(n)</span> time and <span class="math inline">Θ(n)</span> space (both linear), whereas the linear iterative process had <span class="math inline">Θ(1)</span> space (constant).</li>
<li>The order of growth is a crude description of the behavior of a process.</li>
<li>Its importance is allowing us to see the <em>change</em> in the amount of resources required when you, say, increment <span class="math inline">n</span> or double <span class="math inline">n</span>.</li>
</ul>
<h3 id="exponentiation">Exponentiation</h3>
<p>One way to calculate b to the nth power is via the following recursive definition:</p>
<p><span class="math display">b^0 = 1, \qquad b^n = b * b^{n-1}.</span></p>
<p>In words, multiply the base to itself <span class="math inline">n</span> times. A faster method is to use successive squaring:</p>
<p><span class="math display">
b^n = \begin{cases}
\left(b^{n/2}\right)^2 &amp; \text{if $n$ is even,} \\
b * b^{n-1}, &amp; \text{if $n$ is odd.}
\end{cases}
</span></p>
<h3 id="greatest-common-divisors">Greatest Common Divisors</h3>
<ul>
<li>The GCD of integers <span class="math inline">a</span> and <span class="math inline">b</span> is the largest integer that divides both <span class="math inline">a</span> and <span class="math inline">b</span> with no remainder. For example, <span class="math inline">\gcd(16,28) = 4</span>.</li>
<li>Efficient algorithm uses <span class="math inline">\gcd(a,b) = \gcd(b,a\bmod b)</span>.</li>
<li>For example, we can reduce <code>(gcd 206 40)</code> as follows:</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">206</span> <span class="dv">40</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">40</span> <span class="dv">6</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">6</span> <span class="dv">4</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">4</span> <span class="dv">2</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">2</span> <span class="dv">0</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span></code></pre></div>
<ul>
<li>This always works: you always get a pair where the second number is zero, and the other number is the GCD of the original pair.</li>
<li>This is called <em>Euclid’s Algorithm</em>.</li>
<li>Lamé’s Theorem: If Euclid’s Algorithm requires <span class="math inline">k</span> steps to compute the GCD of some pair <span class="math inline">(a,b)</span>, then <span class="math inline">\min\{a,b\} ≥ \text{Fib}(k)</span>.</li>
</ul>
<h3 id="example-testing-for-primality">Example: Testing for Primality</h3>
<h4 id="searching-for-divisors">Searching for divisors</h4>
<ul>
<li>One way to test for primality is to find the number’s divisors.</li>
<li>A number is prime if and only if it is its own smallest divisor.</li>
</ul>
<h4 id="the-fermat-test">The Fermat test</h4>
<p>The Fermat test is a <span class="math inline">Θ(log(n))</span> primality test based on Fermat’s Little Theorem:</p>
<blockquote>
<p>If <span class="math inline">n</span> is a prime number and a is any positive integer less than <span class="math inline">n</span>, then a raised to the <span class="math inline">n</span>th power is congruent to a modulo <span class="math inline">n</span>.</p>
</blockquote>
<p>The test works like this:</p>
<ol type="1">
<li>Given a number <span class="math inline">n</span>, pick a random number <span class="math inline">a &lt; n</span> and calculate <span class="math inline">a^n\bmod n</span>.</li>
<li>Fail: If the result is not equal to <span class="math inline">a</span>, then <span class="math inline">n</span> is not prime.</li>
<li>Pass: If the result is equal to <span class="math inline">a</span>, then <span class="math inline">n</span> is likely prime.</li>
<li>Repeat. The more times the number passes the test, the more confident we are that <span class="math inline">n</span> is prime. If there is a single failure, <span class="math inline">n</span> is certainly not prime.</li>
</ol>
<h4 id="probabilistic-methods">Probabilistic methods</h4>
<ul>
<li>Most familiar algorithms compute an answer that is guaranteed to be correct. Not so with the Fermat test.</li>
<li>We can make the probability error in our primality test as small as we like simply by running more tests – except for Carmichael numbers.</li>
<li>If <span class="math inline">n</span> passes the test for one random value of a, the chances are more than 50% that <span class="math inline">n</span> is prime.</li>
<li>Probabilistic algorithms: algorithms for which one can prove that the chance of error becomes arbitrarily small.</li>
</ul>
<blockquote>
<p>Numbers that fool the Fermat test are called Carmichael numbers, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a “correct” algorithm. Considering an algorithm to be inadequate for the first reason but not for the second <em>illustrates the difference between mathematics and engineering</em>. (69)</p>
</blockquote>
<h2 id="formulating-abstractions-with-higher-order-procedures">Formulating Abstractions with Higher-Order Procedures</h2>
<blockquote>
<p>We have seen that procedures are, in effect, abstractions that describe compound operations on numbers independent of the particular numbers. (74)</p>
</blockquote>
<ul>
<li>We could always use <code>(* x x x)</code> instead of using a cube procedure, but this would be a disadvantage.</li>
</ul>
<blockquote>
<p>One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the abstractions directly. (75)</p>
</blockquote>
<ul>
<li>Even with procedures, we are still limiting ourselves if we only ever let parameters be numbers.</li>
<li>To abstract more general programming patterns, we need to write precedes that take other procedures as arguments and return new procedures.</li>
<li>These are called <em>higher-order</em> procedures.</li>
</ul>
<h3 id="procedures-as-arguments">Procedures as Arguments</h3>
<p>Procedures that compute a sum are all similar. They are all based on the following template:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(&lt;name&gt; a b)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>      <span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      (<span class="op">+</span> (&lt;term&gt; a)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>         (&lt;name&gt; (&lt;next&gt; a) b))))</span></code></pre></div>
<p>This is a useful abstraction, just as sigma notation in math is useful because the summation of a series is so common.</p>
<blockquote>
<p>The power of sigma notation is that it allows mathematicians to deal with the concept of summation itself rather than only with particular sums. (77)</p>
</blockquote>
<h3 id="constructing-procedures-using-lambda">Constructing Procedures Using <code>Lambda</code></h3>
<p><code>lambda</code> creates anonymous procedures. They are just like the procedures created by <code>define</code>, but without a name: <code>(lambda (&lt;formal-parameters&gt;) &lt;body&gt;)</code>.</p>
<p>A lambda expression can be used as the operand in a combination. It will be evaluated to a procedure and applied to the arguments (the evaluated operands). The name comes from the λ-calculus, which was introduced by Alonzo Church.</p>
<h4 id="using-let-to-create-local-variables">Using <code>let</code> to create local variables</h4>
<ul>
<li>We often need local variables other than the ones that have been bound as formal parameters.</li>
<li>We can do this with a lambda expression that takes the local variables as arguments, but this is so common that there is a special <code>let</code> form that does it.</li>
</ul>
<p>The general form of a let-expression is</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((&lt;var1&gt; &lt;exp1&gt;)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>      (&lt;var2&gt; &lt;exp2&gt;)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      (&lt;varn&gt; &lt;expn&gt;))</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  &lt;body&gt;)</span></code></pre></div>
<p>This is just syntactic sugar for</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>((<span class="kw">lambda</span> (&lt;var1&gt; &lt;var2&gt; <span class="op">...</span> &lt;varn&gt;)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>   &lt;body&gt;)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a> &lt;exp1&gt;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a> &lt;exp2&gt;</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a> <span class="op">...</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a> &lt;expn&gt;)</span></code></pre></div>
<ul>
<li>The scope of a variable in a let-expression is the body.</li>
<li>This allows variables to be bound as locally as possible.</li>
<li>The variables in the let-expression are parallel and independent. They cannot refer to each other, and their order does not matter.</li>
<li>You can use let-expressions (<code>let</code>, <code>let*</code>, and <code>letrec</code>) instead of internal definitions (block structure).</li>
</ul>
<h3 id="procedures-as-general-methods">Procedures as General Methods</h3>
<p>So far, we have seen</p>
<ul>
<li>compound procedures that abstract patterns of numerical operators (mathematical functions), independent of the particular numbers;</li>
<li>higher-order procedures that express a more powerful kind of abstraction, independent of the procedures involved.</li>
</ul>
<p>Now we will take it a bit further.</p>
<h4 id="finding-roots-of-equations-by-the-half-interval-method">Finding roots of equations by the half-interval method</h4>
<ul>
<li>The <em>half-interval</em> method: a simple but powerful technique for finding the solutions to <span class="math inline">f(x) = 0</span>.</li>
<li>Given <span class="math inline">f(a) &lt; 0 &lt; f(b)</span>, there must be at least one zero between <span class="math inline">a</span> and <span class="math inline">b</span>.</li>
<li>To narrow it down, we let <span class="math inline">x</span> be the average of <span class="math inline">a</span> and <span class="math inline">b</span>, and then replace either the left bound or the right bound with it.</li>
</ul>
<h4 id="finding-fixed-points-of-a-function">Finding fixed points of a function</h4>
<ul>
<li>A number <span class="math inline">x</span> is a <em>fixed point</em> of a function if <span class="math inline">f(x) = x</span>.</li>
<li>In some cases, repeatedly applying the function to an initial guess will converge on the fixed point.</li>
<li>The procedure we made earlier for finding square roots is actually a special case of the fixed point procedure.</li>
</ul>
<h3 id="procedures-as-returned-values">Procedures as Returned Values</h3>
<p>Passing procedures as arguments gives us expressive power; Returning procedures from functions gives us even more. For example, we can write a procedure that creates a new procedure with average damping:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(average-damp f)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (average x (f x))))</span></code></pre></div>
<p>If we use <code>average-damp</code> on <code>square</code>, we actually get a procedure that takes the sum of the numbers from 1 to n:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>((average-damp square) <span class="dv">10</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span> <span class="dv">10</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span></span></code></pre></div>
<blockquote>
<p>In general, there are many ways to formulate a process as a procedure. Experienced programmers know how to choose procedural formulations that are particularly perspicuous, and where useful elements of the process are exposed as separate entities that can be reused in other applications.</p>
</blockquote>
<h4 id="newtons-method">Newton’s method</h4>
<p>The square-root procedure we did earlier was a special case of Newton’s method. Given a function <span class="math inline">f(x)</span>, the solution to <span class="math inline">f(x) = 0</span> is given by the fixed point of</p>
<p><span class="math display">x ↦ x − \frac{f(x)}{f&#39;(x)}.</span></p>
<p>Newton’s method converges very quickly – much faster than the half-interval method in favorable cases. We need a procedure to transform a function into its derivative (a new procedure). We can use a small dx for this:</p>
<p><span class="math display">f&#39;(x) = \frac{f(x+dx) - f(x)}{dx}.</span></p>
<p>This translates to the following procedure:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(deriv f)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (<span class="op">/</span> (<span class="op">-</span> (f (<span class="op">+</span> x dx)) (f x)) dx)))</span></code></pre></div>
<p>Now we can do things like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(cube x) (<span class="op">*</span> x x x))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> dx </span><span class="fl">0.00001</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>((deriv cube) <span class="dv">5</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="fl">75.00014999664018</span></span></code></pre></div>
<h4 id="abstractions-and-first-class-procedures">Abstractions and first-class procedures</h4>
<ul>
<li>Compound procedures permit us to express general methods of computing as explicit elements in our programming language.</li>
<li>Higher-order procedures permit us to manipulate these general methods to create further abstractions.</li>
<li>We should always be on the lookout for underlying abstractions that can be brought out and generalized.</li>
<li>This doesn’t mean we should always program in the most abstract form possible; there is a level appropriate for each task.</li>
<li>Elements with the fewest restrictions are <em>first-class</em>:
<ul>
<li>They may be named by variables.</li>
<li>They may be passed as arguments to procedures.</li>
<li>They may be returned as the results of procedures.</li>
<li>They may be included in data structures.</li>
</ul></li>
<li>In Lisp, procedures have first-class status. This gives us an enormous gain in expressive power.</li>
</ul>
<h1 id="chapter-2-building-abstractions-with-data">Chapter 2: Building Abstractions with Data</h1>
<ul>
<li>Recap: we looked at computations processes and the role of procedures in program design.
<ul>
<li>We saw primitive data (numbers), primitive operations (arithmetic operators), combinations, and abstractions.</li>
<li>A procedure is a pattern for the local evolution of a process.</li>
<li>We also saw higher-order procedures.</li>
</ul></li>
<li>Now we are going to look at more complex data.</li>
<li>Before we made compound procedures from other procedures; now we will make compound data from other, simpler data.</li>
</ul>
<blockquote>
<p>[…] the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language. (108)</p>
</blockquote>
<ul>
<li>Consider functions dealing with rational numbers: this becomes awkward if they can return only one number.</li>
<li>This is where compound data objects come in handy.</li>
<li><em>Data abstraction</em> is separating representation from use.</li>
<li>Data abstraction enables us to construct <em>abstraction barriers</em> between different parts of the program.</li>
<li>We will look at closure, conventional interfaces, symbolic expressions, generic operations, and data-directed programming.</li>
</ul>
<h2 id="introduction-to-data-abstraction">Introduction to Data Abstraction</h2>
<ul>
<li>We already know about procedural abstraction: the procedure is a black box, and we don’t care how it is implemented internally.</li>
<li>Data abstractions allows us to isolate how a compound data object is used from the details of its actual representation.</li>
</ul>
<blockquote>
<p>That is, our programs should use data in such a way as to make no assumptions about the data that are not strictly necessary for performing the task at hand.</p>
</blockquote>
<ul>
<li>There is a concrete data representation behind the abstraction.</li>
<li>The interface between the two parts of the system is a set of procedures: selectors and constructors.</li>
</ul>
<h3 id="example-arithmetic-operations-for-rational-numbers">Example: Arithmetic Operations for Rational Numbers</h3>
<ul>
<li>We want to add, subtract, multiply, divide, and test equality with our rational numbers.</li>
<li>We assume we have <code>(make-rat &lt;n&gt; &lt;d&gt;)</code>, <code>(number &lt;x&gt;)</code>, and <code>(denom &lt;x&gt;)</code> available as the constructor and selectors.</li>
<li>This is wishful thinking, and it is a good technique.</li>
<li>A <em>pair</em> is a concrete structure that we create with <code>cons</code>.</li>
<li>We extract the parts of the pair with <code>car</code> and <code>cdr</code>.</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> x </span>(<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">car</span> x)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">cdr</span> x)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> y </span>(<span class="kw">cons</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> z </span>(<span class="kw">cons</span> x y))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>(<span class="kw">car</span> (<span class="kw">car</span> z))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>(<span class="kw">car</span> (<span class="kw">cdr</span> z))</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<ul>
<li>This is all the glue we need to implement all sorts of complex data structures.</li>
<li>Data objects constructed from pairs are <em>list-structured</em> data.</li>
<li>To ensure that our rational numbers are always in lowest terms, we need <code>make-rat</code> to divide the numerator and the denominator by their greatest common divisor (GCD).</li>
</ul>
<h3 id="abstractions-barriers">Abstractions Barriers</h3>
<blockquote>
<p>In general, the underlying idea of data abstraction is to identify for each type of data object a basic set of operations in terms of which all manipulations of data objects of that type will be expressed, and then to use only those operations in manipulating the data. (118)</p>
</blockquote>
<ul>
<li>The details on the other side of an abstraction barrier are irrelevant to the code on this side.</li>
<li>This makes programs easier to maintain and modify.</li>
</ul>
<blockquote>
<p>Constraining the dependence on the representation to a few interface procedures helps us design programs as well as modify them, because it allows us to maintain the flexibility to consider alternate implementations. (121)</p>
</blockquote>
<h3 id="what-is-meant-by-data">What Is Meant by Data?</h3>
<ul>
<li>Data is defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.</li>
<li>For rationals, we have the following definition:
<ol type="1">
<li>We can construct a rational <code>x</code> with <code>(make-rat n d)</code>.</li>
<li>We can select the numerator with <code>(numer x)</code>.</li>
<li>We can select the denominator with <code>(denom x)</code>.</li>
<li>For all values of <code>x</code>, <code>(/ (numer x) (denom x))</code> must equal <span class="math inline">n/d</span>.</li>
</ol></li>
<li>For pairs, it is even simpler: we need three operations, which we will call <code>cons</code>, <code>car</code>, and <code>cdr</code>, such that if <code>z</code> is <code>(cons x y)</code>, then <code>(car z)</code> is <code>x</code> and <code>(cdr z)</code> is <code>y</code>.</li>
<li>Any triple of procedures satisfying this definition can be used to implement pairs. In fact, we can do it with procedures themselves and nothing else:</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cons</span> x y)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (m)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="op">=</span> m <span class="dv">0</span>) x y)))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">car</span> z) (z <span class="dv">0</span>))</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cdr</span> z) (z <span class="dv">1</span>))</span></code></pre></div>
<ul>
<li>This doesn’t look like <em>data</em>, but it works.</li>
<li>This is how you implement pairs in the λ-calculus.</li>
<li>In real Lisp implementations, pairs are implemented directly, for reasons of efficiency – but they <em>could</em> be implemented this way and you wouldn’t be able to tell the difference.</li>
</ul>
<blockquote>
<p>[…] the ability to manipulate procedures as objects automatically provides the ability to represent compound data. (125)</p>
</blockquote>
<ul>
<li>This style of programming is often called <em>message passing</em>.</li>
</ul>
<h3 id="extended-exercise-interval-arithmetic">Extended Exercise: Interval Arithmetic</h3>
<ul>
<li>We want to design a system that allows us to manipulate inexact quantities with known precision (uncertainty).</li>
<li>To do this, we need arithmetic operations for combining intervals – ranges of possible values.</li>
</ul>
<h2 id="hierarchical-data-and-the-closure-property">Hierarchical Data and the Closure Property</h2>
<ul>
<li>Paris form a primitive “glue” for compound data objects.</li>
<li>We can visualize cons pairs with <em>box-and-pointer</em> notation.</li>
<li>Each pair is a double box. Both the left box and the right box contain an arrow pointing to something else: either to a primitive data object, or to another cons pair.</li>
<li>The <em>closure property</em> of cons is the ability to make pairs whose elements are pairs.</li>
<li>Closure allows us to create hierarchal structures.</li>
<li>We have been using closure all along with combinations. Now, we are going to use closure for compound data.</li>
</ul>
<h3 id="representing-sequences">Representing Sequences</h3>
<ul>
<li>Among the things we can build with pairs is a sequence.</li>
<li>A sequence is an ordered collection of data objects.</li>
<li>The <code>car</code> of each pair is the corresponding item in the chain, and the <code>cdr</code> of the pair is the next pair in the chain.</li>
<li>The <code>cdr</code> of the final pair is a special value, nil.</li>
<li>This sequence of nested conses is called a <em>list</em>.</li>
<li>We usually represent such lists by placing each element one after the other and enclosing the whole thing in parentheses.</li>
<li>The procedure <code>car</code> gives us the first item; <code>cdr</code> gives us the sublist containing all items but the first; <code>cons</code> returns a list with an item added to the front.</li>
<li>The nil value can be thought of as an empty list.</li>
</ul>
<h4 id="list-operations">List operations</h4>
<ul>
<li>We can get at the nth item of the list by <code>cdr</code> ing one less than <span class="math inline">n</span> times, and then taking the <code>car</code>.</li>
<li>Scheme includes a primitive predicate <code>null?</code> which is true if its argument is the empty list.</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">list-ref</span> items n)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">=</span> n <span class="dv">0</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">car</span> items)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">list-ref</span> (<span class="kw">cdr</span> items) (<span class="op">-</span> n <span class="dv">1</span>))))</span></code></pre></div>
<ul>
<li>We often write recursive procedures that <code>cdr</code> all the way through the list.</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">length</span> items)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="kw">null?</span> items)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>      <span class="dv">0</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>      (<span class="op">+</span> <span class="dv">1</span> (<span class="kw">length</span> (<span class="kw">cdr</span> items)))))</span></code></pre></div>
<ul>
<li>We can build up lists to return by <code>cons</code> ing them up.</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">append</span> list1 list2)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="kw">null?</span> list1)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      list2</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">cons</span> (<span class="kw">car</span> list1 (<span class="kw">append</span> (<span class="kw">cdr</span> list1) list2)))))</span></code></pre></div>
<h4 id="mapping-over-lists">Mapping over lists</h4>
<ul>
<li>Useful operation: applying the same transformation to each element in a list, producing a new list.</li>
<li>This is a higher-order procedure called <code>map</code>.</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(map f xs)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="kw">null?</span> xs)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>      nil</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">cons</span> (f (<span class="kw">car</span> xs))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            (map f (<span class="kw">cdr</span> xs)))))</span></code></pre></div>
<ul>
<li>Using map, we can do <code>(map abs (list -1 5 -3 0 2 -2))</code> and get back the list <code>(1 5 3 0 2 2)</code>.</li>
<li>Map establishes a higher level of abstraction for dealing with lists. It suppressive the recursive detail.</li>
<li>We think about the process differently when we use map.</li>
</ul>
<blockquote>
<p>[…] this abstraction gives us the flexibility to change the low-level details of how sequences are implemented, while preserving the conceptual framework of operations that transform sequences to sequences. (144)</p>
</blockquote>
<h3 id="hierarchical-structures">Hierarchical Structures</h3>
<ul>
<li>We can represent lists whose elements themselves may also be lists. We can also think of them as <em>trees</em>.</li>
<li>Recursion is a natural tool for dealing with trees.</li>
<li>The primitive predicate <code>pair?</code> returns true if its argument is a pair (formed with cons).</li>
<li>We can count the number of leaves in a tree with this:</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(count-leaves x)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cond</span> ((<span class="kw">null?</span> x) <span class="dv">0</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        ((<span class="kw">not</span> (<span class="kw">pair?</span> x)) <span class="dv">1</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">else</span> (<span class="op">+</span> (count-leaves (<span class="kw">car</span> x))</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                 (count-leaves (<span class="kw">cdr</span> x))))))</span></code></pre></div>
<h4 id="mapping-over-trees">Mapping over trees</h4>
<ul>
<li>We can deal with trees using <code>map</code> together with recursion.</li>
<li>This makes it possible to apply an operation to all the leaves in a tree, for example.</li>
</ul>
<h3 id="sequences-as-conventional-interfaces">Sequences as Conventional Interfaces</h3>
<ul>
<li>Abstractions preserves the flexibility to experiment with alternative representations.</li>
<li>Another powerful design principle for working with data structures is the use of conventional interfaces.</li>
<li>To make abstract operations for things other than numbers, we need to have a conventional style in which we manipulate data.</li>
</ul>
<h4 id="sequence-operations">Sequence operations</h4>
<ul>
<li>Key to organizing programs to reflect signal-flow structure: focus on the signals and represent them as lists.</li>
<li>To help, we can implement <code>filter</code> and <code>accumulate</code>.</li>
<li>Expressing programs as sequence operations helps us make program designs that are <em>modular</em> – made of relatively independent pieces that we can connect in flexible ways.</li>
<li>This is a strategy for controlling complexity.</li>
<li>A vast range of operations can be expressed as sequence operations, even if you don’t realize it at first.</li>
<li>Sequences (here, they are lists) serve as a conventional interface for the modules of the program.</li>
</ul>
<h4 id="nested-mappings">Nested mappings</h4>
<ul>
<li>For many computations, the sequence paradigm can be used where loops would otherwise be needed.</li>
<li>Sometimes we need to use <em>nested</em> mappings, where each mapping maps to a second set of mappings.</li>
<li>We can use <code>mapcat</code> to flatten the nested mapping result into one list at the end.</li>
<li>The procedure for computing all permutations of a set is pure magic: this is wishful thinking in action!</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(permutations s)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="kw">null?</span> s)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">list</span> nil)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>      (mapcat (<span class="kw">lambda</span> (x)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>                (map (<span class="kw">lambda</span> (p) (<span class="kw">cons</span> x p))</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>                     (permutations (<span class="kw">remove</span> x s))))</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>              s)))</span></code></pre></div>
<h3 id="example-a-picture-language">Example: A Picture Language</h3>
<ul>
<li>We will use a simple language for drawing pictures.</li>
<li>The data objects are represented as procedures rather than as list structure.</li>
</ul>
<h4 id="the-picture-language">The picture language</h4>
<ul>
<li>There is only one kind of element, called a <em>painter</em>.</li>
<li>The painter draws an image transformed into a parallelogram.</li>
<li>We combine images with operations like <code>beside</code> and <code>below</code>.</li>
<li>We transform single images with operations like <code>flip-vert</code> and <code>flip-horiz</code>.</li>
<li>We can build up complexity easily because painters are closed under the language’s means of combination (this is closure).</li>
</ul>
<h4 id="higher-order-operations">Higher-order operations</h4>
<ul>
<li>Just as we have higher-order procedures, we can have higher-order painting operations.</li>
<li>We can manipulate the painter operations rather than manipulating the painters directly.</li>
</ul>
<h4 id="frames">Frames</h4>
<ul>
<li>Painters paint their contents in frames.</li>
<li>A frame can be represented by three vectors: a position vector for one of the corners, and two vectors going along the edges.</li>
<li>We can use data abstraction to avoid being specific about how these vectors will actually be represented.</li>
<li>We will use coordinates in the unit square.</li>
<li>We can use basic vector operations to map an image coordinate into a pair of coordinates within the frame.</li>
</ul>
<h4 id="painters">Painters</h4>
<ul>
<li>A painter is a procedure that takes a frame as an argument and draws its image transformed to fit in the frame.</li>
<li>The details of primitive painters depend on the characteristics of the graphics system.</li>
<li>Painters as procedures is a powerful abstraction barrier.</li>
</ul>
<h4 id="transforming-and-combining-painters">Transforming and combining painters</h4>
<ul>
<li>Operations on painters invoke the original painters with new frames drives from the argument frame.</li>
<li>They are all based on the procedure <code>transform-painter</code>.</li>
</ul>
<h4 id="levels-of-language-for-robust-design">Levels of language for robust design</h4>
<ul>
<li>The picture language uses abstraction with procedures and data.</li>
<li>Painters are the data abstraction.</li>
<li>This example also uses <em>stratified design</em>, the notion that a complex system should be structured as a sequence of levels.</li>
<li>Each time we start a new level, we treat the old complex things as primitive black boxes and combine them.</li>
<li>Stratified design helps make programs <em>robust</em>: small changes in a specification will likely mean small changes in the program.</li>
</ul>
<blockquote>
<p>In general, each level of a stratified design provides a different vocabulary for expressing the characteristics of the system, and a different kind of ability to change it.</p>
</blockquote>
<h2 id="symbolic-data">Symbolic Data</h2>
<ul>
<li>So far we have constructed compound data from numbers only.</li>
<li>Now, we will work with arbitrary symbols.</li>
</ul>
<h3 id="quotation">Quotation</h3>
<ul>
<li>Lists containing symbols look just like expressions (code).</li>
<li>We need to <em>quote</em> data objects to manipulate symbols.</li>
<li>To make the list <code>(a b)</code>, we can’t just do <code>(list a b)</code> because this will evaluate <code>a</code> and <code>b</code>.</li>
<li>This is just like natural language. If I say, “Say your name,” you will say the <em>value</em> of “your name.” If I instead say, “Say ‘your name,’” you will literally say the words “your name.”</li>
<li>To quote in Lisp, we place a single quotation mark at the beginning of the object to be quoted.</li>
<li>Here is the difference between symbols and their values:</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> a </span><span class="dv">1</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> b </span><span class="dv">2</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">list</span> a b)   <span class="co">; =&gt; (1 2)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">list</span> &#39;a &#39;b) <span class="co">; =&gt; (a b)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">list</span> &#39;a b)  <span class="co">; =&gt; (a 2)</span></span></code></pre></div>
<ul>
<li>We can write lists directly with quotation rather than using <code>cons</code> or list, and we can represent the empty list with <code>'()</code>.</li>
<li>We need one more primitive now: <code>eq?</code>. This tests to see if two symbols are the same.</li>
</ul>
<h3 id="example-symbolic-differentiation">Example: Symbolic Differentiation</h3>
<ul>
<li>Consider a procedure that performs symbolic differentiation of algebraic expressions. We need symbols for this.</li>
<li>We will worry about representation later (data abstraction).</li>
</ul>
<h4 id="the-differentiation-program-with-abstract-data">The differentiation program with abstract data</h4>
<ul>
<li>To start, we will only consider addition and multiplication.</li>
<li>We need the constant rule, the sum rule, and the product rule.</li>
<li>We will assume we already have these procedures:</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>(variable? e)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>(same-variable? v1 v2)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>(sum? e)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>(addend e)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>(augend e)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>(make-sum a1 a2)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>(product? e)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>(multiplier e)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>(multiplicand e)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>(make-product m1 m2)</span></code></pre></div>
<h4 id="representing-algebraic-expressions">Representing algebraic expressions</h4>
<ul>
<li>There are many ways we could represent algebraic expressions.</li>
<li>The most straightforward is in parenthesized Polish notation: Lisp syntax.</li>
<li>We can simplify the answers just like we did in the rational number example: by changing the constructors.</li>
<li>Simplifying the way a human would is hard, partly because the most “simplified” form is sometimes subjective.</li>
</ul>
<h3 id="example-representing-sets">Example: Representing Sets</h3>
<p>There are a number of possible ways we could represent sets. A set is a collection of distinct objects. Our sets need to work with the following operations:</p>
<ul>
<li><code>union-set</code>: new set containing all items of given sets</li>
<li><code>intersection-set</code>: new set containing only the items that all given sets share</li>
<li><code>element-of-set?</code>: predicate for an item’s presence in a set</li>
<li><code>adjoin-set</code>: new set containing one new item</li>
</ul>
<h4 id="sets-as-unordered-lists">Sets as unordered lists</h4>
<ul>
<li>One method is to just use lists. Each time we add a new element, we have to check to make sure it isn’t already in the set.</li>
<li>This isn’t very efficient.</li>
<li>The time complexity of <code>element-of-set?</code> (and therefore for <code>adjoin-set</code>) is <span class="math inline">Θ(n)</span>.</li>
<li>For union and intersection, it’s <span class="math inline">Θ(n^2)</span>.</li>
<li>If we don’t eliminate duplicates, most operations are faster.</li>
<li>On the other hand, the sets grow in size rapidly, which may cause an overall decrease in performance.</li>
</ul>
<h4 id="sets-as-ordered-lists">Sets as ordered lists</h4>
<ul>
<li>A more efficient representation is a sorted list.</li>
<li>We will only consider sets of numbers to keep things simple.</li>
<li>Now, scanning the entire list in <code>element-of-set?</code> is a worst-case scenario. Most of the time we won’t have to.</li>
<li>On average we should expect to scan about half of the set.</li>
<li>This is still <span class="math inline">Θ(n)</span>; however, intersection gets much faster. Instead of <span class="math inline">Θ(n^2)</span>, it is <span class="math inline">Θ(n)</span>.</li>
</ul>
<h4 id="sets-as-binary-trees">Sets as binary trees</h4>
<ul>
<li>An even more efficient representation: binary trees.</li>
<li>Each node contains an element of the set.</li>
<li>The left branch contains smaller numbers, and the right branch contains larger numbers.</li>
<li>The same set can be represented by a tree in many ways.</li>
<li>If the tree is balanced, each subtree is about half the size of the original tree.</li>
<li>This allows us to do <code>element-of-set?</code> in <span class="math inline">Θ(\log(n))</span> time.</li>
<li>We will use the following list structure to represent trees: each node is the list <code>(number left-subtree right-subtree)</code>.</li>
<li>Efficiency hinges on the tree being balanced.</li>
<li>We can write a procedure to balance trees, or we could use a difference data structure (B-trees or red-black trees).</li>
</ul>
<h4 id="sets-and-information-retrieval">Sets and information retrieval</h4>
<ul>
<li>The techniques discussed for sets show up again and again in information retrieval.</li>
<li>In a data-management system, each record is identified by a key.</li>
<li>The key must be unique.</li>
<li>The simplest, least efficient method is to use a set of records represented by an unordered list. This provides <span class="math inline">Θ(n)</span> access.</li>
<li>For “random access,” meaning <span class="math inline">Θ(1)</span> access time complexity, trees are usually used.</li>
<li>Data abstraction is important here – you could begin by using unordered lists, and then change the constructor and selectors to use a tree representation.</li>
</ul>
<h3 id="example-huffman-encoding-trees">Example: Huffman Encoding Trees</h3>
<ul>
<li>We can represent data as sequences of ones and zeros (bits).</li>
<li>Codes like ASCII are fixed-length. Each symbol is represented by the same number of bits.</li>
<li>On the other hand, Morse code is variable-length. Since <em>e</em> is the most common letter, it is represented by a single dot.</li>
<li>The issue with variable-length is that you must have a way of knowing when you’ve reached the end of a symbol.</li>
<li>Morse code uses a temporal pause. Prefix codes, like Huffman encoding, ensure that no code for a symbol is a prefix of the code for another symbol. This eliminates any ambiguity.</li>
<li>A Huffman code can be represented as a binary tree with a symbol and its weight (relative frequency) at each leaf.</li>
<li>Each non-leaf node has a weight (sum of all below) and the set of all the symbols below it. The root node has the set of all the symbols in the tree.</li>
<li>Each left branch is a zero, and each right branch is a one.</li>
</ul>
<h4 id="generating-huffman-trees">Generating Huffman trees</h4>
<ul>
<li>Huffman gave an algorithm for constructing the best code for a given set of symbols and their relative frequencies.</li>
<li>Begin with all the nodes as leaves, then form a node branching off to the two least frequent symbols.</li>
<li>Repeat until there is only one node left, the root node.</li>
</ul>
<h4 id="representing-huffman-trees">Representing Huffman trees</h4>
<ul>
<li>Leaves are represented by the list beginning with the symbol <code>leaf</code> and with two more elements: the symbol and the weight.</li>
<li>Trees are represented by the list <code>(left right symbols weight)</code>, where <code>left</code> and <code>right</code> are subtrees, <code>symbols</code> is a list of the symbols underneath the node, and <code>weight</code> is the sum of the weights of all the leaves beneath the node.</li>
</ul>
<h2 id="multiple-representations-for-abstract-data">Multiple Representations for Abstract Data</h2>
<ul>
<li>Data abstraction lets use write specify programs that work independently of the chosen representation for data objects.</li>
<li>We erect abstraction barriers to control complexity.</li>
<li>This still isn’t powerful enough – it doesn’t always make sense to speak of the “underlying representation.”</li>
<li>We might want to deal with multiple representations.</li>
<li>For example, complex numbers can be represented in rectangular form or in polar form.</li>
<li>We need abstraction barriers that isolate representation from use <em>and</em> others that isolate design choices.</li>
<li>We want to permit multiple design choices to coexist.</li>
<li>This is important for modularity.</li>
<li>We will construct <em>generic procedures</em>, which can operate on data that may be represented in more than one way.</li>
<li>We will accomplish this with <em>type tags</em>. We will also discuss <em>data-directed</em> programming.</li>
<li>We now have horizontal abstraction barriers, separating higher-level from lower-level, and vertical ones, separately alternative representations.</li>
</ul>
<h3 id="representations-for-complex-numbers">Representations for Complex Numbers</h3>
<ul>
<li>This system will perform arithmetic operations on complex numbers represented in rectangular form <em>or</em> polar form.</li>
<li>Different representations are appropriate for different operations.</li>
<li>We have four selectors: <code>real-part</code>, <code>imag-part</code>, <code>magnitude</code>, and <code>angle</code>.</li>
<li>We have two constructors: <code>make-from-real-img</code> and <code>make-from-mag-ang</code>.</li>
</ul>
<h3 id="tagged-data">Tagged Data</h3>
<ul>
<li>One way to view data abstraction: principle of least commitment.</li>
<li>We waited until the last minute to choose the concrete representation, retaining maximum flexibility.</li>
<li>We can take it even further: let’s use <em>both</em>!</li>
<li>To include both in the same system, we need some way of distinguishing between them.</li>
<li>We will use a symbol as a type tag.</li>
<li>Each generic selector uses case analysis to check the tag of its argument and dispatches the appropriate procedure.</li>
<li>Our general mechanism for interfacing separate representations: in a specific implementation, the data object is an untyped pair. The generic selectors dispatch on the tag and strip off the tag before passing the data to the appropriate procedure.</li>
</ul>
<h3 id="data-directed-programming-and-additivity">Data-Directed Programming and Additivity</h3>
<ul>
<li>The strategy of checking the type and calling an appropriate procedure is called dispatching on type.</li>
<li>The implementation in the <a href="#tagged-data">previous section</a> had two significant weaknesses:
<ol type="1">
<li>The generic interface procedures must know about all the different representations. Adding a new representation means adding a clause to all the generic procedures.</li>
<li>We must guarantee that no two procedures have the same name.</li>
</ol></li>
<li>The underlying issue: the technique we used was not <em>additive</em>.</li>
<li>This is a source of inconvenience and error.</li>
<li>The solution is a technique known as data-directed programming.</li>
<li>We imagine a table with operations on one axis and possible types on the other axis.</li>
<li>Before, we used case analysis to perform explicit dispatch.</li>
<li>With DDP, we use a single procedure that looks up the operation name and the argument type in the table.</li>
<li>We assume we have procedures <code>put</code> and <code>get</code>.</li>
<li><code>(put op type item)</code> installs <code>item</code> in the table.</li>
<li><code>(get op type)</code> retrieves the item.</li>
</ul>
<h4 id="message-passing">Message passing</h4>
<ul>
<li>Data-directed programming handles generic operations by dealing explicitly with operation-and-type tables.</li>
<li>In our example, each operation took care of its own dispatching.</li>
<li>An alternative approach is to dispatch on the operator name within the data object itself.</li>
<li>Rather than applying a generic operation to a data object on which it dispatches to the appropriate procedure, we apply the data object to a message.</li>
<li>This is called message-passing style, and we can accomplish it in Scheme using closures.</li>
<li>Message passing can be a powerful tool for structuring simulation programs.</li>
</ul>
<h2 id="systems-with-generic-operations">Systems with Generic Operations</h2>
<ul>
<li>The key idea in the <a href="#data-directed-programming-and-additivity">previous section</a>: link specific data operations to multiple representations using generic procedures.</li>
<li>We can extend this further to create operations that are generic over different kinds of arguments, not just different representations of the same kind of data.</li>
<li>We have seen several different arithmetic packages – primitive numbers, rational numbers, intervals, and complex numbers.</li>
<li>We will use data-directed techniques to write procedures that work on all of these data structures.</li>
<li>This will require many abstraction barriers.</li>
<li>The result will be additive (modular) – easy to add new types.</li>
</ul>
<h3 id="generic-arithmetic-operations">Generic Arithmetic Operations</h3>
<ul>
<li>We want <code>add</code> to work for primitive numbers, rational numbers, and complex numbers.</li>
<li>We will attach a type tag to each kind of number.</li>
<li>Just as we did in our first data-directed example, we will install a “package” for each kind of data.</li>
<li>For complex numbers we have two levels of tagging: a <code>'complex</code> tag on top of the <code>'rectangular</code> or <code>'polar</code> tag.</li>
<li>The tags get stripped off as the data is passed down through packages to the appropriate specific procedure.</li>
</ul>
<h3 id="combining-data-of-different-types">Combining Data of Different Types</h3>
<ul>
<li>In our unified arithmetic system, we ignored an important issue.</li>
<li>We did not consider the possibility of operations that cross type boundaries, like adding a Scheme number to a rational.</li>
<li>One solution would be to design a procedure for each possible combination of types.</li>
<li>This is cumbersome, and it violates modularity.</li>
</ul>
<h4 id="coercion">Coercion</h4>
<ul>
<li>Often the different data types are not completely independent.</li>
<li>For example, any real number can be expressed as a complex number with an imaginary part of zero (but not vice versa).</li>
<li>We can make all operations work on combinations of Scheme numbers and complex numbers by promoting, or coercing, the former to the latter type and then using the complex number procedure.</li>
<li>Here is a typical coercion procedure:</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(scheme-number-&gt;complex n)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  (make-complex-from-real-imag (contents n) <span class="dv">0</span>))</span></code></pre></div>
<ul>
<li>In addition to the generic procedure table, we would need a special coercion table.</li>
<li>We can modify <code>apply-generic</code> to try coercion if there is no specific procedure available for the given types.</li>
<li>The big advantage of coercion is that, although we may need to write many coercion procedures, we only need to write specific operation procedures once per type.</li>
<li>It gets more complicated: what if both types can be converted to a third type? What if A can be converted to B and then from B to C? We have a graph of relations among the types.</li>
</ul>
<h4 id="hierarchies-of-types">Hierarchies of types</h4>
<ul>
<li>Integers are a subtype of rationals, which are a subtype of real numbers, and so on for complex numbers.</li>
<li>We have supertypes going in the opposite order.</li>
<li>A simple hierarchy where each type has at most one supertype and most one subtype is called a tower.</li>
<li>Coercion then simply becomes a matter of raising the argument whose type is lower in the tower to the level of the other type.</li>
<li>We can write fewer procedures by allowing types to <em>inherit</em> the operations on supertypes.</li>
<li>In some cases we can also lower a value down the type tower.</li>
</ul>
<h4 id="inadequacies-of-hierarchies">Inadequacies of hierarchies</h4>
<ul>
<li>In general, a type may have more than one subtype (not a tower).</li>
<li>Having multiple super types is tricky, since the type can be raised via multiple paths to search for a procedure.</li>
<li>Large numbers of interrelated types conflicts with modularity.</li>
</ul>
<h3 id="example-symbolic-algebra">Example: Symbolic Algebra</h3>
<ul>
<li>The manipulation of symbolic algebraic expressions is hard.</li>
<li>We can view them as hierarchical structures – a tree of operators applied to operands.</li>
<li>A complete system would be exceedingly complex.</li>
<li>We will just look at the arithmetic of polynomials.</li>
</ul>
<h4 id="arithmetic-on-polynomials">Arithmetic on polynomials</h4>
<ul>
<li>A polynomial is relative to certain variables, the <em>indeterminates</em>.</li>
<li>We will only consider univariate polynomials.</li>
<li>The polynomial is a sum of terms, each being a coefficient, a power of the indeterminate, or a product of the two.</li>
<li>A coefficient is an algebraic expression that is not dependent upon the indeterminate of the polynomial.</li>
<li>Our polynomials will be syntactic forms, not representations of mathematical functions.</li>
<li>This means that replacing each <span class="math inline">x</span> with <span class="math inline">y</span> creates a different polynomial, although they could represent the same function.</li>
<li>We will only do addition and multiplication.</li>
<li>Both operands must have the same indeterminate.</li>
<li>The <em>poly</em> data structure consists of a variable (the indeterminate) and a list of terms.</li>
<li>Our system works with polynomials with polynomial coefficients “for free” because of data-directed recursion – because we are using generic procedures.</li>
</ul>
<h4 id="representing-term-lists">Representing term lists</h4>
<ul>
<li>Our procedures <code>add-terms</code> and <code>mul-terms</code> always access term lists sequentially from highest to lowest order.</li>
<li>So, we need some kind of ordered list representation.</li>
<li>We can choose between <em>dense</em> and <em>sparse</em> representations.</li>
<li>Dense term lists, where most coefficients are nonzero, are best represented by simple lists.</li>
<li>Sparse term lists, where there are many zeros, are better represented by some kind of associative list or map.</li>
</ul>
<h4 id="hierarchies-of-types-in-symbolic-algebra">Hierarchies of types in symbolic algebra</h4>
<ul>
<li>Our polynomial system used complex objects that had objects of many different parts as types.</li>
<li>It was recursive data abstraction because the terms of the polynomial could themselves be polynomials.</li>
<li>The data types in polynomial algebra cannot be arranged in a tower.</li>
<li>Controlling coercion is a hard problem in these systems.</li>
</ul>
<h4 id="extended-exercise-rational-functions">Extended exercise: Rational functions</h4>
<ul>
<li>Rational functions are “fractions” with polynomial numerators and denominators.</li>
<li>We can use our old rational package, but we need to change a few things (like using generic <code>add</code>, <code>mul</code>, etc.).</li>
<li>We can reduce rational functions as long as we can compute the GCD of two polynomials (which in turn uses the remainder operation on two polynomials).</li>
<li>Problem: we end up with a GCD polynomial that has fractional coefficients. Solution: multiply the first argument by an <em>integerizing factor</em>.</li>
<li>We can use our GCD procedure to reduce rational functions to lowest terms:
<ol type="1">
<li>Compute the integerized GCD of the numerator and denominator.</li>
<li>Multiply the numerator and denominator by an integerizing factor: the leading coefficient of the GCD raised to the power <span class="math inline">1 + O_1 − O_2</span>, where <span class="math inline">O_2</span> is the order of the GCD and <span class="math inline">O_1</span> is the maximum of order of the numerator and the order of the denominator.</li>
<li>Divide the new numerator and new denominator by the GCD.</li>
<li>Divide both by the GCD of all their coefficients.</li>
</ol></li>
<li>This GCD algorithm, or something like it, is at the heart of every system that does operations on rational functions.</li>
<li>This one is very slow. Probabilistic algorithms are faster.</li>
</ul>
<h1 id="chapter-3-modularity-objects-and-state">Chapter 3: Modularity, Objects, and State</h1>
<ul>
<li>Primitive procedures and primitive data combine to construct compound entities; abstraction controls complexity.</li>
<li>But these tools are not sufficient for designing programs.</li>
<li>We also need organizational principles to guide the overall design of the program.</li>
<li>We need to structure large systems to make them <em>modular</em>.</li>
<li>A modular program can be divided into coherent parts that can be separately developed and maintained.</li>
<li>One designed strategy is to base the structure of the program on the structure of physical systems being modelled.</li>
<li>Done properly, this allows us to add new objects or new actions easily and locally, without changing the whole strategy.</li>
<li>Program organization depends on the system to be modelled.</li>
<li>Two “world views”: concentrate on <em>objects</em>, or on <em>streams</em>.</li>
<li>Objects: Must allow change but preserve identity. Abandon the substation model for the environment model. Grapple with time in the computational model.</li>
<li>Streams: Decouple simulated time in the model from the order of events that take place in the computer. Delayed evaluation.</li>
</ul>
<h2 id="assignment-and-local-state">Assignment and Local State</h2>
<ul>
<li>The world is populated by independent objects possessing changing state.</li>
<li>An object “has state”: its behaviour is influenced by history.</li>
<li>A bank account is an example of a stateful object.</li>
<li>An object’s state can be characterized by <em>state variables</em>.</li>
<li>We need an <em>assignment operator</em> to change the value associated with a name representing a local variable of an object.</li>
</ul>
<h3 id="local-state-variables">Local State Variables</h3>
<ul>
<li>Let’s model the situation of withdrawing from a bank account.</li>
<li>The <code>withdraw</code> procedure should accept an amount of money as an argument and return the balance after the withdrawal.</li>
<li>If you try to withdraw too much, it should return the string “Insufficient funds”.</li>
<li>Suppose we begin with $100:</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>(withdraw <span class="dv">25</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dv">75</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>(withdraw <span class="dv">25</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="dv">50</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>(withdraw <span class="dv">60</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Insufficient funds&quot;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>(withdraw <span class="dv">15</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="dv">35</span></span></code></pre></div>
<ul>
<li>Evaluating the same combination twice, <code>(withdraw 25)</code>, returned different values.</li>
<li>We have lost referential transparency. This is a new kind of behaviour of a procedure. Until now, the returned value depended only on the arguments, like a mathematical function.</li>
<li>To implement <code>withdraw</code>, we define a variable called <code>balance</code>:</li>
</ul>
<div class="sourceCode" id="cb25"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> balance </span><span class="dv">100</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(withdraw amount)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">&gt;=</span> balance amount)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">begin</span> (<span class="kw">set!</span> balance (<span class="op">-</span> balance amount))</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>             balance)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Insufficient funds&quot;</span>))</span></code></pre></div>
<ul>
<li>This uses the <code>set!</code> special form, whose syntax is <code>(set! &lt;name&gt; &lt;new-value&gt;)</code>.</li>
<li>Procedures names that end with a bang change the values of variables or of data structures.</li>
<li>The expression <code>(begin &lt;exp1&gt; &lt;exp2&gt; ... &lt;expk&gt;)</code> evaluates all the expressions in sequence and returns the value of the last.</li>
<li>We made <code>balance</code> a global variable. It is much better to have it <em>encapsulated</em> within <code>withdraw</code>, like so:</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> withdraw</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((balance <span class="dv">100</span>))</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (amount)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">if</span> (<span class="op">&gt;=</span> balance amount)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">begin</span> (<span class="kw">set!</span> balance (<span class="op">-</span> balance amount))</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>                 balance)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;Insufficient funds&quot;</span>))))</span></code></pre></div>
<ul>
<li>Unfortunately, the substitution model of evaluation is no longer adequate once we have assignment in our procedures.</li>
<li>For now, we technically have no way to understand how these procedures work. We will develop a new model soon.</li>
<li>The following procedure creates “withdraw processors”:</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-withdraw balance)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (amount)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="op">&gt;=</span> balance amount)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">begin</span> (<span class="kw">set!</span> balance (<span class="op">-</span> balance amount))</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>               balance)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Insufficient funds&quot;</span>)))</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> W1 </span>(make-withdraw <span class="dv">100</span>))</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> W2 </span>(make-withdraw <span class="dv">100</span>))</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>(W1 <span class="dv">50</span>)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="dv">50</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>(W2 <span class="dv">70</span>)</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="dv">30</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>(W2 <span class="dv">40</span>)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Insufficient funds&quot;</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>(W1 <span class="dv">40</span>)</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span></code></pre></div>
<ul>
<li>Here, <code>W1</code> and <code>W2</code> are complement independent objects, each with its own local state variable.</li>
<li>We can create a “bank-account object” that responds to multiple messages, all operating on the same local state:</li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-account balance)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> </span>(withdraw amount)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="op">&gt;=</span> balance amount)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">begin</span> (<span class="kw">set!</span> balance (<span class="op">-</span> balance amount))</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>               balance)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Insufficient funds&quot;</span>))</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> </span>(deposit amount)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set!</span> balance (<span class="op">+</span> balance amount))</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    balance)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> </span>(dispatch m)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">cond</span> ((<span class="kw">eq?</span> m &#39;withdraw) withdraw)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>          ((<span class="kw">eq?</span> m &#39;deposit) deposit)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">else</span> (<span class="kw">error</span> <span class="st">&quot;Unknown request: MAKE-ACCOUNT&quot;</span> m))))</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  dispatch)</span></code></pre></div>
<h3 id="the-benefits-of-introducing-assignment">The Benefits of Introducing Assignment</h3>
<ul>
<li>Introducing assignment “leads us into a thicket of difficult conceptual issues” (305).</li>
<li>Even so, it gives us a powerful technique for maintaining modular design.</li>
<li>Consider the procedure <code>rand</code>. We want it to return an integer chosen at random each time we evaluate <code>(rand)</code>.</li>
<li>Suppose we have the procedure <code>rand-update</code> that takes one argument.
<ul>
<li>We first call it with an initial value <span class="math inline">x_1</span>, and it returns an integer <span class="math inline">x_2</span>.</li>
<li>We call it with <span class="math inline">x_2</span>, and it gives us <span class="math inline">x_3</span>, and so on.</li>
<li>The sequence of values <span class="math inline">x_1, x_2, \dots, x_n</span> will have the desired statistical properties (random uniform distribution).</li>
<li>This is a <em>pseudorandom</em> sequence, since each number is a function of the previous one.</li>
</ul></li>
<li>We could implement <code>rand</code> like this:</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> rand</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((x random-init))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> ()</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">set!</span> x (rand-update x))</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>      x)))</span></code></pre></div>
<blockquote>
<p>The Monte Carlo method consists of choosing sample experiments at random from a large set and then making deductions on the basis of the probabilities estimated from tabulating the results of those experiments. (306–307)</p>
</blockquote>
<ul>
<li>We can use the Monte Carlo method to approximate <span class="math inline">π</span>, knowing that the probability that two randomly chosen integers have 1 as their GCD is <span class="math inline">6/π^2</span>.</li>
<li>If we had to use <code>rand-update</code> directly, our Monte Carlo program would “betray some painful breaches of modularity” (308).</li>
</ul>
<blockquote>
<p>The general phenomenon illustrated by the Monte Carlo example is this: From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write computer programs whose structure reflects this decomposition, we make computational objects (such as bank accounts and random-number generators) whose behaviour changes with time. We model state with local state variables, and we model the changes of state with assignments to those variables. (309)</p>
</blockquote>
<h3 id="the-costs-of-introducing-assignment">The Costs of Introducing Assignment</h3>
<ul>
<li>The advantages of local state and assignment come at a price.</li>
<li>The substitution model of procedure application is no longer sufficient to properly interpret out programs.</li>
<li>Programming without the use of assignment, as we have done in the first two chapters, is called <em>functional programming</em>.</li>
<li>Observe what happens when we try using the substation model:</li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-simplified-withdraw balance)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (amount)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set!</span> balance (<span class="op">-</span> balance amount))</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    balance))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>((make-simplified-withdraw <span class="dv">25</span>) <span class="dv">20</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>((<span class="kw">lambda</span> (amount) (<span class="kw">set!</span> balance (<span class="op">-</span> <span class="dv">25</span> amount)) <span class="dv">25</span>) <span class="dv">20</span>)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">set!</span> balance (<span class="op">-</span> <span class="dv">25</span> <span class="dv">20</span>)) <span class="dv">25</span></span></code></pre></div>
<ul>
<li>Adhering to the substation model, we set <code>balance</code> to 5 and then return 25 as the value of the expression.</li>
<li>This is wrong. We shouldn’t have substituted 25 for <code>balance</code> everywhere, because the assignment changed it.</li>
<li>Before, a variable was simply a name for a value.</li>
<li>Now, since a variable can change, it somehow refers to a place where a value can be stored, and this value can be changed.</li>
</ul>
<h4 id="sameness-and-change">Sameness and change</h4>
<ul>
<li>By introducing change into our computational models, many previously straightforward notions become problematic.</li>
<li>Consider the concept of two things being “the same.”</li>
<li>If we have <code>(make-withdraw 25)</code> and <code>(make-withdraw 25)</code>, are they the same? No, because they can have different local state.</li>
<li>A language that supports “equals can be substituted for equals” is <em>referentially transparent</em>. <code>set!</code> violates this.</li>
<li>Reasoning about programs that use assignment is much more difficult for this reason.</li>
<li>The concepts of “sameness” and “change” chase each other around in circles; it is hard to formally define them.</li>
<li>If we have <code>(define peter-acc (make-account 100))</code>, there is a big difference between defining <code>paul-acc</code> in the same way and defining it with <code>(define paul-acc peter-acc)</code>.</li>
<li>In the first case, they have distinct accounts. In the second, both refer to the same account – this is called <em>aliasing</em>.</li>
<li>As long as we never modify objects, we can regard them to be precisely the totality of their pieces.</li>
<li>This is no longer valid in the presence of change, because “identity” is something different from the pieces.</li>
<li>A bank account is still “the same” account after a withdrawal. Conversely, two distinct accounts with the same balance are “different.”</li>
<li>The name is attached to an identity rather than the data itself.</li>
</ul>
<h4 id="pitfalls-of-imperative-programming">Pitfalls of imperative programming</h4>
<ul>
<li>Programming that makes extensive use of assignment is called <em>imperative programming</em>.</li>
<li>Imperative programs are susceptible to bugs that cannot occur in functional programs.</li>
<li>Things get even worse when we throw concurrency into the mix.</li>
</ul>
<blockquote>
<p>In general, programming with assignment forces us to carefully consider the relative orders of the assignments to make sure that each statement is using the correct version of the variables that have been changed. This issue simply does not arise in functional programs. (318–319)</p>
</blockquote>
<h2 id="the-environment-model-of-evaluation">The Environment Model of Evaluation</h2>
<ul>
<li>Recall the substitution model:</li>
</ul>
<blockquote>
<p>To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.</p>
</blockquote>
<ul>
<li>This is no longer adequate once we allow assignment.</li>
<li>Variables are no longer merely names for values; rather, a variable designates a “place” in which values can be stored.</li>
<li>These places will be maintained in structures called <em>environments</em>.</li>
<li>An environment is a sequence of <em>frames</em>. A frame is a table of <em>bindings</em>. A binding associates a variable name with one value.</li>
<li>Each frame also has a pointer to its enclosing environment, unless it is considered to be global.</li>
<li>The value of a variable with respect to an environment is the value given by the binding in the first frame of the environment that contains a binding for that variable.</li>
<li>If no frame in the sequence specifies a binding for the variable, then the variable is <em>unbound</em> in the environment.</li>
<li>A binding <em>shadows</em> another (of the same variable) if the other is in a frame that is further in the sequence.</li>
<li>The environment determines the context in which an expression should be evaluated. An expression has no meaning otherwise.</li>
<li>The global environment consists of a single frame, and it is implicitly used in interactions with the interpreter.</li>
</ul>
<h3 id="the-rules-for-evaluation">The Rules for Evaluation</h3>
<ul>
<li>To evaluate a combination:
<ol type="1">
<li>Evaluate the subexpressions of the combination.</li>
<li>Apply the value of the operator subexpression to the values of the operand subexpressions.</li>
</ol></li>
<li>The environment model redefines the meaning of “apply.”</li>
<li>A procedure is created by evaluating a λ-expression relative to a given environment.</li>
<li>The resulting procedure object is a pair consisting of the text of the λ-expression and a pointer to the environment in which the procedure was created.</li>
<li>To apply a procedure to arguments, create a new environment whose frame binds the parameters to the values of the arguments and whose enclosing environment is specified by the procedure.</li>
<li>Then, within the new environment, evaluate the procedure body.</li>
<li><code>(lambda (x) (* x x))</code> evaluates a to pair: the parameters and the procedure body as one item, and a pointer to the global environment as the other.</li>
<li><code>(define square (lambda (x) (* x x)))</code> associates the symbol <code>square</code> with that procedure object in the global frame.</li>
<li>Evaluating <code>(define &lt;var&gt; &lt;val&gt;)</code> creates a binding in the current environment frame to associate <code>&lt;var&gt;</code> with <code>&lt;val&gt;</code>.</li>
<li>Evaluating <code>(set! &lt;var&gt; &lt;val&gt;)</code> locates the binding of <code>&lt;var&gt;</code> in the current environment (the first frame that has a binding for it) and changes the bound value to <code>&lt;val&gt;</code>.</li>
<li>We use <code>define</code> for variables that are currently unbound, and <code>set!</code> for variables that are already bound.</li>
</ul>
<h3 id="applying-simple-procedures">Applying Simple Procedures</h3>
<ul>
<li>Let’s evaluate <code>(f 5)</code>, given the following procedures:</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(square x) (<span class="op">*</span> x x))</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(sum-of-squares x y) (<span class="op">+</span> (square x) (square y)))</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(f a) (sum-of-squares (<span class="op">+</span> a <span class="dv">1</span>) (<span class="op">*</span> a <span class="dv">2</span>)))</span></code></pre></div>
<ul>
<li>These definitions create bindings for <code>square</code>, <code>sum-of-squares</code>, and <code>f</code> in the global frame.</li>
<li>To evaluate <code>(f 5)</code>, we create an environment <span class="math inline">E_1</span> with a frame containing a single binding, associating <code>a</code> with <code>5</code>.</li>
<li>In <span class="math inline">E_1</span>, we evaluate <code>(sum-of-squares (+ a 1) (* a 2))</code>.</li>
<li>We must evaluate the subexpressions of this combination.</li>
<li>We find the value associated with <code>sum-of-squares</code> not in <span class="math inline">E_1</span> but in the global environment.</li>
<li>Evaluating the operand subexpressions yields <code>6</code> and <code>10</code>.</li>
<li>Now we create <span class="math inline">E_2</span> with a frame containing two bindings: <code>x</code> is bound to <code>6</code>, and <code>y</code> is bound to <code>10</code>.</li>
<li>In <span class="math inline">E_2</span>, we evaluate <code>(+ (square x) (square y))</code>.</li>
<li>The process continues recursively. We end up with <code>(+ 36 100)</code>, which evaluates to <code>136</code>.</li>
</ul>
<h3 id="frames-as-the-repository-of-local-state">Frames as the Repository of Local State</h3>
<ul>
<li>Now we can see how the environment model makes sense of assignment and local state.</li>
<li>Consider the “withdrawal processor”:</li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-withdraw balance)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (amount)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="op">&gt;=</span> balance amount)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">begin</span> (<span class="kw">set!</span> balance (<span class="op">-</span> balance amount))</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>               balance)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Insufficient funds&quot;</span>)))</span></code></pre></div>
<ul>
<li>This places a single binding in the global environment frame.</li>
<li>Consider now <code>(define W1 (make-withdraw 100))</code>.
<ul>
<li>We set up <span class="math inline">E_1</span> where <code>100</code> is bound to the formal parameter <code>balance</code>, and then we evaluate the body of <code>make-withdraw</code>.</li>
<li>This returns a lambda procedure who environment is <span class="math inline">E_1</span>, and this is then bound to <code>W1</code> in the global frame.</li>
</ul></li>
<li>Now, we apply this procedure: <code>(W1 50)</code>.
<ul>
<li>We construct a frame in <span class="math inline">E_2</span> that binds <code>amount</code> to <code>50</code>, and then we evaluate the body of <code>W1</code>.</li>
<li>The enclosing environment of <span class="math inline">E_2</span> is <span class="math inline">E_1</span>, <em>not</em> the global environment.</li>
<li>Evaluating the body results in the <code>set!</code> rebinding <code>balance</code> in <span class="math inline">E_`</span> to the value <code>(- 100 50)</code>, which is <code>50</code>.</li>
<li>After calling <code>W1</code>, the environment <span class="math inline">E_2</span> is irrelevant because nothing points to it.</li>
<li>Each call to <code>W1</code> creates a new environment to hold <code>amount</code>, but uses the same <span class="math inline">E_1</span> (which holds <code>balance</code>).</li>
</ul></li>
<li><code>(define W2 (make-withdraw 100))</code> creates another environment with a <code>balance</code> binding.
<ul>
<li>This is independent from <span class="math inline">E_1</span>, which is why the <code>W2</code> object and its local state is independent from <code>W1</code>.</li>
<li>On the other hand, <code>W1</code> and <code>W2</code> share the same code.</li>
</ul></li>
</ul>
<h3 id="internal-definitions">Internal Definitions</h3>
<ul>
<li>With block structure, we nested definitions using <code>define</code> to avoid exposing helper procedures.</li>
<li>Internal definitions work according to the environmental model.</li>
<li>When we apply a procedure that has internal definitions, there are <code>define</code> forms at the beginning of the body.</li>
<li>We are in <span class="math inline">E_1</span>, so evaluating these adds bindings to the first frame of <span class="math inline">E_1</span>, right after the arguments.</li>
<li>When we apply the internal procedures, the formal parameter environment <span class="math inline">E_n</span> is created, and its enclosing environment is <span class="math inline">E_1</span> because that was where the procedure was defined.</li>
<li>This means each internal procedure has access to the arguments of the procedure they are defined within.</li>
<li>The names of local procedures don’t interfere with names external to the enclosing procedure, due to <span class="math inline">E_1</span>.</li>
</ul>
<h2 id="modeling-with-mutable-data">Modeling with Mutable Data</h2>
<ul>
<li>We previously looked at compound data and data abstraction.</li>
<li>To model stateful objects, we need <em>mutators</em> in addition to constructors and selectors.</li>
<li>A mutator is a procedure that modifies the data object.</li>
</ul>
<h3 id="mutable-list-structure">Mutable List Structure</h3>
<ul>
<li>The primitive mutators for pairs are <code>set-car!</code> and <code>set-cdr!</code>.</li>
<li><code>(set-car p x)</code> changes the <code>car</code> of the pair <code>p</code>, making it point to <code>x</code> instead.</li>
<li>The old <code>car</code> is unreachable garbage. We will see later how Lisp recycles this memory.</li>
<li>We could implement <code>cons</code> in terms of these two procedures in addition to a <code>get-new-part</code> procedure.</li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cons</span> x y)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((new (get-new-pair)))</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set-car!</span> new x)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set-cdr!</span> new y)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    new))</span></code></pre></div>
<h4 id="sharing-and-identity">Sharing and identity</h4>
<ul>
<li>Consider <code>(define x (list 'a 'b))</code> and <code>(define z1 (cons x x))</code>.</li>
<li><code>z1</code> is a pair whose <code>car</code> and <code>cdr</code> both point to the same <code>x</code>.</li>
<li>In contrast: <code>(define z2 (cons (list 'a 'b)) (list 'a 'b))</code>.</li>
<li>In <code>z2</code>, the two <code>(a b)</code> lists are distinct, although the actual symbols are shared.</li>
<li>Before assignment, we would think <code>z1</code> and <code>z2</code> were “the same.”</li>
<li>The sharing is undetectable without mutators on list structure.</li>
<li>It <em>is</em> detectable in our environmental model.</li>
<li>If we <code>set-car!</code> on the <code>car</code>, this will change both <code>a</code> symbols in <code>z1</code> but only the first in <code>z2</code>.</li>
<li>We can use the predicate <code>eq?</code> to test for sameness in the sense of identity.</li>
<li><code>(eq? x y)</code> tests whether <code>x</code> and <code>y</code> point to the same object.</li>
<li>We can exploit sharing for good, but it can be dangerous.</li>
</ul>
<h4 id="mutation-is-just-assignment">Mutation is just assignment</h4>
<ul>
<li>Earlier we said we can represent pairs purely in terms of procedures:</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cons</span> x y)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (sel)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    (sel x y)))</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">car</span> p)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  (p (<span class="kw">lambda</span> (x y) x)))</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cdr</span> p)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  (p (<span class="kw">lambda</span> (x y) y)))</span></code></pre></div>
<ul>
<li>The same is true of mutable data. We can implement mutators with procedures and assignment alone:</li>
</ul>
<div class="sourceCode" id="cb35"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cons</span> x y)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> </span>(set-x! v) (<span class="kw">set!</span> x v))</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> </span>(set-y! v) (<span class="kw">set!</span> y v))</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> </span>(dispatch m)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">cond</span> ((<span class="kw">eq?</span> m &#39;car) x)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>          ((<span class="kw">eq?</span> m &#39;cdr) y)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>          ((<span class="kw">eq?</span> m &#39;set-car!) set-x!)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>          ((<span class="kw">eq?</span> m &#39;set-cdr!) set-y!)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">else</span> (<span class="kw">error</span> <span class="st">&quot;Undefined operation: CONS&quot;</span> m))))</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  dispatch)</span></code></pre></div>
<ul>
<li>Assignment and mutation are equipotent: each can be implemented in terms of the other.</li>
</ul>
<h3 id="representing-queues">Representing Queues</h3>
<ul>
<li>The mutators allow us to construct new data structures.</li>
<li>A <em>queue</em> is a sequence in which items are inserted at one end (the rear) and deleted from the other end (the front).</li>
<li>It is also called a FIFO buffer (first in, first out).</li>
<li>We define the following operations for data abstraction:
<ul>
<li>a constructor <code>(make-queue)</code>,</li>
<li>a predicate <code>(empty-queue? q)</code>,</li>
<li>a selector <code>(front-queue q)</code>,</li>
<li>two mutators: <code>(insert-queue! q x)</code> and <code>(delete-queue! q)</code>.</li>
</ul></li>
<li>A simple list representation is inefficient because we have to scan to get to one end.</li>
<li>Scanning a list takes <span class="math inline">Θ(n)</span> operations.</li>
<li>A simply modification lets us implement all the operations with <span class="math inline">Θ(1)</span> time complexity: keep a pointer to the end as well.</li>
<li>A queue is a pair formed by consing the front-pointer and the rear-pointer of a normal list.</li>
</ul>
<h3 id="representing-tables">Representing Tables</h3>
<ul>
<li>In a one-dimensional table, each value is indexed by one key.</li>
<li>We can implement it as a simple list of <em>records</em>.</li>
<li>A record is a pair consisting of a key and an associated value.</li>
<li>The first record in the table is a dummy, and it hold the arbitrarily chosen symbol <code>*table*</code>.
<ul>
<li>If a table was just a pointer to the first actual record, then when we wouldn’t be able to write a mutator to add a record to the front.</li>
<li>We would need to change the table to point to the new front, but <code>set!</code> on a formal parameter doesn’t work as desired.</li>
<li>It would only change the parameter in <span class="math inline">E_1</span>, not the value in the calling environment.</li>
<li>We didn’t need to worry about this with sets because a set was a cons of two pointers a therefore we could mutate the <code>car</code> and <code>cdr</code> – but we couldn’t change the set <em>itself</em>, since it was effectively a pointer to the pair, <em>copied</em> on application.</li>
<li>We are essentially using a pointer; we are using one cell of the cons pair. Some schemes provide <code>box</code>, <code>unbox</code>, and <code>set-box!</code> for this purpose. In C, these are <code>&amp;x</code>, <code>*x</code>, and <code>*x = ...</code>.</li>
</ul></li>
<li>The <code>lookup</code> procedure returns the value associated with a key in a table, or <code>#f</code> if it cannot be found.</li>
<li>It uses <code>assoc</code>, which returns the whole record rather than just the associated value.</li>
</ul>
<h4 id="two-dimensional-tables">Two-dimensional tables</h4>
<ul>
<li>Two-dimensional tables are indexed by two keys.</li>
<li>In some cases, we could just use a one dimensional table whose keys are pairs of keys.</li>
<li>We can implement a two-dimensional table as a one-dimensional table whose values are themselves one-dimensional tables.</li>
<li>We could just use them like that without any specific procedures. However, insertion with two keys is complex enough to merit a convenient two-dimensional procedure.</li>
<li>We don’t need to box the subtables. They key of the record serves the purpose of <code>'*table*</code>.</li>
</ul>
<h4 id="creating-local-tables">Creating local tables</h4>
<ul>
<li>With our <code>lookup</code> and <code>insert!</code> procedures taking the table as an argument, we can manage multiple tables.</li>
<li>Another approach is to have separate procedures for each table.</li>
<li>We could use the message-passing style with the <code>dispatch</code> procedure that we’ve seen a few times already.</li>
<li>We could also take the λ-calculus approach:</li>
</ul>
<div class="sourceCode" id="cb36"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-table) (<span class="kw">lambda</span> (k) <span class="dv">#f</span>))</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(lookup key table) (table key))</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(insert! key value table)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (k)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="kw">eq?</span> k key)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        value</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>        (table k))))</span></code></pre></div>
<h3 id="a-simulator-for-digital-circuits">A Simulator for Digital Circuits</h3>
<ul>
<li>Digital circuits are made up of simple elements.</li>
<li>Networks of these simple elements can have very complex behaviour.</li>
<li>We will design a system to simulator digital logic. This type of program is called an <em>event-driven simulation</em>.</li>
<li>Our computational model is based on the physical components.
<ul>
<li>A <em>wire</em> carries a <em>digital signal</em>, which is either 0 or 1.</li>
<li>A <em>function box</em> connects to input wires and output wires.</li>
<li>The output signal is delayed by a time that depends on the type of function box.</li>
<li>Our primitive function boxes are the <em>inverter</em>, <em>and-gate</em>, and <em>or-gate</em>. Each has its own delay.</li>
<li>We construct complex functions by connecting primitives.</li>
<li>Multiple outputs are not necessarily generated at the same time.</li>
</ul></li>
<li>We construct wires with <code>(make-wire)</code>.</li>
<li>Evaluating <code>(define a (make-wire))</code> and <code>(define b (make-wire))</code> followed by <code>(inverter a b)</code> connects <code>a</code> and <code>b</code> with an inverter.</li>
<li>The primitive functions are our primitive elements; wiring is the means of combination; specifying wiring patterns as procedures is the means of abstraction.</li>
</ul>
<h4 id="primitive-function-boxes">Primitive function boxes</h4>
<ul>
<li>The primitives boxes implement “forces” by which changes in the signal of one wire influence the signal of another.</li>
<li>We have the following operations on wires:
<ul>
<li><code>(get-signal &lt;wire&gt;)</code> returns the current value of the signal.</li>
<li><code>(set-signal! &lt;wire&gt; &lt;value&gt;)</code> changes the value of the signal.</li>
<li><code>(add-action! &lt;wire&gt; &lt;procedure of no arguments&gt;)</code> asserts that the given procedure should be run whenever the signal on the wire changes value.</li>
</ul></li>
<li>The procedure <code>after-delay</code> executes a procedure after a given time delay.</li>
</ul>
<h4 id="representing-wires">Representing wires</h4>
<ul>
<li>Our wires will be computational objects each having two local state variables: <code>signal-value</code> and <code>action-procedures</code>.</li>
<li>We use the message-passing style as before.</li>
<li>Wires have time-varying signals and can be incrementally attached to devices. They are a good example of when you need to use a mutable object in the computational model.</li>
<li>A wire is shared between the devices connected to it. If one changes it, the rest see the change.</li>
<li>This would be impossible if you didn’t model the wire as an identity, separate from its signal value.</li>
</ul>
<h4 id="the-agenda">The agenda</h4>
<ul>
<li>The only thing left is <code>after-delay</code>.</li>
<li>An <em>agenda</em> is a data structure that schedules things to do.</li>
<li>For an agenda <code>(define a (make-agenda))</code>, the operations <code>(empty-agenda? a)</code>, <code>(first-agenda-item a)</code>, <code>(remove-first-agenda-item! a)</code>, and <code>(current-time a)</code> are self-explanatory.</li>
<li>We schedule new items with <code>(add-to-agenda &lt;time&gt; &lt;action&gt; a)</code>.</li>
<li>We call the global agenda <code>the-agenda</code>.</li>
<li>The simulation is driven by <code>propagate</code>, which executes each item on the agenda in sequence.</li>
</ul>
<h4 id="implementing-the-agenda">Implementing the agenda</h4>
<ul>
<li>The agenda is a pair: the current time, and a list of <em>time segments</em> sorted in increasing order of time.</li>
<li>A time segment is a pair: a number (the time) and a queue of procedures that are scheduled to run during that time segment.</li>
<li>To add an action to the agenda, we scan its segments, examining their times. If we find the right time, we add the action to that segment’s queue. Otherwise, we create a new segment.</li>
<li>To remove the first agenda item, we delete the first item in the first queue, and if this makes the queue empty, we delete the first time segment as well.</li>
<li>Whenever we extract the first item with <code>first-agenda-item</code>, we also update the current time.</li>
</ul>
<h3 id="propagation-of-constraints">Propagation of Constraints</h3>
<ul>
<li>We often organize computer programs in one direction: from input to output.</li>
<li>On the other hand, we often model systems in terms of relations among quantities.</li>
<li>The equation <span class="math inline">dAE = FL</span> is not one-directional.</li>
<li>We will create a language to work in terms of the relations themselves, so that we don’t have to write five procedures.</li>
<li>The primitive elements are <em>primitive constraints</em>.
<ul>
<li><code>(adder a b c)</code> specifies <span class="math inline">a + b = c</span>.</li>
<li><code>(multiplier x y z)</code> specifies <span class="math inline">xy = z</span>.</li>
<li><code>(constant 3.14 x)</code> says that the value of <code>x</code> must be 3.14.</li>
</ul></li>
<li>The means of combination are constructing <em>constraint networks</em> in which constraints are joined by <em>connectors</em>.</li>
<li>The means of abstraction are procedures.</li>
</ul>
<h4 id="using-the-constraint-system">Using the constraint system</h4>
<ul>
<li>We create connectors with <code>(make-connector)</code>, just like wires.</li>
<li>We use <code>(probe "name" &lt;connector&gt;)</code>, again just like wires.</li>
<li>`(set-value! <connector> <value> ’user) assigns a value to the connector, and this information propagates through the network.</li>
<li>This will give an error if the new value causes a contradiction.</li>
<li><code>(forget-value! &lt;connector&gt; 'user)</code> undoes the assignment.</li>
</ul>
<h4 id="implementing-the-constraint-system">Implementing the constraint system</h4>
<ul>
<li>The overall system is simpler than the digital circuit system because there are no propagation delays.</li>
<li>There are five basic operations on a connector <code>c</code>: <code>(has-value? c)</code>, <code>(get-value c)</code>, <code>(set-value! c &lt;value&gt; &lt;informant&gt;)</code>, <code>(forget-value! c &lt;retractor&gt;)</code>, and <code>(connect c &lt;constraint&gt;)</code>.</li>
<li>The procedures <code>inform-about-value</code> and <code>inform-about-no-value</code> tells the constraint that a connector has (lost) a value.</li>
<li>Whenever an adder gets a new value, it checks if it has two and can calculate the third.</li>
</ul>
<h4 id="representing-connectors">Representing connectors</h4>
<ul>
<li>A connector is a procedural object with local state variables – again, just like a wire.</li>
<li>Each time the connector’s value is set, it remembers the informant. This could be a constraint, or a symbol like <code>'user</code>.</li>
<li><code>for-each-except</code> is used to notify all <em>other</em> constraints.</li>
</ul>
<h2 id="concurrency-time-is-of-the-essence">Concurrency: Time Is of the Essence</h2>
<ul>
<li>The power of stateful computational objects comes at a price: the loss of referential transparency.</li>
<li>This gives rise to a thicket of questions about sameness and change, and we had to create a more intricate evaluation model.</li>
<li>The central issue is that by introducing assignment we are forced to admit <em>time</em> in the computational model.</li>
<li>We can go further in structuring the model to match the world: in the physical world, we perceive simultaneous changes.</li>
<li>We want computational processes executing <em>concurrently</em>.</li>
<li>Writing programs this way forces us to avoid inessential timing constraints, making the program more modular.</li>
<li>It can also provide a speed advantage on multicore computers.</li>
<li>The complexities introduces by assignment become even more problematic in the presence of concurrency.</li>
</ul>
<h3 id="the-nature-of-time-in-concurrent-systems">The Nature of Time in Concurrent Systems</h3>
<ul>
<li>On the surface, time is straightforward: it is an ordering.</li>
<li>Two events either occur in one order, or the other, or simultaneously.</li>
<li>Consider <code>(set! balance (- balance amount))</code>. There are three steps: accessing the value of <code>balance</code>, computing the new balance, and setting <code>balance</code> to this value.</li>
<li>Two such expressions executed concurrently on the same <code>balance</code> variable could have their three steps interleaved.</li>
<li>The general problem is that, when concurrent processes share a state variable, they may try to change it at the same time.</li>
</ul>
<h4 id="correct-behavior-of-concurrent-programs">Correct behavior of concurrent programs</h4>
<ul>
<li>We already know we have to be careful about order with <code>set!</code>.</li>
<li>With concurrent programs we must be especially careful.</li>
<li>A very stringent restriction to ensure correctness: disallow changing more than one state variable at a time.</li>
<li>A less stringent restriction: to ensure that the system produces the same result as if the processes had run sequentially in some order (we don’t specify a particular order).</li>
<li>Concurrent programs are inherently <em>nondeterministic</em>, because we don’t what order of execution its result is equivalent to, so there is a set of possible values it could take.</li>
</ul>
<h3 id="mechanisms-for-controlling-concurrency">Mechanisms for Controlling Concurrency</h3>
<ul>
<li>If one process has three ordered events <span class="math inline">(a,b,c)</span> and another, running concurrently, has three ordered events <span class="math inline">(x,y,z)</span>, then there are twenty ways of interleaving them.</li>
<li>The programmer would have to consider the results in all twenty cases to be confident in the program.</li>
<li>A better approach is to use mechanisms to constrain interleaving to ensure correct behavior.</li>
</ul>
<h4 id="serializing-access-to-shared-state">Serializing access to shared state</h4>
<ul>
<li>Serialization groups procedures into sets such and prevents multiple procedures in the same set from executing concurrently.</li>
<li>We can use this to control access to shared variables.</li>
<li>Before, assignments based on a state variables current value were problematic. We could solve this with the set {<code>get-value</code>, <code>set-value!</code>, and <code>swap-value!</code>} where the latter is defined like so:</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(swap-value! f)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  (set-value! (f (get-value))))</span></code></pre></div>
<h4 id="serializers-in-scheme">Serializers in Scheme</h4>
<ul>
<li>Suppose we have a procedure <code>parallel-execute</code> that takes a variable number of arguments that are procedures of no arguments, and executes them all concurrently.</li>
<li>We construct <em>serializers</em> with <code>(make-serializer)</code>.</li>
<li>A serializer takes a procedure as its argument and returns a serialized procedure that behaves like the original.</li>
<li>Calls to the same serializer return procedures in the same set.</li>
</ul>
<h4 id="complexity-of-using-multiple-shared-resources">Complexity of using multiple shared resources</h4>
<ul>
<li>Serializers are powerful, and easy to use for one resource.</li>
<li>Things get much more difficult with multiple shared resources.</li>
<li>Suppose we want to swap the balances in two bank accounts:</li>
</ul>
<div class="sourceCode" id="cb38"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(exchange acc1 acc2)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((diff (<span class="op">-</span> (acc1 &#39;balance) (acc2 &#39;balance))))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    ((acc1 &#39;withdraw) diff)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    ((acc2 &#39;deposit) diff)))</span></code></pre></div>
<ul>
<li>Serializing deposits and withdrawals themselves is not enough to ensure correctness.</li>
<li>The exchange comprises four individually serialized steps, and these may interleave with a concurrent process.</li>
<li>One solution is to expose the serializer from <code>make-account</code>, and use that to serialize the entire exchanging procedure.</li>
<li>We would have to manually serialize deposits, but this would give us the flexibility to serialize the exchanging procedure.</li>
</ul>
<h4 id="implementing-serializers">Implementing serializers</h4>
<ul>
<li>Serializers are implemented in terms of the primitive <em>mutex</em>.</li>
<li>A mutex can be <em>acquired</em> and it can be <em>released</em>.</li>
<li>Once acquired, no other acquire operations can proceed until the mutex is released.</li>
<li>Each serializer has an associated mutex.</li>
<li>A serialized procedure (created with <code>(s proc)</code> where <code>s</code> is a serializer) does the following when it is run:
<ul>
<li>acquire the mutex,</li>
<li>run the procedure <code>proc</code>,</li>
<li>release the mutex.</li>
</ul></li>
<li>The mutex is a mutable object, represented by a <em>cell</em> (a one-element list). It holds a boolean value, indicating whether or not it is currently locked.</li>
<li>To acquire the mutex, we test the cell. We wait until it is false, then we set it to true and proceed.</li>
<li>To release the mutex, we set its contents to false.</li>
</ul>
<h4 id="deadlock">Deadlock</h4>
<ul>
<li>Even with a proper implementation of mutexes and seralizers, we still have a problem with the account exchanging procedure.</li>
<li>We serialize the whole procedure with both accounts so that an account may only participate in one exchange at a time.</li>
<li>There are two mutexes, so it is possible for something to happen in between acquiring the first and the second.</li>
<li>If we exchange <code>a1</code> with <code>a2</code> and concurrently do the reverse exchange, it is possible for the first process to lock <code>a1</code> and the second process to lock <code>a2</code>.</li>
<li>Now both need to lock the other, but they can’t. This situation is called <em>deadlock</em>.</li>
<li>In this case, we can fix the problem by locking accounts in a particular order based on a unique identifier.</li>
<li>In some cases, it is not possible to avoid deadlock, and we simply have to “back out” and try again.</li>
</ul>
<h4 id="concurrency-time-and-communication">Concurrency, time, and communication</h4>
<ul>
<li>Concurrency can be tricky because it’s not always clear what is meant by “shared state.”</li>
<li>It also becomes more complicated in large, distributed systems.</li>
<li>The notion of time in concurrency control must be intimately linked to <em>communication</em>.</li>
<li>There are some parallels with the theory of relativity.</li>
</ul>
<h2 id="streams">Streams</h2>
<ul>
<li>We’ve used assignment as a powerful tool and dealt with some of the complex problems it raises.</li>
<li>Now we will consider another approach to modeling state, using data structures called <em>streams</em>.</li>
<li>We want to avoid identifying time in the computer with time in the modeled world.</li>
<li>If <span class="math inline">x</span> is a function of time <span class="math inline">x(t)</span>, we can think of the identity <span class="math inline">x</span> as a history of values (and these don’t change).</li>
<li>With time measured in discrete steps, we can model a time function as a sequence of values.</li>
<li>Stream processing allows us to model state without assignments.</li>
</ul>
<h3 id="streams-are-delayed-lists">Streams Are Delayed Lists</h3>
<ul>
<li>If we represent streams as lists, we get elegance at the price of severe inefficiency (time <em>and</em> space).</li>
<li>Consider adding all the primes in an interval. Using <code>filter</code> and <code>reduce</code>, we waste a lot of space storing lists.</li>
<li>Streams are lazy lists. They are the clever idea of using sequence manipulations without incurring the cost.</li>
<li>We only construct an item of the stream when it is needed.</li>
<li>We have <code>cons-stream</code>, <code>stream-car</code>, <code>stream-cdr</code>, <code>the-empty-stream</code>, and <code>stream-null?</code>.</li>
<li>The <code>cons-stream</code> procedure must not evaluate its second argument until it is accessed by <code>stream-cdr</code>.</li>
<li>To implement streams, we will use <em>promises</em>. <code>(delay &lt;exp&gt;)</code> does not evaluate the argument but returns a promise. <code>(force &lt;promise&gt;)</code> evaluates a promise and returns the value.</li>
<li><code>(cons-stream a b)</code> is a special form equivalent to <code>(cons a (delay b))</code>.</li>
</ul>
<h4 id="the-stream-implementation-in-action">The stream implementation in action</h4>
<blockquote>
<p>In general, we can think of delayed evaluation as “demand-driven” programming, we herby each stage in the stream process is activated only enough to satisfy the next stage. (438)</p>
</blockquote>
<h4 id="implementing-delay-and-force">Implementing <code>delay</code> and <code>force</code></h4>
<ul>
<li>Promises are quite straightforward to implement.</li>
<li><code>(delay &lt;exp&gt;)</code> is syntactic sugar for <code>(lambda () &lt;exp&gt;)</code>.</li>
<li><code>force</code> simply calls the procedure. We can optimize it by saving the result and not calling the procedure a second time.</li>
<li>The promise stored in the <code>cdr</code> of the stream is also known as a <em>thunk</em>.</li>
</ul>
<h3 id="infinite-streams">Infinite Streams</h3>
<ul>
<li>With lazy sequences, we can manipulate infinitely long streams!</li>
<li>We can define Fibonacci sequence explicitly with a generator:</li>
</ul>
<div class="sourceCode" id="cb39"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(fibgen a b) (cons-stream a (fibgen b (<span class="op">+</span> a b))))</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> fibs </span>(fibgen <span class="dv">0</span> <span class="dv">1</span>))</span></code></pre></div>
<ul>
<li>As long as we don’t try to display the whole sequence, we will never get stuck in an infinite loop.</li>
<li>We can also create an infinite stream of primes.</li>
</ul>
<h4 id="defining-streams-implicitly">Defining streams implicitly</h4>
<ul>
<li>Instead of using a generator procedure, we can define infinite streams implicitly, taking advantage of the laziness.</li>
</ul>
<div class="sourceCode" id="cb40"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> fibs</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  (cons-stream</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>   <span class="dv">0</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>   (cons-stream <span class="dv">1</span> (stream-map <span class="op">+</span> fibs (stream-cdr fibs)))))</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> pot</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  (cons-stream <span class="dv">1</span> (stream-map (<span class="kw">lambda</span> (x) (<span class="op">*</span> x <span class="dv">2</span>)) pot)))</span></code></pre></div>
<ul>
<li>This implicit technique is known as <em>corecursion</em>. Recursion works backward towards a base case, but corecursion works from the base and creates more data in terms of itself.</li>
</ul>
<h3 id="exploiting-the-stream-paradigm">Exploiting the Stream Paradigm</h3>
<ul>
<li>Streams can provide many of the benefits of local state and assignment while avoiding some of the theoretical tangles.</li>
<li>Using streams allows us to have different module boundaries.</li>
<li>We can focus on the whole stream/series/signal rather than on individual values.</li>
</ul>
<h4 id="formulating-iterations-as-stream-processes">Formulating iterations as stream processes</h4>
<ul>
<li>Before, we made iterative processes by updating state variables in recursive calls.</li>
<li>To compute the square root, we improved a guess until the values didn’t change very much.</li>
<li>We can make a stream that converges on the square root of <code>x</code>, and a stream to approximate π.</li>
<li>One neat thing we can do with these streams is use sequence accelerators, such as Euler’s transform.</li>
</ul>
<h4 id="infinite-streams-of-pairs">Infinite streams of pairs</h4>
<ul>
<li>Previously, we handled traditional nested loops as processes defined on sequences of pairs.</li>
<li>We can find all pairs <span class="math inline">(i,j)</span> with <span class="math inline">i ≤ j</span> such that <span class="math inline">i + j</span> is prime like this:</li>
</ul>
<div class="sourceCode" id="cb41"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>(stream-filter</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a> (<span class="kw">lambda</span> (pair) (prime? (<span class="op">+</span> (<span class="kw">car</span> pair) (<span class="kw">cadr</span> pair))))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a> int-pairs)</span></code></pre></div>
<ul>
<li>We need some way of producing a stream of all integer pairs.</li>
<li>More generally, we can combined two streams to get a two-dimensional grid of pairs, and we want to reduce this to a one-dimensional stream.</li>
<li>One way to do this is to use <code>interleave</code> in the recursive definition, in order to handle infinite streams.</li>
</ul>
<h4 id="streams-as-signals">Streams as signals</h4>
<ul>
<li>We can use streams to model signal-processing systems.</li>
<li>For example, taking the integral of a signal:</li>
</ul>
<div class="sourceCode" id="cb42"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(integral integrand initial-value dt)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> int</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    (cons-stream initial-value</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>                 (add-streams (scale-stream integrand dt)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>                              int)))</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  int)</span></code></pre></div>
<h3 id="streams-and-delayed-evaluation">Streams and Delayed Evaluation</h3>
<ul>
<li>The use of <code>delay</code> in <code>cons-stream</code> is crucial to defining streams with feedback loops.</li>
<li>However, there are cases where we need further, explicit uses of <code>delay</code>.</li>
<li>For example, solving the differential equation <span class="math inline">dy/dt = f(y)</span> where <span class="math inline">f</span> is a given function.</li>
<li>The problem here is that <code>y</code> and <code>dy</code> will depend on each other.</li>
<li>To solve this, we need to change <code>integral</code> to take a delayed integrand.</li>
</ul>
<h4 id="normal-order-evaluation">Normal-order evaluation</h4>
<ul>
<li>Explicit use of <code>delay</code> and <code>force</code> is powerful, but makes our programs more complex.</li>
<li>It creates two classes of procedures: normal, and ones that take delayed arguments.</li>
<li>(This is similar to the sync vs. async divide in modern programming languages.)</li>
<li>This forces us to define separate classes of higher-order procedures, unless we make everything delayed, equivalent to normal-order evaluation (like Haskell).</li>
<li>Mutability and delayed evaluation do not mix well.</li>
</ul>
<h3 id="modularity-of-functional-programs-and-modularity-of-objects">Modularity of Functional Programs and Modularity of Objects</h3>
<ul>
<li>Modularity through encapsulation is a major benefit of introducing assignment.</li>
<li>Stream models can provide equivalent modularity without assignment.</li>
<li>For example, we can reimplement the Monte Carlo simulation with streams.</li>
</ul>
<h4 id="a-functional-programming-view-of-time">A functional-programming view of time</h4>
<ul>
<li>Streams represent time explicitly, decoupling the simulated world from evaluation.</li>
<li>They produce stateful-seeming behavior but avoid all the thorny issues of state.</li>
<li>However, the issues come back when we need to merge streams together.</li>
<li>Immutability is a key pillar of <em>functional programming languages</em>.</li>
</ul>
<blockquote>
<p>We can model the world as a collection of separate, time-bound, interacting objects with state, or we can model the world as a single, timeless, stateless unity. Each view has powerful advantages, but neither view alone is completely satisfactory. A grand unification has yet to emerge. (486)</p>
</blockquote>
<blockquote>
<p>The object model approximates the world by dividing it into separate pieces. The functional model does not modularize along object boundaries. The object model is useful when the unshared state of the “objects” is much larger than the state that they share. (486)</p>
</blockquote>
<h1 id="chapter-4-metalinguistic-abstraction">Chapter 4: Metalinguistic Abstraction</h1>
<ul>
<li>Expert programmers build up abstractions from simpler concepts to higher-level ones, and preserve modularity by adopting appropriate large-scale views of system structure.</li>
<li>However, with increasingly complex problems we will find that Lisp, or any programming language, is not sufficient.</li>
</ul>
<blockquote>
<p>We must constantly turn to new languages in order to express our ideas more effectively. Establishing new languages is a powerful strategy for controlling complexity in engineering design; we can often enhance our ability to deal with a complex problem by adopting a new language that enables us to describe (and hence to think about) the problem in a different way, using primitives, means of combination, and means of abstraction that are particularly well suited to the problem at hand. (488)</p>
</blockquote>
<ul>
<li><em>Metalinguistic abstraction</em> means establishing new languages.</li>
<li>An <em>evaluator</em> (or <em>interpreter</em>) is a procedure that implements a programming language.</li>
</ul>
<blockquote>
<p>It is no exaggeration to regard this as the most fundamental idea in programming: The evaluator, which determines the meaning of expressions in a programming language, is just another program. (489)</p>
</blockquote>
<ul>
<li>Lisp is particularly well suited to metalinguistic abstraction.</li>
</ul>
<h2 id="the-metacircular-evaluator">The Metacircular Evaluator</h2>
<ul>
<li>We will implement a Lisp evaluator as a Lisp program.</li>
<li>The metacircular evaluator implements the environment model of evaluation:
<ol type="1">
<li>To evaluate a combination, evaluate subexpressions and then apply the operator subexpression to the operand subexpressions.</li>
<li>To apply a procedure to arguments, evaluate the body of the procedure in a new environment. To construct the new environment, extend the environment part of the procedure object by a frame in which the formal parameters of the procedure are bound to the arguments to which the procedure is applied.</li>
</ol></li>
<li>This embodies the interplay between two critical procedures, <code>eval</code> and <code>apply</code>.</li>
</ul>
<h3 id="the-core-of-the-evaluator">The Core of the Evaluator</h3>
<h4 id="eval"><code>Eval</code></h4>
<ul>
<li><code>eval</code> classifies an expression and directs its evaluation in an environment.</li>
<li>We use <em>abstract syntax</em> to avoid committing to a particular syntax in the evaluator.</li>
</ul>
<div class="sourceCode" id="cb43"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>        ((variable? <span class="kw">exp</span>) (lookup-variable-value <span class="kw">exp</span> env))</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        ((assignment? <span class="kw">exp</span>) (eval-assignment <span class="kw">exp</span> env))</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        ((definition? <span class="kw">exp</span>) (eval-definition <span class="kw">exp</span> env))</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        ((if? <span class="kw">exp</span>) (eval-if <span class="kw">exp</span> env))</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>        ((lambda? <span class="kw">exp</span>) (make-procedure (lambda-parameters <span class="kw">exp</span>)</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>                                       (lambda-body <span class="kw">exp</span>)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>                                       env))</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        ((begin? <span class="kw">exp</span>) (eval-sequence (begin-actions <span class="kw">exp</span>) env))</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>        ((cond? <span class="kw">exp</span>) (<span class="kw">eval</span> (cond-&gt;if <span class="kw">exp</span>) env))</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>        ((application? <span class="kw">exp</span>)</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>         (apply (<span class="kw">eval</span> (operator <span class="kw">exp</span>) env)</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>                (list-of-values (operands <span class="kw">exp</span>) env)))</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">else</span> (<span class="kw">error</span> <span class="st">&quot;Unknown expression type: EVAL&quot;</span> <span class="kw">exp</span>))))</span></code></pre></div>
<h4 id="apply"><code>Apply</code></h4>
<ul>
<li><code>apply</code> classifies a procedure and directs its application to a list of arguments.</li>
<li>If compound, it evaluates the procedure body in an extended environment.</li>
</ul>
<div class="sourceCode" id="cb44"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(apply procedure arguments)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cond</span> ((primitive-procedure? procedure)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>         (apply-primitive-procedure procedure arguments))</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>        ((compound-procedure? procedure)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>         (eval-sequence</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>          (procedure-body procedure)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>          (extend-environment</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>           (procedure-parameters procedure)</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>           arguments</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>           (procedure-environment procedure))))</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">else</span> (<span class="kw">error</span> <span class="st">&quot;Unknown procedure type: APPLY&quot;</span> procedure))))</span></code></pre></div>
<h3 id="representing-expressions">Representing Expressions</h3>
<ul>
<li>The evaluator is reminiscent of the symbolic differentiator: both make recursive computations on compound expressions, and both use data abstraction.</li>
<li>The syntax of the language is determined solely by procedures that classify and extract pieces of expressions. For example:</li>
</ul>
<div class="sourceCode" id="cb45"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;quote))</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>      false))</span></code></pre></div>
<h4 id="derived-expressions">Derived expressions</h4>
<ul>
<li>Some special forms can be defined in terms of others.</li>
<li>For example, we can reduce <code>cond</code> to an <code>if</code> expression:</li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(cond? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;cond))</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(cond-clauses <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(cond-else-clause? clause) (<span class="kw">eq?</span> (cond-predicate clause) &#39;else))</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(cond-predicate clause) (<span class="kw">car</span> clause))</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(cond-actions clause) (<span class="kw">cdr</span> clause))</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(cond-&gt;if <span class="kw">exp</span>) (expand-clauses (cond-clauses <span class="kw">exp</span>)))</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(expand-clauses clauses)</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="kw">null?</span> clauses)</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>      &#39;false <span class="co">; no else clause</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> ((first (<span class="kw">car</span> clauses))</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>            (rest (<span class="kw">cdr</span> clauses)))</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">if</span> (cond-else-clause? first)</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">if</span> (<span class="kw">null?</span> rest)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>                (sequence-&gt;exp (cond-actions first))</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>                (<span class="kw">error</span> <span class="st">&quot;ELSE clause isn&#39;t last: COND-&gt;IF&quot;</span> clauses))</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>            (make-if (cond-predicate first)</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>                     (sequence-&gt;exp (cond-actions first))</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>                     (expand-clauses rest))))))</span></code></pre></div>
<ul>
<li>Practical Lisp systems allow the user to define new derived expressions by syntactic transformation. These are called <em>macros</em>.</li>
<li>There is much research on avoiding name-conflict problems in macro definition languages.</li>
</ul>
<h3 id="evaluator-data-structures">Evaluator Data Structures</h3>
<h4 id="testing-of-predicates">Testing of predicates</h4>
<ul>
<li>Anything other than <code>false</code> is considered “truthy.”</li>
</ul>
<div class="sourceCode" id="cb47"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(true? x) (<span class="kw">not</span> (<span class="kw">eq?</span> x false)))</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(false? x) (<span class="kw">eq?</span> x false))</span></code></pre></div>
<h4 id="representing-procedures">Representing procedures</h4>
<ul>
<li><code>(apply-primitive-procedure &lt;proc&gt; &lt;args&gt;)</code> applies a primitive procedure to <code>&lt;args&gt;</code>.</li>
<li><code>(primitive-procedure? &lt;proc&gt;)</code> tests whether <code>&lt;proc&gt;</code> is a primitive procedure.</li>
<li>Compound procedures are represented by the following data structure:</li>
</ul>
<div class="sourceCode" id="cb48"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-procedure parameters body env)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">list</span> &#39;procedure parameters body env))</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(compound-procedure? p) (tagged-list? p &#39;procedure))</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(procedure-parameters p) (<span class="kw">cadr</span> p)) (<span class="ex">define</span><span class="fu"> </span>(procedure-body p) (<span class="kw">caddr</span> p))</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(procedure-environment p) (<span class="kw">cadddr</span> p))</span></code></pre></div>
<h4 id="operations-on-environments">Operations on environments</h4>
<ul>
<li><code>(lookup-variable-value &lt;var&gt; &lt;env&gt;)</code> returns the value bound to a variable.</li>
<li><code>(extend-environment &lt;variables&gt; &lt;values&gt; &lt;base-env&gt;)</code> returns a new environment extended with a frame containing the given bindings.</li>
<li><code>(define-variable! &lt;var&gt; &lt;value&gt; &lt;env&gt;)</code> adds a binding to the first frame of <code>&lt;env&gt;</code>.</li>
<li><code>(set-variable-value! &lt;var&gt; &lt;value&gt; &lt;env&gt;)</code> changes a binding in <code>&lt;env&gt;</code>.</li>
<li>Here is a partial implementation:</li>
</ul>
<div class="sourceCode" id="cb49"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(enclosing-environment env) (<span class="kw">cdr</span> env))</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(first-frame env) (<span class="kw">car</span> env))</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> the-empty-environment </span>&#39;())</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-frame variables <span class="kw">values</span>) (<span class="kw">cons</span> variables <span class="kw">values</span>))</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(frame-variables frame) (<span class="kw">car</span> frame))</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(frame-values frame) (<span class="kw">cdr</span> frame))</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(extend-environment vars vals base-env)</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">=</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">cons</span> (make-frame vars vals) base-env)</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">if</span> (<span class="op">&lt;</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">error</span> <span class="st">&quot;Too many arguments supplied&quot;</span> vars vals)</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">error</span> <span class="st">&quot;Too few arguments supplied&quot;</span> vars vals))))</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(lookup-variable-value var env)</span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> </span>(env-loop env)</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>    (<span class="ex">define</span><span class="fu"> </span>(scan vars vals)</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">cond</span> ((<span class="kw">null?</span> vars) (env-loop (enclosing-environment env)))</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>            ((<span class="kw">eq?</span> var (<span class="kw">car</span> vars)) (<span class="kw">car</span> vals))</span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">else</span> (scan (<span class="kw">cdr</span> vars) (<span class="kw">cdr</span> vals)))))</span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="kw">eq?</span> env the-empty-environment)</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">error</span> <span class="st">&quot;Unbound variable&quot;</span> var)</span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">let</span> ((frame (first-frame env)))</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>          (scan (frame-variables frame) (frame-values frame)))))</span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>  (env-loop env))</span></code></pre></div>
<ul>
<li>This representation is simple, but inefficient, since the evaluator may have to search through many frames to find a binding. This approach is called <em>deep binding</em>.</li>
</ul>
<h3 id="running-the-evaluator-as-a-program">Running the Evaluator as a Program</h3>
<ul>
<li>We can run our evaluator as a program: Lisp within Lisp.</li>
<li>The evaluator ultimately reduces expressions to applications of primitive procedures, so we need the evaluator to map these to the underlying Lisp’s primitive procedures.</li>
<li>We set up a global environment mapping primitive procedures, <code>true</code>, and <code>false</code>:</li>
</ul>
<div class="sourceCode" id="cb50"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(setup-environment)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((initial-env</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>         (extend-environment (primitive-procedure-names)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>                             (primitive-procedure-objects)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>                             the-empty-environment)))</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    (define-variable! &#39;true true initial-env)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    (define-variable! &#39;false false initial-env)</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    initial-env))</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> the-global-environment </span>(setup-environment))</span></code></pre></div>
<ul>
<li>We define a list of primitive procedures <code>car</code>, <code>cdr</code>, <code>cons</code>, and <code>null?</code>:</li>
</ul>
<div class="sourceCode" id="cb51"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(primitive-procedure? proc) (tagged-list? proc &#39;primitive))</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(primitive-implementation proc) (<span class="kw">cadr</span> proc))</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> primitive-procedures</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">list</span> (<span class="kw">list</span> &#39;car <span class="kw">car</span>)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">list</span> &#39;cdr <span class="kw">cdr</span>)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">list</span> &#39;cons <span class="kw">cons</span>)</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">list</span> &#39;null? <span class="kw">null?</span>)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>        &lt;more primitives&gt;))</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(primitive-procedure-names)</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>  (map <span class="kw">car</span> primitive-procedures))</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(primitive-procedure-objects)</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>  (map (<span class="kw">lambda</span> (proc) (<span class="kw">list</span> &#39;primitive (<span class="kw">cadr</span> proc)))</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>       primitive-procedures))</span></code></pre></div>
<ul>
<li>Here, <code>apply-in-underlying-scheme</code> refers to the built-in <code>apply</code>, not the one we defined:</li>
</ul>
<div class="sourceCode" id="cb52"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(apply-primitive-procedure proc args)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  (apply-in-underlying-scheme (primitive-implementation proc) args))</span></code></pre></div>
<ul>
<li>Finally, we make a simple <em>driver loop</em>, or REPL:</li>
</ul>
<div class="sourceCode" id="cb53"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> input-prompt </span><span class="st">&quot;;;; M-Eval input:&quot;</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> output-prompt </span><span class="st">&quot;;;; M-Eval value:&quot;</span>)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(driver-loop)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  (prompt-for-input input-prompt)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((input (<span class="kw">read</span>)))</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> ((output (<span class="kw">eval</span> input the-global-environment)))</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>      (announce-output output-prompt)</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>      (user-print output)))</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>  (driver-loop))</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(prompt-for-input <span class="kw">string</span>)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">newline</span>) (<span class="kw">newline</span>) (<span class="kw">display</span> <span class="kw">string</span>) (<span class="kw">newline</span>))</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(announce-output <span class="kw">string</span>)</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">newline</span>) (<span class="kw">display</span> <span class="kw">string</span>) (<span class="kw">newline</span>))</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(user-print object)</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (compound-procedure? object)</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">display</span> (<span class="kw">list</span> &#39;compound-procedure</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>                     (procedure-parameters object)</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>                     (procedure-body object)</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>                     &#39;&lt;procedure-env&gt;))</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">display</span> object)))</span></code></pre></div>
<h3 id="data-as-programs">Data as Programs</h3>
<ul>
<li>A program can be viewed as a description of an abstract machine.</li>
<li>The evaluator is a machine that emulates another machine given its description. In other words, the evaluator is a <em>universal machine</em>.</li>
<li>Deep idea: any evaluator can emulate any other. This gets to the heart of <em>computability</em>.</li>
<li>Just as the evaluator can emulate any Lisp-described machine, a <em>universal Turing machine</em> can emulate any other Turing machine.</li>
<li>The existence of a universal machine is a deep and wonderful property of computation.</li>
<li>The user’s programs are the evaluator’s data. Lisp takes advantage of this and provides a primitive <code>eval</code> procedure for evaluating data as programs.</li>
</ul>
<h3 id="internal-definitions-1">Internal Definitions</h3>
<ul>
<li>Global definitions have <em>sequential scoping</em>: they are defined one at a time.</li>
<li>Internal definitions should have <em>simultaneous scoping</em>, as if defined all at once.</li>
<li>The Scheme standard requires internal definitions to come first in the body and not use each other during evaluation. Although this restriction makes sequential and simultaneous scoping equivalent, simultaneous scoping makes compiler optimization easier.</li>
<li>To achieve simultaneous scoping, we “scan out” internal definitions:</li>
</ul>
<div class="sourceCode" id="cb54"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> &lt;vars&gt;</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> u </span>&lt;e1&gt;)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  (<span class="ex">define</span><span class="fu"> v </span>&lt;e2&gt;)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  &lt;e3&gt;)</span></code></pre></div>
<ul>
<li>Transforming them into a <code>let</code> with assignments:</li>
</ul>
<div class="sourceCode" id="cb55"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> &lt;vars&gt;</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((u &#39;*unassigned*)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>        (v &#39;*unassigned*))</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set!</span> u &lt;e1&gt;)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set!</span> v &lt;e2&gt;) &lt;e3&gt;))</span></code></pre></div>
<ul>
<li>Here, <code>*unassigned*</code> is a special symbol causing an error upon variable lookup.</li>
</ul>
<h3 id="separating-syntactic-analysis-from-execution">Separating Syntactic Analysis from Execution</h3>
<ul>
<li>Our evaluator is inefficient because it interleaves syntactic analysis with execution.</li>
<li>For example, given a recursive procedure:</li>
</ul>
<div class="sourceCode" id="cb56"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(factorial n)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">=</span> n <span class="dv">1</span>) <span class="dv">1</span> (<span class="op">*</span> (factorial (<span class="op">-</span> n <span class="dv">1</span>)) n)))</span></code></pre></div>
<ul>
<li>When evaluating <code>(factorial 4)</code>, on all four recursive calls the evaluator must determine anew that the body is an <code>if</code> expression by reaching the <code>if?</code> test.</li>
<li>We can arrange the evaluator to analyze syntax only once by splitting <code>eval</code> into two parts:
<ul>
<li><code>(analyze exp)</code> performs syntactic analysis and returns an <em>execution procedure</em>.</li>
<li><code>((analyze exp) env)</code> completes the evaluation.</li>
</ul></li>
<li><code>analyze</code> is similar to the <a href="#the-core-of-the-evaluator">original <code>eval</code></a>, except it only performs analysis, not full evaluation:</li>
</ul>
<div class="sourceCode" id="cb57"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(analyze <span class="kw">exp</span>)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) (analyze-self-evaluating <span class="kw">exp</span>))</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>        ((quoted? <span class="kw">exp</span>) (analyze-quoted <span class="kw">exp</span>))</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>        ((variable? <span class="kw">exp</span>) (analyze-variable <span class="kw">exp</span>))</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        ((assignment? <span class="kw">exp</span>) (analyze-assignment <span class="kw">exp</span>))</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>        ((definition? <span class="kw">exp</span>) (analyze-definition <span class="kw">exp</span>))</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        ((if? <span class="kw">exp</span>) (analyze-if <span class="kw">exp</span>))</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        ((lambda? <span class="kw">exp</span>) (analyze-lambda <span class="kw">exp</span>))</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>        ((begin? <span class="kw">exp</span>) (analyze-sequence (begin-actions <span class="kw">exp</span>)))</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>        ((cond? <span class="kw">exp</span>) (analyze (cond-&gt;if <span class="kw">exp</span>)))</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>        ((application? <span class="kw">exp</span>) (analyze-application <span class="kw">exp</span>))</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">else</span> (<span class="kw">error</span> <span class="st">&quot;Unknown expression type: ANALYZE&quot;</span> <span class="kw">exp</span>))))</span></code></pre></div>
<ul>
<li>Here is one of the helper procedures, <code>analyze-lambda</code>. It provides a major gain in efficiency because we only analyze the lambda body once, no matter how many times the procedure is called.</li>
</ul>
<div class="sourceCode" id="cb58"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(analyze-lambda <span class="kw">exp</span>)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((vars (lambda-parameters <span class="kw">exp</span>))</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>        (bproc (analyze-sequence (lambda-body <span class="kw">exp</span>))))</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (env) (make-procedure vars bproc env))))</span></code></pre></div>
<h2 id="variations-on-a-scheme-lazy-evaluation">Variations on a Scheme — Lazy Evaluation</h2>
<ul>
<li>We can experiment with different language design just by modifying the evaluator.</li>
<li>This is often how new languages are invented. It’s easy to iterate on a high level evaluator, and it also allows stealing features from the underlying language.</li>
</ul>
<h3 id="normal-order-and-applicative-order">Normal Order and Applicative Order</h3>
<ul>
<li><a href="#applicative-order-versus-normal-order">Earlier</a>, we noted that scheme is an <em>applicative-order</em> language.</li>
<li><em>Normal-order</em> languages use <em>lazy evaluation</em> to delay evaluation as long as possible.</li>
<li>Consider this procedure:</li>
</ul>
<div class="sourceCode" id="cb59"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(try a b) (<span class="kw">if</span> <span class="op">=</span> a <span class="dv">0</span>) <span class="dv">1</span> b)</span></code></pre></div>
<ul>
<li>In Scheme, <code>(try 0 (/ 1 0))</code> causes a division-by-zero error. With lazy evaluation, it does not because the value of <code>b</code> is never needed.</li>
<li>In a lazy language, we can implement <code>if</code> as an ordinary procedure.</li>
</ul>
<h3 id="an-interpreter-with-lazy-evaluation">An Interpreter with Lazy Evaluation</h3>
<ul>
<li>In this section, we will modify the interpreter to support lazy evaluation.</li>
<li>The lazy evaluator <em>delays</em> certain arguments, transforming them into <em>thunks</em>.</li>
<li>The expression in a thunk does not get evaluated until the thunk is <em>forced</em>.</li>
<li>A thunk gets forced when its value is needed:
<ul>
<li>when passed to a primitive procedure;</li>
<li>when it is the predicate of conditional;</li>
<li>when it is an operator about to be applied as a procedure.</li>
</ul></li>
<li>This is similar to <a href="#streams-are-delayed-lists">streams</a>, but uniform and automatic throughout the language.</li>
<li>For efficiency, we’ll make our interpreter <em>memoize</em> thunks.
<ul>
<li>This is called <em>call-by-need</em>, as opposed to non-memoized <em>call-by-name</em>.</li>
<li>It raises subtle and confusing issues in the presence of assignments.</li>
</ul></li>
</ul>
<h4 id="modifying-the-evaluator">Modifying the evaluator</h4>
<ul>
<li>The main change required is the procedure application logic in <code>eval</code> and <code>apply</code>.</li>
<li>The <code>application?</code> clause of <code>eval</code> becomes:</li>
</ul>
<div class="sourceCode" id="cb60"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>((application? <span class="kw">exp</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a> (apply (actual-value (operator <span class="kw">exp</span>) env)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>        (operands <span class="kw">exp</span>)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>        env))</span></code></pre></div>
<ul>
<li>Whenever we need the actual value of an expression, we force in addition to evaluating:</li>
</ul>
<div class="sourceCode" id="cb61"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(actual-value <span class="kw">exp</span> env) (force-it (<span class="kw">eval</span> <span class="kw">exp</span> env)))</span></code></pre></div>
<ul>
<li>We change <code>apply</code> to take <code>env</code>, and use <code>list-of-arg-values</code> and <code>list-of-delayed-args</code>:</li>
</ul>
<div class="sourceCode" id="cb62"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(apply procedure arguments env)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cond</span> ((primitive-procedure? procedure)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>         (apply-primitive-procedure</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>          procedure</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>          (list-of-arg-values arguments env)))  <span class="co">; changed</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>        ((compound-procedure? procedure)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>         (eval-sequence</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>          (procedure-body procedure)</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>          (extend-environment</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>           (procedure-parameters procedure)</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>           (list-of-delayed-args arguments env) <span class="co">; changed</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>           (procedure-environment procedure))))</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">else</span> (<span class="kw">error</span> <span class="st">&quot;Unknown procedure type: APPLY&quot;</span> procedure))))</span></code></pre></div>
<ul>
<li>We also need to change <code>eval-if</code> to use <code>actual-value</code> on the predicate:</li>
</ul>
<div class="sourceCode" id="cb63"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(eval-if <span class="kw">exp</span> env)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (true? (actual-value (if-predicate <span class="kw">exp</span>) env))</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">eval</span> (if-consequent <span class="kw">exp</span>) env)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">eval</span> (if-alternative <span class="kw">exp</span>) env)))</span></code></pre></div>
<h4 id="representing-thunks">Representing thunks</h4>
<ul>
<li>To force a thunk, we evaluate it in its environment. We use <code>actual-value</code> instead of <code>eval</code> so that it recursively forces if the result is another thunk:</li>
</ul>
<div class="sourceCode" id="cb64"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(force-it obj)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (thunk? obj)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>      (actual-value (thunk-exp obj) (thunk-env obj))</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>      obj))</span></code></pre></div>
<ul>
<li>We can represent thunks simply by a list containing the expression and environment:</li>
</ul>
<div class="sourceCode" id="cb65"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(delay-it <span class="kw">exp</span> env) (<span class="kw">list</span> &#39;thunk <span class="kw">exp</span> env))</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(thunk? obj) (tagged-list? obj &#39;thunk))</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(thunk-exp thunk) (<span class="kw">cadr</span> thunk))</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(thunk-env thunk) (<span class="kw">caddr</span> thunk))</span></code></pre></div>
<ul>
<li>To memoize thunks, <code>force-it</code> becomes a bit more complicated.</li>
</ul>
<h3 id="streams-as-lazy-lists">Streams as Lazy Lists</h3>
<ul>
<li>Before introducing lazy evaluation, we <a href="#streams-are-delayed-lists">implemented streams as delayed lists</a>.</li>
<li>We can instead formulate streams as <em>lazy</em> lists. There are two advantages:
<ol type="1">
<li>No need for special forms <code>delay</code> and <code>cons-stream</code>.</li>
<li>No need for separate list and stream operations.</li>
</ol></li>
<li>All we need to do is make <code>cons</code> lazy, either by introducing non-strict primitives or by defining <code>cons</code>, <code>car</code>, and <code>cdr</code> <a href="#what-is-meant-by-data">as compound procedures</a>.</li>
<li>Now we can write code without distinguishing normal lists from infinite ones:</li>
</ul>
<div class="sourceCode" id="cb66"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> ones </span>(<span class="kw">cons</span> <span class="dv">1</span> ones))</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(scale-list items factor) (map (<span class="kw">lambda</span> (x) (<span class="op">*</span> x factor)) items))</span></code></pre></div>
<ul>
<li>These lazy lists are even lazier than our original streams, since the <code>car</code> is delayed too.</li>
<li>This also eliminates <a href="#streams-and-delayed-evaluation">the problems we had earlier</a> around having to explicitly delay and force some arguments when computing integrals.</li>
</ul>
<h2 id="variations-on-a-scheme-nondeterministic-computing">Variations on a Scheme — Nondeterministic Computing</h2>
<ul>
<li><em>Nondeterministic computing</em></li>
</ul>
<footer class="footer">© 2020 Mitchell Kember</footer>
</body>
</html>
