<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Section 1.3 Notes</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link rel="stylesheet" href="../../assets/style.css">
</head>
<body>
<header class="header ">
  <a class="title link" href="../../index.html">SICP Study</a>
  <span class="gap"></span>
  <nav class="sitenav">
    <a class="sitenav__item link  sitenav__item--active" href="../../text/index.html">Text</a>
    <a class="sitenav__item link " href="../../lecture/index.html">Lecture</a>
    <a class="sitenav__item link " href="../../exercise/index.html">Exercise</a>
    <a class="sitenav__item link" href="https://github.com/mk12/sicp">Source <svg class="github-mark" width="25" height="25" viewBox="0 0 136 133">
  <g transform="matrix(1,0,0,1,-568.001,-447.669)">
    <g transform="matrix(4.16667,0,0,4.16667,0,0)">
      <g transform="matrix(1,0,0,1,152.608,139.345)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.778 -11.354,-8.279 -11.354,-8.279C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.154 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.237C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.839 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.839 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904"/>
      </g>
    </g>
  </g>
</svg></a>
  </nav>
</header>
<nav class="pagenav pagenav--top">
  <div class="pagenav__item pagenav__item--prev"><a class="pagenav__link link" href="2.html">← Prev</a></div>
  <div class="pagenav__item pagenav__item--up"><a class="pagenav__link link" href="index.html">↑ Up</a></div>
  <div class="pagenav__item pagenav__item--next"><a class="pagenav__link link" href="../2/index.html">Next →</a></div>
</nav>
<h1>
Formulating Abstractions with Higher-Order Procedures<small class="number">1.3</small>
</h1>
<blockquote>
<p>We have seen that procedures are, in effect, abstractions that describe compound operations on numbers independent of the particular numbers. (74) FOO</p>
</blockquote>
<ul>
<li>We could always use <code class="sourceCode scheme">(<span class="op">*</span> x x x)</code> instead of using a cube procedure, but this would be a disadvantage.</li>
</ul>
<blockquote>
<p>One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the abstractions directly. (75) FOO</p>
</blockquote>
<ul>
<li>Even with procedures, we are still limiting ourselves if we only ever let parameters be numbers.</li>
<li>To abstract more general programming patterns, we need to write precedes that take other procedures as arguments and return new procedures.</li>
<li>These are called <em>higher-order</em> procedures.</li>
</ul>
<h2 id="1.3.1" class="anchor">
<a class="anchor__link link" href="#1.3.1">#</a>Procedures as Arguments<small class="number">1.3.1</small>
</h3>
<p>Procedures that compute a sum are all similar. They are all based on the following template:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(&lt;name&gt; a b)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      (<span class="op">+</span> (&lt;term&gt; a)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>         (&lt;name&gt; (&lt;next&gt; a) b))))</span></code></pre></div>
<p>This is a useful abstraction, just as sigma notation in math is useful because the summation of a series is so common.</p>
<blockquote>
<p>The power of sigma notation is that it allows mathematicians to deal with the concept of summation itself rather than only with particular sums. (77) FOO</p>
</blockquote>
<h2 id="1.3.2" class="anchor">
<a class="anchor__link link" href="#1.3.2">#</a>Constructing Procedures Using <code>Lambda</code><small class="number">1.3.2</small>
</h3>
<p><code>lambda</code> creates anonymous procedures. They are just like the procedures created by <code>define</code>, but without a name: <code class="sourceCode scheme">(<span class="kw">lambda</span> (&lt;formal-parameters&gt;) &lt;body&gt;)</code>.</p>
<p>A lambda expression can be used as the operand in a combination. It will be evaluated to a procedure and applied to the arguments (the evaluated operands). The name comes from the λ-calculus, which was introduced by Alonzo Church.</p>
<h3 id="1.3.2.1" class="anchor">
<a class="anchor__link link" href="#1.3.2.1">#</a>Using <code>let</code> to create local variables
</h3>
<ul>
<li>We often need local variables other than the ones that have been bound as formal parameters.</li>
<li>We can do this with a lambda expression that takes the local variables as arguments, but this is so common that there is a special <code>let</code> form that does it.</li>
</ul>
<p>The general form of a let-expression is</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((&lt;var1&gt; &lt;exp1&gt;)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>      (&lt;var2&gt; &lt;exp2&gt;)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      (&lt;varn&gt; &lt;expn&gt;))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  &lt;body&gt;)</span></code></pre></div>
<p>This is just syntactic sugar for</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>((<span class="kw">lambda</span> (&lt;var1&gt; &lt;var2&gt; <span class="op">...</span> &lt;varn&gt;)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>   &lt;body&gt;)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a> &lt;exp1&gt;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a> &lt;exp2&gt;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a> <span class="op">...</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a> &lt;expn&gt;)</span></code></pre></div>
<ul>
<li>The scope of a variable in a let-expression is the body.</li>
<li>This allows variables to be bound as locally as possible.</li>
<li>The variables in the let-expression are parallel and independent. They cannot refer to each other, and their order does not matter.</li>
<li>You can use let-expressions (<code>let</code>, <code>let*</code>, and <code>letrec</code>) instead of internal definitions (block structure).</li>
</ul>
<h2 id="1.3.3" class="anchor">
<a class="anchor__link link" href="#1.3.3">#</a>Procedures as General Methods<small class="number">1.3.3</small>
</h3>
<p>So far, we have seen</p>
<ul>
<li>compound procedures that abstract patterns of numerical operators (mathematical functions), independent of the particular numbers;</li>
<li>higher-order procedures that express a more powerful kind of abstraction, independent of the procedures involved.</li>
</ul>
<p>Now we will take it a bit further.</p>
<h3 id="1.3.3.1" class="anchor">
<a class="anchor__link link" href="#1.3.3.1">#</a>Finding roots of equations by the half-interval method
</h3>
<ul>
<li>The <em>half-interval</em> method: a simple but powerful technique for finding the solutions to <span class="math inline">f(x) = 0</span>.</li>
<li>Given <span class="math inline">f(a) &lt; 0 &lt; f(b)</span>, there must be at least one zero between <span class="math inline">a</span> and <span class="math inline">b</span>.</li>
<li>To narrow it down, we let <span class="math inline">x</span> be the average of <span class="math inline">a</span> and <span class="math inline">b</span>, and then replace either the left bound or the right bound with it.</li>
</ul>
<h3 id="1.3.3.2" class="anchor">
<a class="anchor__link link" href="#1.3.3.2">#</a>Finding fixed points of a function
</h3>
<ul>
<li>A number <span class="math inline">x</span> is a <em>fixed point</em> of a function if <span class="math inline">f(x) = x</span>.</li>
<li>In some cases, repeatedly applying the function to an initial guess will converge on the fixed point.</li>
<li>The procedure we made earlier for finding square roots is actually a special case of the fixed point procedure.</li>
</ul>
<h2 id="1.3.4" class="anchor">
<a class="anchor__link link" href="#1.3.4">#</a>Procedures as Returned Values<small class="number">1.3.4</small>
</h3>
<p>Passing procedures as arguments gives us expressive power; Returning procedures from functions gives us even more. For example, we can write a procedure that creates a new procedure with average damping:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(average-damp f)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (average x (f x))))</span></code></pre></div>
<p>If we use <code>average-damp</code> on <code>square</code>, we actually get a procedure that takes the sum of the numbers from 1 to n:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>((average-damp square) <span class="dv">10</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span> <span class="dv">10</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span></span></code></pre></div>
<blockquote>
<p>In general, there are many ways to formulate a process as a procedure. Experienced programmers know how to choose procedural formulations that are particularly perspicuous, and where useful elements of the process are exposed as separate entities that can be reused in other applications.</p>
</blockquote>
<h3 id="1.3.4.1" class="anchor">
<a class="anchor__link link" href="#1.3.4.1">#</a>Newton’s method
</h3>
<p>The square-root procedure we did earlier was a special case of Newton’s method. Given a function <span class="math inline">f(x)</span>, the solution to <span class="math inline">f(x) = 0</span> is given by the fixed point of</p>
<p><span class="math display">x ↦ x - \frac{f(x)}{f&#39;(x)}.</span></p>
<p>Newton’s method converges very quickly – much faster than the half-interval method in favorable cases. We need a procedure to transform a function into its derivative (a new procedure). We can use a small dx for this:</p>
<p><span class="math display">f&#39;(x) = \frac{f(x+dx) - f(x)}{dx}.</span></p>
<p>This translates to the following procedure:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(deriv f)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (x) (<span class="op">/</span> (<span class="op">-</span> (f (<span class="op">+</span> x dx)) (f x)) dx)))</span></code></pre></div>
<p>Now we can do things like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(cube x) (<span class="op">*</span> x x x))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> dx </span><span class="fl">0.00001</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>((deriv cube) <span class="dv">5</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="fl">75.00014999664018</span></span></code></pre></div>
<h3 id="1.3.4.2" class="anchor">
<a class="anchor__link link" href="#1.3.4.2">#</a>Abstractions and first-class procedures
</h3>
<ul>
<li>Compound procedures permit us to express general methods of computing as explicit elements in our programming language.</li>
<li>Higher-order procedures permit us to manipulate these general methods to create further abstractions.</li>
<li>We should always be on the lookout for underlying abstractions that can be brought out and generalized.</li>
<li>This doesn’t mean we should always program in the most abstract form possible; there is a level appropriate for each task.</li>
<li>Elements with the fewest restrictions are <em>first-class</em>:
<ul>
<li>They may be named by variables.</li>
<li>They may be passed as arguments to procedures.</li>
<li>They may be returned as the results of procedures.</li>
<li>They may be included in data structures.</li>
</ul></li>
<li>In Lisp, procedures have first-class status. This gives us an enormous gain in expressive power.</li>
</ul>
<nav class="pagenav pagenav--bottom">
  <div class="pagenav__item pagenav__item--prev"><a class="pagenav__link link" href="2.html">← Prev</a></div>
  <div class="pagenav__item pagenav__item--up"><a class="pagenav__link link" href="index.html">↑ Up</a></div>
  <div class="pagenav__item pagenav__item--next"><a class="pagenav__link link" href="../2/index.html">Next →</a></div>
</nav>
<footer class="footer">© 2020 Mitchell Kember</footer>
</body>
</html>
