<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Section 1.1 Notes</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link rel="stylesheet" href="../../assets/style.css">
</head>
<body>
<header class="header">
  <a class="title" href="../../index.html">SICP Study</a>
  <span class="gap"></span>
  <nav class="sitenav">
    <a class="sitenav__item sitenav__item--active" href="../../text/index.html">Text</a>
    <a class="sitenav__item" href="../../lecture/index.html">Lecture</a>
    <a class="sitenav__item" href="../../exercise/index.html">Exercise</a>
    <a class="sitenav__item" href="https://github.com/mk12/sicp">Source <svg class="github-mark" width="25" height="25" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g transform="matrix(1,0,0,1,-568.001,-447.669)">
      <g transform="matrix(4.16667,0,0,4.16667,0,0)">
          <g transform="matrix(1,0,0,1,152.608,139.345)">
              <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.778 -11.354,-8.279 -11.354,-8.279C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.154 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.237C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.839 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.839 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904"/>
          </g>
      </g>
  </g>
</svg></a>
  </nav>
</header>
<nav class="pagenav">
  <div class="pagenav__prev"><a class="pagenav__link" href="index.html">← Prev</a></div>
  <div class="pagenav__up"><a class="pagenav__link" href="index.html">↑ Up</a></div>
  <div class="pagenav__next"><a class="pagenav__link" href="2.html">Next →</a></div>
</nav>
<h1>
The Elements of Programming<small class="number">1.1</small>
</h1>
<p>There are three mechanisms for combining simple ideas to form more complex ideas in every powerful programming language:</p>
<ul>
<li>primitive expressions,</li>
<li>means of combination,</li>
<li>means of abstraction.</li>
</ul>
<p>Programming deals with <em>procedures</em> and <em>data</em> (which are almost the same thing in Lisp). Procedures manipulate data.</p>
<h3 id="1.1.1">
<a class="anchor" href="#1.1.1">#</a>Expressions<small class="number">1.1.1</small>
</h3>
<ul>
<li>The REPL reads an expression, evaluates it, prints the result, and repeats.</li>
<li>A number is one kind of primitive expression.</li>
<li>An application of a primitive procedure is a compound expression.</li>
<li>Combination: list of expressions inside parentheses to denote procedure application.</li>
<li>The first element is the operator; the rest are the operands.</li>
<li>The value of the combination is the result of applying the value of the operator to the value of the operands.</li>
<li>Lisp combinations use prefix notation.</li>
<li>Combinations can be nested: an operator or operand can itself be another combination.</li>
</ul>
<h3 id="1.1.2">
<a class="anchor" href="#1.1.2">#</a>Naming and the Environment<small class="number">1.1.2</small>
</h3>
<ul>
<li>Scheme names things with the <code>define</code>. This is the simplest means of abstraction.</li>
<li>The name-value pairs are stored in an <em>environment</em>.</li>
</ul>
<h3 id="1.1.3">
<a class="anchor" href="#1.1.3">#</a>Evaluating Combinations<small class="number">1.1.3</small>
</h3>
<ul>
<li>To evaluate a combination, do the following:
<ol type="1">
<li>Evaluate the subexpressions of the combination.</li>
<li>Apply the procedure (value of left more subexpression, the operator) to the arguments (values of other subexpressions, the operands).</li>
</ol></li>
<li>Before evaluating a combination, we must first evaluate each element inside it.</li>
<li>Evaluation is recursive in nature – one of its steps is invoking itself.</li>
<li>The evaluation of a combination can be represents with a tree.</li>
<li>Recursion is a powerful technique for dealing with hierarchical, tree-like objects.</li>
<li>To end the recursion, we stipulate the following:
<ol type="1">
<li>Numbers evaluate to themselves.</li>
<li>Built-in operators evaluate to machine instruction sequences.</li>
<li>Names evaluate to the values associated with them in the environment.</li>
</ol></li>
<li>Rule 2 is a special case of rule 3 if we consider the arithmetic operators to be names in the environment.</li>
<li>Evaluating <code>(define x 3)</code> does not apply <code>define</code> to two arguments; this is not a combination.</li>
<li>Exceptions such as these are <em>special forms</em>. Each one has its own evaluation rule.</li>
</ul>
<blockquote>
<p>Syntactic sugar causes cancer of the semicolon. (Alan Perlis)</p>
</blockquote>
<h3 id="1.1.4">
<a class="anchor" href="#1.1.4">#</a>Compound Procedures<small class="number">1.1.4</small>
</h3>
<ul>
<li>Procedure definitions are very powerful for abstraction.</li>
<li>A squaring procedure: <code>(define (square x) (* x x))</code>.</li>
<li>This is a compound procedure given the name <em>square</em>.</li>
<li>The general form of a procedure definition is <code>(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)</code>.</li>
<li>If the body contains more than one expression, each is evaluated in sequence and the value of the last one is returned.</li>
</ul>
<h3 id="1.1.5">
<a class="anchor" href="#1.1.5">#</a>The Substitution Model for Procedure Application<small class="number">1.1.5</small>
</h3>
<p>This is the substation model:</p>
<blockquote>
<p>To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.</p>
</blockquote>
<p>An example of procedure application:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(f <span class="dv">5</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(sum-of-squares (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>) (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(sum-of-squares <span class="dv">6</span> <span class="dv">10</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> (square <span class="dv">6</span>) (square <span class="dv">10</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> <span class="dv">36</span> <span class="dv">100</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">136</span></span></code></pre></div>
<h4 id="1.1.1.5">
<a class="anchor" href="#1.1.1.5">#</a>Applicative order versus normal order
</h4>
<ul>
<li>That example used <em>applicative order</em>: evaluate everything first, then apply the procedure to the arguments.</li>
<li>With <em>normal order</em>, operands are substituted in the procedure unevaluated. Only when it reaches primitive operators do combinations reduce to values.</li>
</ul>
<p>An example of normal order procedure application:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(f <span class="dv">5</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>(sum-of-squares (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>) (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> (square (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>)) (square (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>)))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> (<span class="op">*</span> (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>) (<span class="op">+</span> <span class="dv">5</span> <span class="dv">1</span>)) (<span class="op">*</span> (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>) (<span class="op">*</span> <span class="dv">5</span> <span class="dv">2</span>)))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> (<span class="op">*</span> <span class="dv">6</span> <span class="dv">6</span>) (<span class="op">*</span> <span class="dv">10</span> <span class="dv">10</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span> <span class="dv">36</span> <span class="dv">100</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dv">136</span></span></code></pre></div>
<ul>
<li>In this example, normal order causes a few combinations to be evaluated multiple times.</li>
<li>Applicative: evaluate the arguments and then apply.</li>
<li>Normal: fully expand and then reduce.</li>
</ul>
<h3 id="1.1.6">
<a class="anchor" href="#1.1.6">#</a>Conditional Expressions and Predicates<small class="number">1.1.6</small>
</h3>
<ul>
<li>To make more useful procedures, we need to be able to make tests and perform different operations accordingly.</li>
<li>We do <em>case analysis</em> in Scheme using <code>cond</code>.</li>
<li>Those conditional expressions work by testing each predicate. The consequent expression of the first clause with a true predicate is returned, and the other clauses are ignored.</li>
<li>A predicate is an expression that evaluates to true or false, or a procedure that returns true or false.</li>
<li>The symbol <code>else</code> can be used as the last clause – it will always evaluate to true.</li>
<li>The <code>if</code> conditional can be used when there are two cases.</li>
<li>Logical values can be combined with <code>and</code>, <code>or</code>, and <code>not</code>. The first two are special forms, not procedures.</li>
</ul>
<h3 id="1.1.7">
<a class="anchor" href="#1.1.7">#</a>Example: Square Roots by Newton’s Method<small class="number">1.1.7</small>
</h3>
<blockquote>
<p>But there is an important difference between mathematical functions and computer procedures. Procedures must be effective. (28)</p>
</blockquote>
<ul>
<li>In mathematics, you can say “the square root of <span class="math inline">x</span> is the nonnegative <span class="math inline">y</span> such that <span class="math inline">y^2 = x</span>.” This is not a procedure.</li>
<li>Mathematical functions describes things (declarative knowledge); procedures describe how to do things (imperative knowledge).</li>
<li>Declarative is <em>what is</em>, imperative is <em>how to</em>.</li>
</ul>
<h3 id="1.1.8">
<a class="anchor" href="#1.1.8">#</a>Procedures as Black-Box Abstractions<small class="number">1.1.8</small>
</h3>
<ul>
<li>Each procedure in a program should accomplish and identifiable task that can be used as a module in defining other procedures.</li>
<li>When we use a procedure as a “black box,” we are concerned with <em>what</em> it is doing but not <em>how</em> it is doing it.</li>
<li>This is called procedural abstraction. Its purpose is to suppress detail.</li>
</ul>
<blockquote>
<p>A user should not need to know how the procedure is implemented in order to use it. (35)</p>
</blockquote>
<h4 id="1.1.1.8">
<a class="anchor" href="#1.1.1.8">#</a>Local names
</h4>
<ul>
<li>The choice of names for the procedure’s formal parameters should not matter to the user of the procedure.</li>
<li>Consequentially, the parameter names must be local to the body of the procedure.</li>
<li>The name of the formal parameter doesn’t matter; it is called a <em>bound variable</em>. The procedure <em>binds</em> its formal parameters.</li>
<li>If a variable is not bound, it is <em>free</em>.</li>
<li>The expressions in which a binding exists is called the <em>scope</em> of the name. For parameters of procedures, this is the body.</li>
<li>Using the same name for a bound variable and an existing free variable is called <em>capturing</em> the variable.</li>
<li>The names of the free variables <em>do</em> matter for the meaning of the procedure.</li>
</ul>
<h4 id="1.1.1.8">
<a class="anchor" href="#1.1.1.8">#</a>Internal definitions and block structure
</h4>
<ul>
<li>Putting a definition in the body of a procedure makes it local to that procedure. This nesting is called <em>block structure</em>.</li>
<li>Now we have two kinds of name isolation: formal parameters and internal definitions.</li>
<li>By internalizing auxiliary procedures, we can often eliminate bindings by allowing variables to remain free.</li>
<li>Lexical scoping: free variables in a procedure refer to bindings in enclosing procedure definitions.</li>
</ul>
<nav class="pagenav">
  <div class="pagenav__prev"><a class="pagenav__link" href="index.html">← Prev</a></div>
  <div class="pagenav__up"><a class="pagenav__link" href="index.html">↑ Up</a></div>
  <div class="pagenav__next"><a class="pagenav__link" href="2.html">Next →</a></div>
</nav>
<footer class="footer">© 2020 Mitchell Kember</footer>
</body>
</html>
