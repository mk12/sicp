<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Section 1.2 Notes</title>
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css">
  <link rel="stylesheet" href="../../assets/style.css">
</head>
<body>
<div hidden>
  <svg>
    <symbol id="up" viewBox="0 0 11 12">
      <path fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" d="M5.5.8v10.4m4.457-5.943L5.5.8 1.043 5.257"/>
    </symbol>
    <symbol id="left" viewBox="0 0 12 11">
      <path fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" d="M.8 5.5h10.4M5.257 9.957L.8 5.5l4.457-4.457"/>
    </symbol>
    <symbol id="right" viewBox="0 0 12 11">
      <use xlink:href="#left" transform="matrix(-1 0 0 1 12 0)"/>
    </symbol>
    <symbol id="external" viewBox="0 0 24 24">
      <path fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" d="M10.688 5.438H4.125A2.65 2.65 0 001.5 8.063v11.812A2.65 2.65 0 004.125 22.5h11.813a2.65 2.65 0 002.624-2.625v-6.563m-9.187 1.313L22.5 1.5m-6.563 0H22.5v6.563"/>
    </symbol>
    <symbol id="circle-left" viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9" stroke-width="1.69" transform="matrix(.8889 0 0 .8889 -1.667 -1.667)"/>
      <path stroke-width="1.5" d="M5.229 9h7.542M9 5.229L5.229 9 9 12.771"/>
    </symbol>
  </svg>
</div>
<a class="skip-link" href="#main">Skip to main content</a>
<header class="header">
  <a class="title link" href="../../index.html">SICP Study</a>
  <nav class="sitenav" aria-label="site">
    <a class="sitenav__item sitenav__item--active link"
        href="../../text/index.html" aria-label="textbook notes">Text</a>
    <a class="sitenav__item link"
        href="../../lecture/index.html" aria-label="lecture notes">Lecture</a>
    <a class="sitenav__item link"
        href="../../exercise/index.html" aria-label="exercises">Exercise</a>
    <a class="sitenav__item sitenav__item--last link"
        href="https://github.com/mk12/sicp" aria-label="GitHub repository">
      Source
      <svg class="github-mark" width="25" height="25" viewBox="0 0 136 133" aria-hidden="true">
        <path fill="currentColor" d="M67.866.002C30.387.002 0 30.39 0 67.877c0 29.988 19.446 55.425 46.417 64.404 3.396.621 4.633-1.475 4.633-3.275 0-1.608-.058-5.879-.091-11.541-18.88 4.1-22.863-9.1-22.863-9.1-3.087-7.838-7.537-9.925-7.537-9.925-6.163-4.213.466-4.13.466-4.13 6.813.484 10.396 6.996 10.396 6.996 6.054 10.371 15.888 7.375 19.754 5.642.617-4.387 2.367-7.38 4.309-9.075-15.071-1.712-30.917-7.537-30.917-33.546 0-7.408 2.646-13.466 6.988-18.212-.7-1.717-3.03-8.617.662-17.963 0 0 5.7-1.825 18.667 6.959 5.412-1.505 11.22-2.259 16.992-2.284 5.762.025 11.57.78 16.991 2.284 12.959-8.784 18.646-6.959 18.646-6.959 3.704 9.346 1.375 16.246.675 17.963 4.35 4.746 6.98 10.804 6.98 18.212 0 26.075-15.872 31.813-30.992 33.492 2.437 2.096 4.608 6.237 4.608 12.57 0 9.072-.083 16.392-.083 18.617 0 1.817 1.22 3.93 4.666 3.267 26.95-8.996 46.38-34.417 46.38-64.396 0-37.487-30.392-67.875-67.88-67.875"/>
      </svg>      
    </a>
  </nav>
</header>
<nav class="pagenav pagenav--top" aria-label="page">
  <div class="pagenav__item pagenav__item--left">
    <a class="pagenav__link link" href="1.html" aria-label="previous page">
      <svg width="12" height="11" aria-hidden="true"><use xlink:href="#left"/>
      </svg><span class="pagenav__prev">Prev</span>
    </a>
  </div>
  <div class="pagenav__item pagenav__item--center">
    <a class="pagenav__link link" href="index.html" aria-label="parent page">
      <svg width="11" height="12" aria-hidden="true"><use xlink:href="#up"/>
      </svg><span class="pagenav__up">Up</span>
    </a>
  </div>
  <div class="pagenav__item pagenav__item--right">
    <a class="pagenav__link link" href="3.html" aria-label="next page">
      <span class="pagenav__next">Next</span
        ><svg width="12" height="11" aria-hidden="true"
        ><use xlink:href="#right"/></svg>
    </a>
  </div>
</nav>
<main id="main">
<article>
<h1>
<span class="number">1.2</span> <a class="link" href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html">Procedures and the Processes They Generate<span class="nowrap">﻿<svg class="external" width="24" height="24" aria-hidden="true"><use xlink:href="#external"/></svg></span></a>
</h1>
<blockquote>
<p>To become experts, we must learn to visualize the processes generated by various types of procedures. Only after we have developed such a skill can we learn to reliably construct programs that exhibit the desired behavior. (40)</p>
</blockquote>
<ul>
<li>A procedure is a pattern for the <em>local evolution</em> of a computation process: how one stage is built on the previous.</li>
<li>The global behavior of a computational process is much harder to reason about.</li>
<li>Processes governed by different types of procedures generate different “shapes” of evolution.</li>
<li>There are two important resources that computational processes consume: time and space.</li>
</ul>
<h2 id="1.2.1" class="anchor">
<a class="anchor__link link" href="#1.2.1" aria-hidden="true">#</a> <span class="number">1.2.1</span> <a class="link" href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.1">Linear Recursion and Iteration<span class="nowrap">﻿<svg class="external" width="24" height="24" aria-hidden="true"><use xlink:href="#external"/></svg></span></a>
</h2>
<ul>
<li>The factorial of HELLO is defined as the product of the integers on the interval HELLO.</li>
<li>The naive <em>recursive</em> implementation creates a curved shape:</li>
</ul>
<pre><code class="blockcode">(factorial <span class="cn">4</span>)
(<span class="fu">*</span> <span class="cn">4</span> (factorial <span class="cn">3</span>))
(<span class="fu">*</span> <span class="cn">4</span> (<span class="fu">*</span> <span class="cn">3</span> (factorial <span class="cn">2</span>)))
(<span class="fu">*</span> <span class="cn">4</span> (<span class="fu">*</span> <span class="cn">3</span> (<span class="fu">*</span> <span class="cn">2</span> (factorial <span class="cn">1</span>))))
(<span class="fu">*</span> <span class="cn">4</span> (<span class="fu">*</span> <span class="cn">3</span> (<span class="fu">*</span> <span class="cn">2</span> <span class="cn">1</span>)))
(<span class="fu">*</span> <span class="cn">4</span> (<span class="fu">*</span> <span class="cn">3</span> <span class="cn">2</span>))
(<span class="fu">*</span> <span class="cn">4</span> <span class="cn">6</span>)
<span class="cn">24</span></code></pre>
<ul>
<li>The <em>iterative</em> implementation maintains a running product and multiplies the numbers from 1 to HELLO to it.</li>
<li>This creates a shape with a straight edge:</li>
</ul>
<pre><code class="blockcode">(factorial <span class="cn">4</span>)
(fact-iter <span class="cn">1</span> <span class="cn">1</span> <span class="cn">4</span>)
(fact-iter <span class="cn">1</span> <span class="cn">2</span> <span class="cn">4</span>)
(fact-iter <span class="cn">2</span> <span class="cn">3</span> <span class="cn">4</span>)
(fact-iter <span class="cn">6</span> <span class="cn">4</span> <span class="cn">4</span>)
(fact-iter <span class="cn">24</span> <span class="cn">5</span> <span class="cn">4</span>)
<span class="cn">24</span></code></pre>
<ul>
<li>Both compute the same mathematical function, but the computational processes evolve very differently.</li>
<li>The first one is a <em>linear recursive process</em>. The chain of deferred operations causes an expansion (as more operations are added) and a contraction (as the operations are performed).
<ul>
<li>The interpreter must keep track of all these operations.</li>
<li>It is a <em>linear</em> recursive process because the information it must keep track of (the call stack) grows linearly with HELLO.</li>
</ul></li>
<li>The second is a <em>linear iterative process</em>. It is iterative because it does not grow and shrink.
<ul>
<li>It is summarized by a fixed number of state variables and a rule to describe how they should update and when the process should terminate.</li>
<li>It is a <em>linear</em> iterative process because the number of steps grows linearly with HELLO.</li>
</ul></li>
<li>In the iterative process, the variables provide a complete description of the state of the process at any point.</li>
<li>In the recursive process, their is “hidden” information that makes it impossible to resume the process midway through.</li>
<li>The longer the chain of deferred operations, the more information must be maintained (in a stack, as we will see).</li>
<li>A recursive <em>procedure</em> is simply a procedure that refers to itself directly or indirectly.</li>
<li>A recursive <em>process</em> refers to the evolution of the process described above.</li>
<li>A recursive procedure can generate an iterative process in Scheme thanks to tail-call optimization. In other languages, special-purpose looping constructs are needed for this.</li>
</ul>
<h2 id="1.2.2" class="anchor">
<a class="anchor__link link" href="#1.2.2" aria-hidden="true">#</a> <span class="number">1.2.2</span> <a class="link" href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.2">Tree Recursion<span class="nowrap">﻿<svg class="external" width="24" height="24" aria-hidden="true"><use xlink:href="#external"/></svg></span></a>
</h2>
<ul>
<li>With tree recursion, the procedure invokes itself more than once, causing the process to evolve in the shape of a tree.</li>
<li>The naive Fibonacci procedure calls itself twice each time it is invoked, so each branch splits into two at each level.</li>
</ul>
<blockquote>
<p>In general, the number of steps required by a tree-recursive process will be proportional to the number of nodes in the tree, while the space required will be proportional to the maximum depth of the tree. (49)</p>
</blockquote>
<ul>
<li>The iterative implementation of the Fibonacci procedure is vastly more efficient in space and in time.</li>
</ul>
<h3 id="1.2.2.1" class="anchor">
<a class="anchor__link link" href="#1.2.2.1" aria-hidden="true">#</a> Example: Counting change
</h3>
<p>Let HELLO represent the number of ways of changing the amount A using HELLO kinds of coins. If the first kind of coin has denomination HELLO, then HELLO. In words, there are two situations: where you do not use any of the first kind of coin, and when you do. The value of HELLO assumes we don’t use the first kind at all; the value of HELLO assumes we use one or more of the first kind.</p>
<p>That rule and a few degenerate cases is sufficient to describe an algorithm for counting the number of ways of changing amounts of money. We can define it with the following piecewise function:</p>
<p>HELLO</p>
<p>Like Fibonacci, the easy tree-recursive implementation involves a lot of redundancy. Unlike it, there is no obvious iterative solution (it is possible, just harder). One way to improve the performance of the tree-recursive process is to use <em>memoization</em> (maintaining a lookup table).</p>
<h2 id="1.2.3" class="anchor">
<a class="anchor__link link" href="#1.2.3" aria-hidden="true">#</a> <span class="number">1.2.3</span> <a class="link" href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.3">Orders of Growth<span class="nowrap">﻿<svg class="external" width="24" height="24" aria-hidden="true"><use xlink:href="#external"/></svg></span></a>
</h2>
<ul>
<li>Some processes consume more or less computational resources than others.</li>
<li>We compare this using <em>order of growth</em>, a gross measure of the resources required by a process as the inputs becomes larger.</li>
<li>Let HELLO be a parameter that measures the size of a problem—it could be the input itself, the tolerance, the number of rows in the matrix, etc. There are many properties that HELLO can measure.</li>
<li>Let HELLO be the amount of resources the process requires for a problem of size HELLO. This could be time, space (amount of memory), number of registers used, etc.</li>
<li>We say that HELLO has order of growth HELLO, or HELLO, if there are positive constants HELLO and HELLO independent of HELLO such that HELLO for any sufficiently large value of HELLO.</li>
<li>The value HELLO is sandwiched between HELLO and HELLO.</li>
<li>The linear recursive process for computing factorials had HELLO time and HELLO space (both linear), whereas the linear iterative process had HELLO space (constant).</li>
<li>The order of growth is a crude description of the behavior of a process.</li>
<li>Its importance is allowing us to see the <em>change</em> in the amount of resources required when you, say, increment HELLO or double HELLO.</li>
</ul>
<h2 id="1.2.4" class="anchor">
<a class="anchor__link link" href="#1.2.4" aria-hidden="true">#</a> <span class="number">1.2.4</span> <a class="link" href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.4">Exponentiation<span class="nowrap">﻿<svg class="external" width="24" height="24" aria-hidden="true"><use xlink:href="#external"/></svg></span></a>
</h2>
<p>One way to calculate b to the nth power is via the following recursive definition:</p>
<p>HELLO</p>
<p>In words, multiply the base to itself HELLO times. A faster method is to use successive squaring:</p>
<p>HELLO</p>
<h2 id="1.2.5" class="anchor">
<a class="anchor__link link" href="#1.2.5" aria-hidden="true">#</a> <span class="number">1.2.5</span> <a class="link" href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.5">Greatest Common Divisors<span class="nowrap">﻿<svg class="external" width="24" height="24" aria-hidden="true"><use xlink:href="#external"/></svg></span></a>
</h2>
<ul>
<li>The GCD of integers HELLO and HELLO is the largest integer that divides both HELLO and HELLO with no remainder. For example, HELLO.</li>
<li>An efficient algorithm uses HELLO.</li>
<li>For example, we can reduce <code>(<span class="fu">gcd</span> <span class="cn">206</span> <span class="cn">40</span>)</code> as follows:</li>
</ul>
<pre><code class="blockcode">(<span class="fu">gcd</span> <span class="cn">206</span> <span class="cn">40</span>)
(<span class="fu">gcd</span> <span class="cn">40</span> <span class="cn">6</span>)
(<span class="fu">gcd</span> <span class="cn">6</span> <span class="cn">4</span>)
(<span class="fu">gcd</span> <span class="cn">4</span> <span class="cn">2</span>)
(<span class="fu">gcd</span> <span class="cn">2</span> <span class="cn">0</span>)
<span class="cn">2</span></code></pre>
<ul>
<li>This always works: you always get a pair where the second number is zero, and the other number is the GCD of the original pair.</li>
<li>This is called <em>Euclid’s Algorithm</em>.</li>
<li>Lamé’s Theorem: If Euclid’s Algorithm requires HELLO steps to compute the GCD of some pair HELLO, then HELLO.</li>
</ul>
<h2 id="1.2.6" class="anchor">
<a class="anchor__link link" href="#1.2.6" aria-hidden="true">#</a> <span class="number">1.2.6</span> <a class="link" href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.6">Example: Testing for Primality<span class="nowrap">﻿<svg class="external" width="24" height="24" aria-hidden="true"><use xlink:href="#external"/></svg></span></a>
</h2>
<h3 id="1.2.6.1" class="anchor">
<a class="anchor__link link" href="#1.2.6.1" aria-hidden="true">#</a> Searching for divisors
</h3>
<ul>
<li>One way to test for primality is to find the number’s divisors.</li>
<li>A number is prime if and only if it is its own smallest divisor.</li>
</ul>
<h3 id="1.2.6.2" class="anchor">
<a class="anchor__link link" href="#1.2.6.2" aria-hidden="true">#</a> The Fermat test
</h3>
<p>The Fermat test is a HELLO primality test based on Fermat’s Little Theorem:</p>
<blockquote>
<p>If HELLO is a prime number and a is any positive integer less than HELLO, then a raised to the HELLOth power is congruent to a modulo HELLO.</p>
</blockquote>
<p>The test works like this:</p>
<ol type="1">
<li>Given a number HELLO, pick a random number HELLO and calculate HELLO.</li>
<li>Fail: If the result is not equal to HELLO, then HELLO is not prime.</li>
<li>Pass: If the result is equal to HELLO, then HELLO is likely prime.</li>
<li>Repeat. The more times the number passes the test, the more confident we are that HELLO is prime. If there is a single failure, HELLO is certainly not prime.</li>
</ol>
<h3 id="1.2.6.3" class="anchor">
<a class="anchor__link link" href="#1.2.6.3" aria-hidden="true">#</a> Probabilistic methods
</h3>
<ul>
<li>Most familiar algorithms compute an answer that is guaranteed to be correct. Not so with the Fermat test.</li>
<li>We can make the probability error in our primality test as small as we like simply by running more tests—except for Carmichael numbers.</li>
<li>If HELLO passes the test for one random value of a, the chances are more than 50% that HELLO is prime.</li>
<li>Probabilistic algorithms: algorithms for which one can prove that the chance of error becomes arbitrarily small.</li>
</ul>
<div id="q1" class="highlight">
<a class="highlight__link link" href="../highlight.html#1.2-q1" aria-label="view quote in highlights page"><svg class="circle-arrow" width="18" height="18" aria-hidden="true"><use xlink:href="#circle-left"/></svg> Highlights</a>
<blockquote>
<p>Numbers that fool the Fermat test are called Carmichael numbers, and little is known about them other than that they are extremely rare. […] In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a “correct” algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering. <span class="citation" data-cites="sicp">[@sicp 1.2.6]</span></p>
</blockquote>
</div>
<!-- https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#footnote_Temp_80 -->
</article>
</main>
<nav class="pagenav pagenav--bottom" aria-label="page">
  <div class="pagenav__item pagenav__item--left">
    <a class="pagenav__link link" href="1.html" aria-label="previous page">
      <svg width="12" height="11" aria-hidden="true"><use xlink:href="#left"/>
      </svg><span class="pagenav__prev">Prev</span>
    </a>
  </div>
  <div class="pagenav__item pagenav__item--center">
    <a class="pagenav__link link" href="index.html" aria-label="parent page">
      <svg width="11" height="12" aria-hidden="true"><use xlink:href="#up"/>
      </svg><span class="pagenav__up">Up</span>
    </a>
  </div>
  <div class="pagenav__item pagenav__item--right">
    <a class="pagenav__link link" href="3.html" aria-label="next page">
      <span class="pagenav__next">Next</span
        ><svg width="12" height="11" aria-hidden="true"
        ><use xlink:href="#right"/></svg>
    </a>
  </div>
</nav>
<footer class="footer">
  <p>© 2020 Mitchell Kember</p>
</footer>
</body>
</html>
