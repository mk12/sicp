<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Section 1.2 Notes</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link rel="stylesheet" href="../../assets/style.css">
</head>
<body>
<header class="header">
  <a class="title link" href="../../index.html">SICP Study</a>
  <span class="gap"></span>
  <nav class="sitenav">
    <a class="sitenav__item link  sitenav__item--active" href="../../text/index.html">Text</a>
    <a class="sitenav__item link " href="../../lecture/index.html">Lecture</a>
    <a class="sitenav__item link " href="../../exercise/index.html">Exercise</a>
    <a class="sitenav__item link" href="https://github.com/mk12/sicp">Source <svg class="github-mark" width="25" height="25" viewBox="0 0 136 133">
  <g transform="matrix(1,0,0,1,-568.001,-447.669)">
    <g transform="matrix(4.16667,0,0,4.16667,0,0)">
      <g transform="matrix(1,0,0,1,152.608,139.345)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.778 -11.354,-8.279 -11.354,-8.279C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.154 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.237C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.839 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.839 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904"/>
      </g>
    </g>
  </g>
</svg></a>
  </nav>
</header>
<nav class="pagenav pagenav--top">
  <div class="pagenav__item pagenav__item--prev"><a class="pagenav__link link" href="1.html">← Prev</a></div>
  <div class="pagenav__item pagenav__item--up"><a class="pagenav__link link" href="index.html">↑ Up</a></div>
  <div class="pagenav__item pagenav__item--next"><a class="pagenav__link link" href="3.html">Next →</a></div>
</nav>
<h1>
Procedures and the Processes They Generate<small class="number">1.2</small>
</h1>
<blockquote>
<p>To become experts, we must learn to visualize the processes generated by various types of procedures. Only after we have developed such a skill can we learn to reliably construct programs that exhibit the desired behavior. (40) FOO</p>
</blockquote>
<ul>
<li>A procedure is a pattern for the <em>local evolution</em> of a computation process: how one stage is built on the previous.</li>
<li>The global behavior of a computational process is much harder to reason about.</li>
<li>Processes governed by different types of procedures generate different “shapes” of evolution.</li>
<li>There are two important resources that computational processes consume: time and space.</li>
</ul>
<h2 id="1.2.1" class="anchor">
<a class="anchor__link link" href="#1.2.1">#</a>Linear Recursion and Iteration<small class="number">1.2.1</small>
</h3>
<ul>
<li>The factorial of <span class="math inline">N</span> is defined as the product of the integers on the interval <span class="math inline">[1,N]</span>.</li>
<li>The naive <em>recursive</em> implementation creates a curved shape:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(factorial <span class="dv">4</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (factorial <span class="dv">3</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (factorial <span class="dv">2</span>)))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (<span class="op">*</span> <span class="dv">2</span> (factorial <span class="dv">1</span>))))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (<span class="op">*</span> <span class="dv">2</span> <span class="dv">1</span>)))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> <span class="dv">2</span>))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> <span class="dv">4</span> <span class="dv">6</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span></span></code></pre></div>
<ul>
<li>The <em>iterative</em> implementation maintains a running product and multiplies the numbers from 1 to <span class="math inline">N</span> to it.</li>
<li>This creates a shape with a straight edge:</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(factorial <span class="dv">4</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">1</span> <span class="dv">1</span> <span class="dv">4</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">6</span> <span class="dv">4</span> <span class="dv">4</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>(fact-iter <span class="dv">24</span> <span class="dv">5</span> <span class="dv">4</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span></span></code></pre></div>
<ul>
<li>Both compute the same mathematical function, but the computational processes evolve very differently.</li>
<li>The first one is a <em>linear recursive process</em>. The chain of deferred operations causes an expansion (as more operations are added) and a contraction (as the operations are performed).
<ul>
<li>The interpreter must keep track of all these operations.</li>
<li>It is a <em>linear</em> recursive process because the information it must keep track of (the call stack) grows linearly with <span class="math inline">N</span>.</li>
</ul></li>
<li>The second is a <em>linear iterative process</em>. It is iterative because it does not grow and shrink.
<ul>
<li>It is summarized by a fixed number of state variables and a rule to describe how they should update and when the process should terminate.</li>
<li>It is a <em>linear</em> iterative process because the number of steps grows linearly with <span class="math inline">N</span>.</li>
</ul></li>
<li>In the iterative process, the variables provide a complete description of the state of the process at any point.</li>
<li>In the recursive process, their is “hidden” information that makes it impossible to resume the process midway through.</li>
<li>The longer the chain of deferred operations, the more information must be maintained (in a stack, as we will see).</li>
<li>A recursive <em>procedure</em> is simply a procedure that refers to itself directly or indirectly.</li>
<li>A recursive <em>process</em> refers to the evolution of the process described above.</li>
<li>A recursive procedure can generate an iterative process in Scheme thanks to tail-call optimization. In other languages, special-purpose looping constructs are needed for this.</li>
</ul>
<h2 id="1.2.2" class="anchor">
<a class="anchor__link link" href="#1.2.2">#</a>Tree Recursion<small class="number">1.2.2</small>
</h3>
<ul>
<li>With tree recursion, the procedure invokes itself more than once, causing the process to evolve in the shape of a tree.</li>
<li>The naive Fibonacci procedure calls itself twice each time it is invoked, so each branch splits into two at each level.</li>
</ul>
<blockquote>
<p>In general, the number of steps required by a tree-recursive process will be proportional to the number of nodes in the tree, while the space required will be proportional to the maximum depth of the tree. (49) FOO</p>
</blockquote>
<ul>
<li>The iterative implementation of the Fibonacci procedure is vastly more efficient in space and in time.</li>
</ul>
<h3 id="1.2.2.1" class="anchor">
<a class="anchor__link link" href="#1.2.2.1">#</a>Example: Counting change
</h3>
<p>Let <span class="math inline">f(A,N)</span> represent the number of ways of changing the amount A using <span class="math inline">N</span> kinds of coins. If the first kind of coin has denomination <span class="math inline">N</span>, then <span class="math inline">f(A,N) = f(A,N-1) + f(A-D,N)</span>. In words, there are two situations: where you do not use any of the first kind of coin, and when you do. The value of <span class="math inline">f(A,N-1)</span> assumes we don’t use the first kind at all; the value of <span class="math inline">f(A-D,N)</span> assumes we use one or more of the first kind.</p>
<p>That rule and a few degenerate cases is sufficient to describe an algorithm for counting the number of ways of changing amounts of money. We can define it with the following piecewise function:</p>
<p><span class="math display">
f(A,N) = \begin{cases}
1, &amp; \text{if $A = 0$,} \\
0, &amp; \text{if $A &lt; 0$ or $N = 0$,} \\
f(A,N-1) + f(A-D,N), &amp; \text{if $A &gt; 0$ and $N &gt; 0$.}
\end{cases}
</span></p>
<p>Like Fibonacci, the easy tree-recursive implementation involves a lot of redundancy. Unlike it, there is no obvious iterative solution (it is possible, just harder). One way to improve the performance of the tree-recursive process is to use <em>memoization</em> (maintaining a lookup table).</p>
<h2 id="1.2.3" class="anchor">
<a class="anchor__link link" href="#1.2.3">#</a>Orders of Growth<small class="number">1.2.3</small>
</h3>
<ul>
<li>Some processes consume more or less computational resources than others.</li>
<li>We compare this using <em>order of growth</em>, a gross measure of the resources required by a process as the inputs becomes larger.</li>
<li>Let <span class="math inline">n</span> be a parameter that measures the size of a problem – it could be the input itself, the tolerance, the number of rows in the matrix, etc. There are many properties that <span class="math inline">n</span> can measure.</li>
<li>Let <span class="math inline">R(n)</span> be the amount of resources the process requires for a problem of size <span class="math inline">n</span>. This could be time, space (amount of memory), number of registers used, etc.</li>
<li>We say that <span class="math inline">R(n)</span> has order of growth <span class="math inline">Θ(f(n))</span>, or <span class="math inline">R(n) = Θ(f(n))</span>, if there are positive constants <span class="math inline">A</span> and <span class="math inline">B</span> independent of <span class="math inline">n</span> such that <span class="math inline">Af(n) ≤ R(n) ≤ Bf(n)</span> for any sufficiently large value of <span class="math inline">n</span>.</li>
<li>The value <span class="math inline">R(n)</span> is sandwiched between <span class="math inline">Af(n)</span> and <span class="math inline">Bf(n)</span>.</li>
<li>The linear recursive process for computing factorials had <span class="math inline">Θ(n)</span> time and <span class="math inline">Θ(n)</span> space (both linear), whereas the linear iterative process had <span class="math inline">Θ(1)</span> space (constant).</li>
<li>The order of growth is a crude description of the behavior of a process.</li>
<li>Its importance is allowing us to see the <em>change</em> in the amount of resources required when you, say, increment <span class="math inline">n</span> or double <span class="math inline">n</span>.</li>
</ul>
<h2 id="1.2.4" class="anchor">
<a class="anchor__link link" href="#1.2.4">#</a>Exponentiation<small class="number">1.2.4</small>
</h3>
<p>One way to calculate b to the nth power is via the following recursive definition:</p>
<p><span class="math display">b^0 = 1, \qquad b^n = b * b^{n-1}.</span></p>
<p>In words, multiply the base to itself <span class="math inline">n</span> times. A faster method is to use successive squaring:</p>
<p><span class="math display">
b^n = \begin{cases}
\left(b^{n/2}\right)^2 &amp; \text{if $n$ is even,} \\
b * b^{n-1}, &amp; \text{if $n$ is odd.}
\end{cases}
</span></p>
<h2 id="1.2.5" class="anchor">
<a class="anchor__link link" href="#1.2.5">#</a>Greatest Common Divisors<small class="number">1.2.5</small>
</h3>
<ul>
<li>The GCD of integers <span class="math inline">a</span> and <span class="math inline">b</span> is the largest integer that divides both <span class="math inline">a</span> and <span class="math inline">b</span> with no remainder. For example, <span class="math inline">\gcd(16,28) = 4</span>.</li>
<li>Efficient algorithm uses <span class="math inline">\gcd(a,b) = \gcd(b,a\bmod b)</span>.</li>
<li>For example, we can reduce <code class="sourceCode scheme">(<span class="kw">gcd</span> <span class="dv">206</span> <span class="dv">40</span>)</code> as follows:</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">206</span> <span class="dv">40</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">40</span> <span class="dv">6</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">6</span> <span class="dv">4</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">4</span> <span class="dv">2</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">gcd</span> <span class="dv">2</span> <span class="dv">0</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span></code></pre></div>
<ul>
<li>This always works: you always get a pair where the second number is zero, and the other number is the GCD of the original pair.</li>
<li>This is called <em>Euclid’s Algorithm</em>.</li>
<li>Lamé’s Theorem: If Euclid’s Algorithm requires <span class="math inline">k</span> steps to compute the GCD of some pair <span class="math inline">(a,b)</span>, then <span class="math inline">\min\{a,b\} ≥ \text{Fib}(k)</span>.</li>
</ul>
<h2 id="1.2.6" class="anchor">
<a class="anchor__link link" href="#1.2.6">#</a>Example: Testing for Primality<small class="number">1.2.6</small>
</h3>
<h3 id="1.2.6.1" class="anchor">
<a class="anchor__link link" href="#1.2.6.1">#</a>Searching for divisors
</h3>
<ul>
<li>One way to test for primality is to find the number’s divisors.</li>
<li>A number is prime if and only if it is its own smallest divisor.</li>
</ul>
<h3 id="1.2.6.2" class="anchor">
<a class="anchor__link link" href="#1.2.6.2">#</a>The Fermat test
</h3>
<p>The Fermat test is a <span class="math inline">Θ(log(n))</span> primality test based on Fermat’s Little Theorem:</p>
<blockquote>
<p>If <span class="math inline">n</span> is a prime number and a is any positive integer less than <span class="math inline">n</span>, then a raised to the <span class="math inline">n</span>th power is congruent to a modulo <span class="math inline">n</span>.</p>
</blockquote>
<p>The test works like this:</p>
<ol type="1">
<li>Given a number <span class="math inline">n</span>, pick a random number <span class="math inline">a &lt; n</span> and calculate <span class="math inline">a^n\bmod n</span>.</li>
<li>Fail: If the result is not equal to <span class="math inline">a</span>, then <span class="math inline">n</span> is not prime.</li>
<li>Pass: If the result is equal to <span class="math inline">a</span>, then <span class="math inline">n</span> is likely prime.</li>
<li>Repeat. The more times the number passes the test, the more confident we are that <span class="math inline">n</span> is prime. If there is a single failure, <span class="math inline">n</span> is certainly not prime.</li>
</ol>
<h3 id="1.2.6.3" class="anchor">
<a class="anchor__link link" href="#1.2.6.3">#</a>Probabilistic methods
</h3>
<ul>
<li>Most familiar algorithms compute an answer that is guaranteed to be correct. Not so with the Fermat test.</li>
<li>We can make the probability error in our primality test as small as we like simply by running more tests – except for Carmichael numbers.</li>
<li>If <span class="math inline">n</span> passes the test for one random value of a, the chances are more than 50% that <span class="math inline">n</span> is prime.</li>
<li>Probabilistic algorithms: algorithms for which one can prove that the chance of error becomes arbitrarily small.</li>
</ul>
<blockquote>
<p>Numbers that fool the Fermat test are called Carmichael numbers, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a “correct” algorithm. Considering an algorithm to be inadequate for the first reason but not for the second <em>illustrates the difference between mathematics and engineering</em>. (69) FOO</p>
</blockquote>
<nav class="pagenav pagenav--bottom">
  <div class="pagenav__item pagenav__item--prev"><a class="pagenav__link link" href="1.html">← Prev</a></div>
  <div class="pagenav__item pagenav__item--up"><a class="pagenav__link link" href="index.html">↑ Up</a></div>
  <div class="pagenav__item pagenav__item--next"><a class="pagenav__link link" href="3.html">Next →</a></div>
</nav>
<footer class="footer">© 2020 Mitchell Kember</footer>
</body>
</html>
