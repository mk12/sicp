<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Lecture 6A Notes</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
<div hidden>
  <svg>
    <symbol id="up" viewBox="0 0 11 12">
      <path fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" d="M5.257.8v10.4m4.457-5.943L5.257.8.8 5.257"/>
    </symbol>
    <symbol id="left" viewBox="0 0 12 11">
      <path fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" d="M.8 5.257h10.4M5.257 9.714L.8 5.257 5.257.8"/>
    </symbol>
    <symbol id="right" viewBox="0 0 12 11">
      <use xlink:href="#left" transform="matrix(-1 0 0 1 12 0)"/>
    </symbol>    <symbol id="external" viewBox="0 0 24 24">
               <path fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" d="M10.688 5.438H4.125A2.65 2.65 0 001.5 8.063v11.812A2.65 2.65 0 004.125 22.5h11.813a2.65 2.65 0 002.624-2.625v-6.563m-9.187 1.313L22.5 1.5m-6.563 0H22.5v6.563"/>
             </symbol>  </svg>
</div>
<a class="skip-link" href="#main">Skip to main content</a>
<header class="header ">
  <a class="title link" href="../index.html">SICP Study</a>
  <nav class="sitenav" aria-label="primary">
    <a class="sitenav__item link "
      href="../text/index.html" aria-label="textbook notes">Text</a>
    <a class="sitenav__item link  sitenav__item--active"
      href="../lecture/index.html" aria-label="lecture notes">Lecture</a>
    <a class="sitenav__item link "
      href="../exercise/index.html" aria-label="exercises">Exercise</a>
    <a class="sitenav__item sitenav__item--last link"
      href="https://github.com/mk12/sicp" aria-label="GitHub repository">Source
      <svg alt="" class="github-mark" width="25" height="25" viewBox="0 0 136 133">
        <path fill="currentColor" d="M67.866.002C30.387.002 0 30.39 0 67.877c0 29.988 19.446 55.425 46.417 64.404 3.396.621 4.633-1.475 4.633-3.275 0-1.608-.058-5.879-.091-11.541-18.88 4.1-22.863-9.1-22.863-9.1-3.087-7.838-7.537-9.925-7.537-9.925-6.163-4.213.466-4.13.466-4.13 6.813.484 10.396 6.996 10.396 6.996 6.054 10.371 15.888 7.375 19.754 5.642.617-4.387 2.367-7.38 4.309-9.075-15.071-1.712-30.917-7.537-30.917-33.546 0-7.408 2.646-13.466 6.988-18.212-.7-1.717-3.03-8.617.662-17.963 0 0 5.7-1.825 18.667 6.959 5.412-1.505 11.22-2.259 16.992-2.284 5.762.025 11.57.78 16.991 2.284 12.959-8.784 18.646-6.959 18.646-6.959 3.704 9.346 1.375 16.246.675 17.963 4.35 4.746 6.98 10.804 6.98 18.212 0 26.075-15.872 31.813-30.992 33.492 2.437 2.096 4.608 6.237 4.608 12.57 0 9.072-.083 16.392-.083 18.617 0 1.817 1.22 3.93 4.666 3.267 26.95-8.996 46.38-34.417 46.38-64.396 0-37.487-30.392-67.875-67.88-67.875"/>
      </svg>    </a>
  </nav>
</header>
<nav class="pagenav pagenav--top" aria-label="secondary">
  <div class="pagenav__item pagenav__item--prev">
    <a class="pagenav__link link" href="5b.html" aria-label="Previous page">
      <svg alt="" width="12" height="11"><use xlink:href="#left"/></svg> Prev
    </a>
  </div>
  <div class="pagenav__item pagenav__item--up">
    <a class="pagenav__link link" href="index.html" aria-label="Parent page">
      <svg alt="" width="11" height="12"><use xlink:href="#up"/></svg> Up
    </a>
  </div>
  <div class="pagenav__item pagenav__item--next">
    <a class="pagenav__link link" href="6b.html" aria-label="Next page">
      Next <svg alt="" width="12" height="11"><use xlink:href="#right"/></svg>
    </a>
  </div>
</nav>
<main id="main">
<h1>
<span class="number">6A</span> <a class="link" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/6a-streams-part-1">Streams, Part 1<span class="nowrap">﻿<svg alt="" class="external" width="24" height="24"><use xlink:href="#external"/></svg></span></a>
</h1>
<h2 id="1" class="anchor">
<a class="anchor__link link" href="#1" aria-hidden="true">#</a>Part 1
</h2>
<h3 id="1.1" class="anchor">
<a class="anchor__link link" href="#1.1" aria-hidden="true">#</a>Recap
</h3>
<ul>
<li>We’ve learned about assignment and its frightening implications.</li>
<li>The substitution model of evaluation breaks down; we have to use the much more complicated environment model.</li>
<li>Worry about: assignment, state, change, time, identity, objects, sharing.</li>
<li>Suddenly a variable doesn’t just stand for a value; it specifies a place that holds a value.</li>
<li>Our goal was <em>modularity</em>, writing programs that mirror reality.</li>
<li>Maybe we have the wrong view of reality; maybe time is an illusion and nothing changes.</li>
</ul>
<h3 id="1.2" class="anchor">
<a class="anchor__link link" href="#1.2" aria-hidden="true">#</a>Motivation
</h3>
<ul>
<li>We’re going to look at another way to decompose systems: <em>stream processing</em>.</li>
<li>Consider summing the odd squares in a binary tree of integers:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (sum-odd-squares tree)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (leaf-node? tree)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">if</span> (<span class="fu">odd?</span> tree)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          (square tree)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          <span class="cn">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">+</span> (sum-odd-squares (left-branch tree))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>         (sum-odd-squares (right-branch tree)))))</span></code></pre></div>
<ul>
<li>And contrast with collecting the odd Fibonacci numbers:</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (odd-fibs n)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">define</span> (next k)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="fu">&gt;</span> k n)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        &#39;()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">let</span> ((f (fib k)))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">if</span> (<span class="fu">odd?</span> f)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>              (<span class="fu">cons</span> f (next (<span class="fu">1+</span> k)))</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>              (next (<span class="fu">1+</span> k))))))</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  (next <span class="cn">1</span>))</span></code></pre></div>
<ul>
<li>1st procedure: enumerate leaves → filter <code class="sourceCode scheme"><span class="fu">odd?</span></code> → map <code class="sourceCode scheme">square</code> → accumulate <code class="sourceCode scheme"><span class="fu">+</span></code>, 0.</li>
<li>2nd procedure: enumerate interval → map <code class="sourceCode scheme">fib</code> → filter <code class="sourceCode scheme"><span class="fu">odd?</span></code> → accumulate <code class="sourceCode scheme"><span class="fu">cons</span></code>, <code class="sourceCode scheme">&#39;()</code>.</li>
<li>These are similar, but the commonality is obscured by how we wrote the procedures.</li>
</ul>
<blockquote>
<p>Going back to this fundamental principle of computer science that in order to control something you need the name of it.</p>
</blockquote>
<h3 id="1.3" class="anchor">
<a class="anchor__link link" href="#1.3" aria-hidden="true">#</a>Defining streams
</h3>
<ul>
<li>The arrows between the boxes represent data structures called <em>streams</em>.</li>
<li><code class="sourceCode scheme">(<span class="kw">cons-stream</span> x y)</code> and <code class="sourceCode scheme">the-empty-stream</code> construct streams.</li>
<li>For any <code class="sourceCode scheme">x</code> and <code class="sourceCode scheme">y</code>, <code class="sourceCode scheme">(head (<span class="kw">cons-stream</span> x y))</code> is <code class="sourceCode scheme">x</code>.</li>
<li>For any <code class="sourceCode scheme">x</code> and <code class="sourceCode scheme">y</code>, <code class="sourceCode scheme">(tail (<span class="kw">cons-stream</span> x y))</code> is <code class="sourceCode scheme">y</code>.</li>
<li>We can define higher-order procedures like we did for lists:</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (map-stream proc s)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (empty-stream? s)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>      the-empty-stream</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">cons-stream</span> (proc (head s))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                   (map-stream proc (tail se)))))</span></code></pre></div>
<h3 id="1.4" class="anchor">
<a class="anchor__link link" href="#1.4" aria-hidden="true">#</a>Using the language
</h3>
<ul>
<li>Now we can reimplement those problems with explicit stream processing:</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (sum-odd-squares tree)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (accumulate <span class="fu">+</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>              <span class="cn">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>              (<span class="fu">map</span> square</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                   (<span class="fu">filter</span> odd</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                           (enumerate-tree tree)))))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (odd-fibs n)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  (accumulate <span class="fu">cons</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>              &#39;()</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>              (<span class="fu">filter</span> odd</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                      (<span class="fu">map</span> fib</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                           (enumerate-interval <span class="cn">1</span> n)))))</span></code></pre></div>
<ul>
<li>This reveals their commonality, and makes it easy to mix and match boxes.</li>
<li>The advantage of stream processing is that it establishes <em>conventional interfaces</em>.</li>
<li>Conventional interfaces are powerful because we can easily glue things together.</li>
</ul>
<h2 id="2" class="anchor">
<a class="anchor__link link" href="#2" aria-hidden="true">#</a>Part 2
</h2>
<h3 id="2.1" class="anchor">
<a class="anchor__link link" href="#2.1" aria-hidden="true">#</a>More complicated stream processing
</h3>
<ul>
<li>Suppose we have a stream of streams <span class="math inline">\{\{1,2,3,\dots\},\{10,20,30,\dots\},\dots\}</span>.</li>
<li>We can define a procedure <code class="sourceCode scheme">flatten</code> to accumulate them into a single flat stream.</li>
<li>Problem: Given <span class="math inline">N</span>, find all pairs <span class="math inline">0&lt;j&lt;i≤N</span> such that <span class="math inline">i+j</span> is prime.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (prime-sum-pairs n)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  (<span class="fu">map</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">lambda</span> (p)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>     (<span class="fu">list</span> (<span class="fu">car</span> p) (<span class="fu">cadr</span> p) (<span class="fu">+</span> (<span class="fu">car</span> p) (<span class="fu">cadr</span> p))))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>   (<span class="fu">filter</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (p)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>      (prime (<span class="fu">+</span> (<span class="fu">car</span> p) (<span class="fu">cadr</span> p))))</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    (flatmap</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">lambda</span> (i)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>       (<span class="fu">map</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">lambda</span> (j) (<span class="fu">list</span> i j))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        (enumerate-interval <span class="cn">1</span> (<span class="fu">-1+</span> i))))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>     (enumerate-interval <span class="cn">1</span> n)))))</span></code></pre></div>
<ul>
<li><code class="sourceCode scheme">flatmap</code> takes the place of nested loops in most other languages.</li>
<li>We can simplify it with syntactic sugar <code class="sourceCode scheme">collect</code>:</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (prime-sum-pairs n)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (collect</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>   (<span class="fu">list</span> i j (<span class="fu">+</span> i j))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>   ((i (enumerate-interval <span class="cn">1</span> n))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    (j (enumerate-interval <span class="cn">1</span> (<span class="fu">-1+</span> i))))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>   (prime? (<span class="fu">+</span> i j))))</span></code></pre></div>
<h3 id="2.2" class="anchor">
<a class="anchor__link link" href="#2.2" aria-hidden="true">#</a>Eight queens puzzle
</h3>
<ul>
<li>Solving this typically uses a <em>backtracking search</em>, navigating up and down the tree of possibilities until we get to the bottom (all queens placed).</li>
<li>This is unnecessary—it’s inordinately concerned with <em>time</em>.</li>
<li>A simpler way is to employ <em>wishful thinking</em> and go from <span class="math inline">k</span> columns to <span class="math inline">k+1</span> columns.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (queens size)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">define</span> (fill-cols k)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">if</span> (<span class="fu">=</span> k <span class="cn">0</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        (singleton empty-board)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        (collect (adjoin-position try-row k rest-queens)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                 ((rest-queens (fill-cols (<span class="fu">-1+</span> k)))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                  (try-row (enumerate-interval <span class="cn">1</span> size)))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                 (safe? try-row k rest-queens))))</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  (fill-cols size))</span></code></pre></div>
<ul>
<li>This gives us <em>all solutions</em> to the <span class="math inline">k</span>-queens puzzle.</li>
<li>We changed our view from things that evolve in time and have state to a global view where we’re not concerned with time.</li>
</ul>
<h2 id="3" class="anchor">
<a class="anchor__link link" href="#3" aria-hidden="true">#</a>Part 3
</h2>
<h3 id="3.1" class="anchor">
<a class="anchor__link link" href="#3.1" aria-hidden="true">#</a>Streams are not lists
</h3>
<ul>
<li>By now you should be suspicious—what’s the catch?</li>
<li>Problem: Find the second prime between 10,000 and 1,000,000.</li>
<li>Stream solution: enumerate 10,000 to 1,000,000 → filter <code class="sourceCode scheme">prime?</code> → take 2nd.</li>
<li>This is ridiculously inefficient. Our earlier programs (before streams) were ugly because they mixed all the operations up, but because of this they were efficient.</li>
<li>But we can have our cake and eat it to! We can make it just as efficient.</li>
<li>The key to this is that streams are <em>not</em> lists.</li>
</ul>
<h3 id="3.2" class="anchor">
<a class="anchor__link link" href="#3.2" aria-hidden="true">#</a>Implementing streams
</h3>
<ul>
<li>We want the stream to compute itself incrementally, to be an “on demand” data structure.
<ul>
<li><code class="sourceCode scheme">(<span class="kw">cons-stream</span> x y)</code> is an abbreviation for <code class="sourceCode scheme">(<span class="fu">cons</span> x (<span class="kw">delay</span> y))</code></li>
<li><code class="sourceCode scheme">(head s)</code> is <code class="sourceCode scheme">(<span class="fu">car</span> s)</code></li>
<li><code class="sourceCode scheme">(tail s)</code> is <code class="sourceCode scheme">(<span class="fu">force</span> (<span class="fu">cdr</span> s))</code></li>
</ul></li>
<li><code class="sourceCode scheme"><span class="kw">delay</span></code> creates a promise to compute something when <code class="sourceCode scheme"><span class="fu">force</span></code> d.
<ul>
<li><code class="sourceCode scheme">(<span class="kw">delay</span> &lt;expr&gt;)</code> is an abbreviation for <code class="sourceCode scheme">(<span class="kw">lambda</span> () &lt;expr&gt;)</code></li>
<li><code class="sourceCode scheme">(<span class="fu">force</span> p)</code> is <code class="sourceCode scheme">(p)</code></li>
</ul></li>
<li><code class="sourceCode scheme"><span class="kw">delay</span></code> decouples the apparent order of events from the actual order of events that happen in the machine. We give up the idea that our procedures mirror some clear notion of time.</li>
<li>One little hack: to be efficient, <code class="sourceCode scheme">(<span class="kw">delay</span> &lt;expr&gt;)</code> is <code class="sourceCode scheme">(memo-proc (<span class="kw">lambda</span> () &lt;expr&gt;))</code>.</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (memo-proc proc)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((already-run? nil) (result nil))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> ()</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">if</span> (<span class="fu">not</span> already-run?)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>          (sequence (<span class="kw">set!</span> result (proc))</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                    (<span class="kw">set!</span> already-run? (<span class="fu">not</span> nil))</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                    result)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>          result))))</span></code></pre></div>
<ul>
<li>Streams blur the line between data structures and procedures.</li>
</ul>
</main>
<nav class="pagenav pagenav--bottom" aria-label="secondary">
  <div class="pagenav__item pagenav__item--prev">
    <a class="pagenav__link link" href="5b.html" aria-label="Previous page">
      <svg alt="" width="12" height="11"><use xlink:href="#left"/></svg> Prev
    </a>
  </div>
  <div class="pagenav__item pagenav__item--up">
    <a class="pagenav__link link" href="index.html" aria-label="Parent page">
      <svg alt="" width="11" height="12"><use xlink:href="#up"/></svg> Up
    </a>
  </div>
  <div class="pagenav__item pagenav__item--next">
    <a class="pagenav__link link" href="6b.html" aria-label="Next page">
      Next <svg alt="" width="12" height="11"><use xlink:href="#right"/></svg>
    </a>
  </div>
</nav>
<footer class="footer">
  <p>© 2020 Mitchell Kember</p>
</footer>
</body>
</html>
