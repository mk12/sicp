<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Lecture 3A Notes</title>
  <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
<header class="header">
  <a class="title link" href="../index.html">SICP Study</a>
  <span class="gap"></span>
  <nav class="sitenav">
    <a class="sitenav__item link " href="../text/index.html">Text</a>
    <a class="sitenav__item link  sitenav__item--active" href="../lecture/index.html">Lecture</a>
    <a class="sitenav__item link " href="../exercise/index.html">Exercise</a>
    <a class="sitenav__item link" href="https://github.com/mk12/sicp">Source <svg class="github-mark" width="25" height="25" viewBox="0 0 136 133">
  <g transform="matrix(1,0,0,1,-568.001,-447.669)">
    <g transform="matrix(4.16667,0,0,4.16667,0,0)">
      <g transform="matrix(1,0,0,1,152.608,139.345)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.778 -11.354,-8.279 -11.354,-8.279C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.154 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.237C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.839 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.839 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904"/>
      </g>
    </g>
  </g>
</svg></a>
  </nav>
</header>
<nav class="pagenav pagenav--top">
  <div class="pagenav__item pagenav__item--prev"><a class="pagenav__link link" href="2b.html">← Prev</a></div>
  <div class="pagenav__item pagenav__item--up"><a class="pagenav__link link" href="index.html">↑ Up</a></div>
  <div class="pagenav__item pagenav__item--next"><a class="pagenav__link link" href="3b.html">Next →</a></div>
</nav>
<h1>
Henderson Escher Example<small class="number">3A</small>
</h1>
<h2 id="1" class="anchor">
<a class="anchor__link link" href="#1">#</a>Part 1
</h2>
<h3 id="1.1" class="anchor">
<a class="anchor__link link" href="#1.1">#</a>Recap
</h3>
<ul>
<li>Now we know about procedural abstract and data abstraction.</li>
<li>We can isolate the way data objects are <em>used</em> from the way that they are <em>represented</em>.</li>
<li>We learned how to make pairs with <code>cons</code>, <code>car</code>, and <code>cdr</code>.</li>
<li>We looked at examples: interval arithmetic and vectors.</li>
<li>We can glue together arbitrary things with <code>cons</code>, not just numbers.</li>
<li>We learned about closure: the things that we combine can themselves be combined. This allows us to build complexity.</li>
</ul>
<h3 id="1.2" class="anchor">
<a class="anchor__link link" href="#1.2">#</a>Lists
</h3>
<ul>
<li>Their are a lot of different ways of building list structure.</li>
<li>Lisp has a particular convention for representing a sequence as chained pairs: a list.</li>
<li>The car of the pair is the first item. The <code>cdr</code> of the pair is the rest of the sequence.</li>
<li>The <code>cdr</code> of the last pair has a special marker. This is the empty list, also called nil or null. It is printed as <code>()</code>.</li>
<li>The predicate <code>null?</code> checks if a list is empty (is nil).</li>
<li>Lisp has a procedure called <code>list</code>, which is just an abbreviation for the nested conses.</li>
</ul>
<h3 id="1.3" class="anchor">
<a class="anchor__link link" href="#1.3">#</a>Mapping lists
</h3>
<ul>
<li>It is common to write a procedure that does the same thing to each item in a list and returns a new list.</li>
<li>The recursive strategy is to apply the operation to the car of the list, and then cons that onto the rest of the list which has already been mapped (wishful thinking).</li>
<li>Rather than doing the recursive strategy manually each time, we use the higher-order procedure <code>map</code>.</li>
<li>Thinking in terms of operations on aggregates is a powerful idea. We don’t worry about recursion or other details.</li>
<li><code>for-each</code> is like map, but it doesn’t build up a new list. It is just for side-effects.</li>
</ul>
<h2 id="2" class="anchor">
<a class="anchor__link link" href="#2">#</a>Part 2
</h2>
<h3 id="2.1" class="anchor">
<a class="anchor__link link" href="#2.1">#</a>Henderson Escher example
</h3>
<ul>
<li>A language for describing self-similar, fractal-like figures.</li>
<li>This example will blur the line between procedures and data.</li>
<li>There is only one primitive: a painter. A painter draws its image within a frame (a parallelogram).</li>
<li>We have means of combination: <code>rotate</code>, <code>beside</code>, and <code>below</code>.</li>
<li>Thanks to the closure property, we are able to build up complexity in this language quickly.</li>
<li>A frame is defined by an origin vector and two side vectors.</li>
<li>All frames are based on transformations from the unit square.</li>
<li>We can build primitive painters from lists of line segments.</li>
<li>A painter is a procedure that takes a frame and draws its image within the frame.</li>
</ul>
<h2 id="3" class="anchor">
<a class="anchor__link link" href="#3">#</a>Part 3
</h2>
<h3 id="3.1" class="anchor">
<a class="anchor__link link" href="#3.1">#</a>Importance of closure
</h3>
<ul>
<li>This representation is nice because, once primitives are implemented in this way, the means of combination just fall out because you automatically get the closure property.</li>
<li>The procedures <code>beside</code> and <code>below</code> are trivial to write.</li>
<li>The operation <code>rotate</code> is similarly simple.</li>
<li>The real punchline comes when you look at the means of abstraction. Since painters are just procedures, everything that Lisp supplies for procedures is automatically available to us in this painting language.</li>
<li>We can write recursive painters without ever having purposely built recursion into the painting language.</li>
<li>We can even write higher-order painters.</li>
</ul>
<h3 id="3.2" class="anchor">
<a class="anchor__link link" href="#3.2">#</a>The power of Lisp
</h3>
<ul>
<li>The difference between merely implementing something in a language and embedding something in the language: you don’t lost the original power of the language.</li>
<li>Lisp is a lousy language for any particular problem. But it’s good for figuring out the right language and embedding that in Lisp. That’s the real power of this approach to design.</li>
<li>There is no difference between procedures and data.</li>
</ul>
<h3 id="3.3" class="anchor">
<a class="anchor__link link" href="#3.3">#</a>Software engineering
</h3>
<ul>
<li>We have been creating a sequence of layers of language.</li>
<li>The methodology (or mythology) of software engineering is this: figure out your task, break it into three sub-tasks, and repeat for each sub-task. Work your way up to the top and you’ll end up with this beautiful edifice.</li>
<li>Each of these nodes in the tree is supposed to fit perfectly into the whole thing.</li>
<li>The Henderson example didn’t work like that.</li>
<li>Instead, we had a sequence of layers of language. Each layer depends on the layers beneath it, but it can’t see their details because there is an abstraction barrier in the way.</li>
</ul>
<blockquote>
<p>So what you have is, at each level, the objects that are being talked about are the things that were erected at the previous level.</p>
</blockquote>
<ul>
<li>With the top-down tree, each part does a specific task.</li>
<li>In the Henderson example, we had a full range of linguistic power at each level. Each level does a whole range of things, not a single task.</li>
<li>This makes the system more robust, meaning that changes are easy to make and the system can adapt to them.</li>
<li>A small change in the top-down tree might cause the whole thing to fall down unless you reconstruct it.</li>
<li>We are talking about levels of language rather than a strict hierarchy. Each level has its own vocabulary.</li>
<li>The design process is not so much implementing programs as implementing languages. That’s the powerful idea of Lisp.</li>
</ul>
<nav class="pagenav pagenav--bottom">
  <div class="pagenav__item pagenav__item--prev"><a class="pagenav__link link" href="2b.html">← Prev</a></div>
  <div class="pagenav__item pagenav__item--up"><a class="pagenav__link link" href="index.html">↑ Up</a></div>
  <div class="pagenav__item pagenav__item--next"><a class="pagenav__link link" href="3b.html">Next →</a></div>
</nav>
<footer class="footer">© 2020 Mitchell Kember</footer>
</body>
</html>
