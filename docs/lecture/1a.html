<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Lecture 1A Notes</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
<svg style="display: none;">
  <symbol id="external">
    <path d="M11 7H6a2 2 0 00-2 2v9a2 2 0 002 2h9a2 2 0 002-2v-5M10 14L20 4M15 4h5v5"/>
  </symbol></svg>
<a class="skip-link" href="#main">Skip to main content</a>
<header class="header ">
  <a class="title link" href="../index.html">SICP Study</a>
  <nav class="sitenav" aria-label="primary">
    <a class="sitenav__item link "
      href="../text/index.html" aria-label="textbook notes">Text</a>
    <a class="sitenav__item link  sitenav__item--active"
      href="../lecture/index.html" aria-label="lecture notes">Lecture</a>
    <a class="sitenav__item link "
      href="../exercise/index.html" aria-label="exercises">Exercise</a>
    <a class="sitenav__item sitenav__item--last link"
      href="https://github.com/mk12/sicp" aria-label="GitHub repository">Source
      <svg alt="" class="github-mark" width="25" height="25" viewBox="0 0 136 133">
        <path d="M67.866.002C30.387.002 0 30.39 0 67.877c0 29.988 19.446 55.425 46.417 64.404 3.396.621 4.633-1.475 4.633-3.275 0-1.608-.058-5.879-.091-11.541-18.88 4.1-22.863-9.1-22.863-9.1-3.087-7.838-7.537-9.925-7.537-9.925-6.163-4.213.466-4.13.466-4.13 6.813.484 10.396 6.996 10.396 6.996 6.054 10.371 15.888 7.375 19.754 5.642.617-4.387 2.367-7.38 4.309-9.075-15.071-1.712-30.917-7.537-30.917-33.546 0-7.408 2.646-13.466 6.988-18.212-.7-1.717-3.03-8.617.662-17.963 0 0 5.7-1.825 18.667 6.959 5.412-1.505 11.22-2.259 16.992-2.284 5.762.025 11.57.78 16.991 2.284 12.959-8.784 18.646-6.959 18.646-6.959 3.704 9.346 1.375 16.246.675 17.963 4.35 4.746 6.98 10.804 6.98 18.212 0 26.075-15.872 31.813-30.992 33.492 2.437 2.096 4.608 6.237 4.608 12.57 0 9.072-.083 16.392-.083 18.617 0 1.817 1.22 3.93 4.666 3.267 26.95-8.996 46.38-34.417 46.38-64.396 0-37.487-30.392-67.875-67.88-67.875"/>
      </svg>
    </a>
  </nav>
</header>
<nav class="pagenav pagenav--top" aria-label="secondary">
  <div class="pagenav__item pagenav__item--prev">
    <a class="pagenav__link link" href="highlight.html" aria-label="Previous page">
      <svg alt="" class="arrow" width="18" height="18" viewBox="0 0 24 24">
    <path d="M5 12h14M5 12l6 6M5 12l6-6"/>
  </svg> Prev
    </a>
  </div>
  <div class="pagenav__item pagenav__item--up">
    <a class="pagenav__link link" href="index.html" aria-label="Parent page">
      <svg alt="" class="arrow" width="18" height="18" viewBox="0 0 24 24">
    <path d="M12 5v14M18 11l-6-6M6 11l6-6"/>
  </svg> Up
    </a>
  </div>
  <div class="pagenav__item pagenav__item--next">
    <a class="pagenav__link link" href="1b.html" aria-label="Next page">
      Next <svg alt="" class="arrow" width="18" height="18" viewBox="0 0 24 24">
    <path d="M5 12h14M13 18l6-6M13 6l6 6"/>
  </svg>
    </a>
  </div>

  </nav>
<main id="main">

<h1>
<span class="number">1A</span> <a class="link" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp">Overview and Introduction to Lisp<span class="nowrap">﻿<svg class="external" viewBox="0 0 24 24"><use xlink:href="#external"/></svg></span></a>
</h1>
<h2 id="1" class="anchor">
<a class="anchor__link link" href="#1" aria-hidden="true">#</a>Part 1
</h2>
<h3 id="1.1" class="anchor">
<a class="anchor__link link" href="#1.1" aria-hidden="true">#</a>Computer science
</h3>
<ul>
<li>It’s not a science, and it’s not <em>really</em> about computers.</li>
<li>It’s not about computers in the same way that astronomy isn’t about telescopes.</li>
<li>The ancient Egyptians began geometry using surveying instruments. We now know that the essence of geometry is much bigger than the act of using these primitive tools.</li>
<li>We often conflate the essence of a field with its tools.</li>
<li>In a thousand years, they will look back on us in a similar way to how we look at the ancient Egyptians: “They were playing around with these digital computers, but that was only the beginning of the much broader ideas about computation.”</li>
</ul>
<h3 id="1.2" class="anchor">
<a class="anchor__link link" href="#1.2" aria-hidden="true">#</a>Declarative vs. imperative
</h3>
<p>Mathematical declarative statement (what-is knowledge): The square root of <span class="math inline">x</span> is the <span class="math inline">y</span> such that <span class="math inline">y ≥ 0</span> and <span class="math inline">y^2 = x</span>.</p>
<p>Imperative instructions (how-to knowledge): approximate the square root of <span class="math inline">x</span> with the following steps:</p>
<ol type="1">
<li>Make a guess, <span class="math inline">G</span>.</li>
<li>Improve the guess by averaging <span class="math inline">G</span> and <span class="math inline">x/G</span>.</li>
<li>Keep improving until the guess is good enough.</li>
</ol>
<h3 id="1.3" class="anchor">
<a class="anchor__link link" href="#1.3" aria-hidden="true">#</a>Processes and Lisp
</h3>
<ul>
<li>The above is an algorithm. More generally, it is a <em>process</em>.</li>
<li>What is a process? It’s like a magical spirit that lives in the computer and does something.</li>
<li>The process is directed by a pattern of rules called a procedure (procedure is the spell that controls the spirit).</li>
<li>We conjure our spirits in a language called Lisp.</li>
<li>Lisp is easy to learn just as chess is easy to learn.</li>
<li>Rules stated in minutes, but there are many implications.</li>
<li>Much more difficult to become a master programmer: understanding all the implications, knowing how to approach problems.</li>
</ul>
<h3 id="1.4" class="anchor">
<a class="anchor__link link" href="#1.4" aria-hidden="true">#</a>Complexity and computer science
</h3>
<ul>
<li>The real problems in CS come when developing huge software with so much code that you can’t hold it all in your head at once.</li>
<li>This is possible thanks to techniques for controlling the complexity of large systems.</li>
<li>Computer scientists are in the business of controlling complexity.</li>
<li>This is different from the complexity that others, for example aeronautical engineers, deal with, because the complexity in CS in a sense is not real.</li>
<li>Computer science deals with <em>idealized</em> components.</li>
<li>We know as much as we want about the components; we don’t need to worry about tolerance.</li>
<li>Not much difference between what I can <em>build</em> and what I can <em>image</em>.</li>
<li>Other disciplines have physical constraints; in CS, the only constraint is your mind.</li>
<li>CS is an abstract kind of engineering—ignore the constraints imposed by reality.</li>
</ul>
<h3 id="1.5" class="anchor">
<a class="anchor__link link" href="#1.5" aria-hidden="true">#</a>Techniques for managing complexity
</h3>
<h4 id="1.5.1" class="anchor">
<a class="anchor__link link" href="#1.5.1" aria-hidden="true">#</a>Black box abstraction
</h4>
<p>Take something and build a box around it. The important thing is that you don’t care what is going on inside the box—it’s not important. Black-box abstraction <em>suppresses detail</em>. This allows you to go on and build bigger boxes.</p>
<ul>
<li>Primitive objects: primitive procedures, primitive data.</li>
<li>Means of combination: procedure composition, construction of compound data.</li>
<li>Means of abstraction: procedure definition, simple data abstraction.</li>
<li>Capturing common patterns: higher-order procedures, data as procedures.</li>
</ul>
<h4 id="1.5.2" class="anchor">
<a class="anchor__link link" href="#1.5.2" aria-hidden="true">#</a>Conventional interfaces
</h4>
<p>Agreed upon ways of connecting things together. Like standard impedances in electrical engineering.</p>
<ul>
<li>generic operations</li>
<li>large-scale structure and modularity</li>
<li>object-oriented programming</li>
<li>operations on aggregates</li>
</ul>
<h4 id="1.5.3" class="anchor">
<a class="anchor__link link" href="#1.5.3" aria-hidden="true">#</a>Metalinguistic abstraction
</h4>
<p>Another way of controlling complexity is to choose a new design language (a domain-specific language, or DSL) that will highlight different aspects of the system. It will emphasize some kinds of details and suppress others. This is the technology for building new computer languages.</p>
<p>The process of interpreting Lisp in Lisp is like a giant wheel of two processes, <code class="sourceCode scheme"><span class="fu">apply</span></code> and <code class="sourceCode scheme"><span class="fu">eval</span></code>, which reduce expressions to each other. Very magical.</p>
<ul>
<li><code class="sourceCode scheme"><span class="fu">apply</span></code> and <code class="sourceCode scheme"><span class="fu">eval</span></code></li>
<li>logical programming</li>
<li>register machines</li>
</ul>
<h2 id="2" class="anchor">
<a class="anchor__link link" href="#2" aria-hidden="true">#</a>Part 2
</h2>
<h3 id="2.1" class="anchor">
<a class="anchor__link link" href="#2.1" aria-hidden="true">#</a>Three main features
</h3>
<h4 id="2.1.1" class="anchor">
<a class="anchor__link link" href="#2.1.1" aria-hidden="true">#</a>Primitive elements
</h4>
<p>Here are some primitive elements is Lisp: <code class="sourceCode scheme"><span class="cn">3</span></code>, <code class="sourceCode scheme"><span class="cn">14.4</span></code>, <code class="sourceCode scheme"><span class="cn">5</span></code>, <code class="sourceCode scheme"><span class="fu">+</span></code>. These are all names that represents things. The first three represent numbers, and the last one represents the concept of addition.</p>
<h4 id="2.1.2" class="anchor">
<a class="anchor__link link" href="#2.1.2" aria-hidden="true">#</a>Means of combination
</h4>
<ul>
<li>We can take the sum using a <em>combination</em>: <code class="sourceCode scheme">(<span class="fu">+</span> <span class="cn">3</span> <span class="cn">14.4</span> <span class="cn">5</span>)</code>.</li>
<li>Combination: applying and operator to operands.</li>
<li>The operator and operands themselves can be combinations.</li>
<li>Lisp uses fully parenthesized (unambiguous) prefix notation.</li>
<li>Parentheses are very different in Lisp and in mathematics.</li>
<li>Nested combinations can be modelled as trees.</li>
<li>Parentheses are just a way to write trees as a linear sequence of characters.</li>
</ul>
<h4 id="2.1.3" class="anchor">
<a class="anchor__link link" href="#2.1.3" aria-hidden="true">#</a>Means of abstraction
</h4>
<p>This is accomplished in Lisp with <code class="sourceCode scheme"><span class="kw">define</span></code>. Defining something gives a name to an expression. We write this the same way as a regular combination, but <code class="sourceCode scheme"><span class="kw">define</span></code> is not a procedure—it is a <em>special form</em>. We can also define procedures this way:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (square x) (<span class="fu">*</span> x x))</span></code></pre></div>
<p>We can also make it more clear that we are naming something:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> square (<span class="kw">lambda</span> (x) (<span class="fu">*</span> x x)))</span></code></pre></div>
<p>The former notation is just syntactic sugar for the latter: a more convenient surface forms for typing something. The former <em>desugars</em> to the latter.</p>
<p>In Lisp, you do not make arbitrary distinctions between things that are defined in the language and things that happen to be built-in.</p>
<h3 id="2.2" class="anchor">
<a class="anchor__link link" href="#2.2" aria-hidden="true">#</a>Case analysis
</h3>
<p>We do case analysis in Lisp using <code class="sourceCode scheme"><span class="kw">cond</span></code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (<span class="fu">abs</span> x)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cond</span> ((<span class="fu">&lt;</span> x <span class="cn">0</span>) (<span class="fu">-</span> x))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        ((<span class="fu">=</span> x <span class="cn">0</span>) <span class="cn">0</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        ((<span class="fu">&gt;</span> x <span class="cn">0</span>) x)))</span></code></pre></div>
<p>Each line is a clause consisting of a predicate (true or false) and an action. We can use <code class="sourceCode scheme"><span class="kw">if</span></code> if there is a single case:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">define</span> (<span class="fu">abs</span> x)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="fu">&lt;</span> x <span class="cn">0</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">-</span> x)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>      x))</span></code></pre></div>
<p>You can think of <code class="sourceCode scheme"><span class="kw">if</span></code> as syntactic sugar for <code class="sourceCode scheme"><span class="kw">cond</span></code> or vice versa.</p>
<h3 id="2.3" class="anchor">
<a class="anchor__link link" href="#2.3" aria-hidden="true">#</a>Recursion
</h3>
<ul>
<li>We now know enough to implement any numerical procedure that you could implement in other languages.</li>
<li>We don’t need any looping constructs in Lisp. We can define things in terms of themselves using <em>recursion</em>.</li>
</ul>
<h3 id="2.4" class="anchor">
<a class="anchor__link link" href="#2.4" aria-hidden="true">#</a>Block structure
</h3>
<ul>
<li>We can create a black box by packaging internals inside of a definition. This is called <em>block structure</em>.</li>
</ul>
</main>
<nav class="pagenav pagenav--bottom" aria-label="secondary">
  <div class="pagenav__item pagenav__item--prev">
    <a class="pagenav__link link" href="highlight.html" aria-label="Previous page">
      <svg alt="" class="arrow" width="18" height="18" viewBox="0 0 24 24">
    <path d="M5 12h14M5 12l6 6M5 12l6-6"/>
  </svg> Prev
    </a>
  </div>
  <div class="pagenav__item pagenav__item--up">
    <a class="pagenav__link link" href="index.html" aria-label="Parent page">
      <svg alt="" class="arrow" width="18" height="18" viewBox="0 0 24 24">
    <path d="M12 5v14M18 11l-6-6M6 11l6-6"/>
  </svg> Up
    </a>
  </div>
  <div class="pagenav__item pagenav__item--next">
    <a class="pagenav__link link" href="1b.html" aria-label="Next page">
      Next <svg alt="" class="arrow" width="18" height="18" viewBox="0 0 24 24">
    <path d="M5 12h14M13 18l6-6M13 6l6 6"/>
  </svg>
    </a>
  </div>

  </nav>
<footer class="footer">
  <p>© 2020 Mitchell Kember</p>
</footer>
</body>
</html>
