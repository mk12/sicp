<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Lecture 1A Notes</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
<header class="header ">
  <a class="title link" href="../index.html">SICP Study</a>
  <span class="gap"></span>
  <nav class="sitenav">
    <a class="sitenav__item link " href="../text/index.html">Text</a>
    <a class="sitenav__item link  sitenav__item--active" href="../lecture/index.html">Lecture</a>
    <a class="sitenav__item link " href="../exercise/index.html">Exercise</a>
    <a class="sitenav__item link" href="https://github.com/mk12/sicp">Source <svg class="github-mark" width="25" height="25" viewBox="0 0 136 133">
  <g transform="matrix(1,0,0,1,-568.001,-447.669)">
    <g transform="matrix(4.16667,0,0,4.16667,0,0)">
      <g transform="matrix(1,0,0,1,152.608,139.345)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.778 -11.354,-8.279 -11.354,-8.279C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.154 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.237C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.839 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.839 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904"/>
      </g>
    </g>
  </g>
</svg></a>
  </nav>
</header>
<nav class="pagenav pagenav--top">
  <div class="pagenav__item pagenav__item--prev"><a class="pagenav__link link" href="quote.html">← Prev</a></div>
  <div class="pagenav__item pagenav__item--up"><a class="pagenav__link link" href="index.html">↑ Up</a></div>
  <div class="pagenav__item pagenav__item--next"><a class="pagenav__link link" href="1b.html">Next →</a></div>
</nav>
<h1>
<small class="number">1A</small>Overview and Introduction to Lisp
</h1>
<h2 id="1" class="anchor">
<a class="anchor__link link" href="#1">#</a>Part 1
</h2>
<h3 id="1.1" class="anchor">
<a class="anchor__link link" href="#1.1">#</a>Computer science
</h3>
<ul>
<li>It’s not a science, and it’s not <em>really</em> about computers.</li>
<li>It’s not about computers in the same way that astronomy isn’t about telescopes.</li>
<li>The ancient Egyptians began geometry using surveying instruments. We now know that the essence of geometry is much bigger than the act of using these primitive tools.</li>
<li>We often conflate the essence of a field with its tools.</li>
<li>In a thousand years, they will look back on us in a similar way to how we look at the ancient Egyptians: “They were playing around with these digital computers, but that was only the beginning of the much broader ideas about computation.”</li>
</ul>
<h3 id="1.2" class="anchor">
<a class="anchor__link link" href="#1.2">#</a>Declarative vs. imperative
</h3>
<p>Mathematical declarative statement (what-is knowledge): The square root of <span class="math inline">x</span> is the <span class="math inline">y</span> such that <span class="math inline">y ≥ 0</span> and <span class="math inline">y^2 = x</span>.</p>
<p>Imperative instructions (how-to knowledge): approximate the square root of <span class="math inline">x</span> with the following steps:</p>
<ol type="1">
<li>Make a guess, <span class="math inline">G</span>.</li>
<li>Improve the guess by averaging <span class="math inline">G</span> and <span class="math inline">x/G</span>.</li>
<li>Keep improving until the guess is good enough.</li>
</ol>
<h3 id="1.3" class="anchor">
<a class="anchor__link link" href="#1.3">#</a>Processes and Lisp
</h3>
<ul>
<li>The above is an algorithm. More generally, it is a <em>process</em>.</li>
<li>What is a process? It’s like a magical spirit that lives in the computer and does something.</li>
<li>The process is directed by a pattern of rules called a procedure (procedure is the spell that controls the spirit).</li>
<li>We conjure our spirits in a language called Lisp.</li>
<li>Lisp is easy to learn just as chess is easy to learn.</li>
<li>Rules stated in minutes, but there are many implications.</li>
<li>Much more difficult to become a master programmer: understanding all the implications, knowing how to approach problems.</li>
</ul>
<h3 id="1.4" class="anchor">
<a class="anchor__link link" href="#1.4">#</a>Complexity and computer science
</h3>
<ul>
<li>The real problems in CS come when developing huge software with so much code that you can’t hold it all in your head at once.</li>
<li>This is possible thanks to techniques for controlling the complexity of large systems.</li>
<li>Computer scientists are in the business of controlling complexity.</li>
<li>This is different from the complexity that others, for example aeronautical engineers, deal with, because the complexity in CS in a sense is not real.</li>
<li>Computer science deals with <em>idealized</em> components.</li>
<li>We know as much as we want about the components; we don’t need to worry about tolerance.</li>
<li>Not much difference between what I can <em>build</em> and what I can <em>image</em>.</li>
<li>Other disciplines have physical constraints; in CS, the only constraint is your mind.</li>
<li>CS is an abstract kind of engineering – ignore the constraints imposed by reality.</li>
</ul>
<h3 id="1.5" class="anchor">
<a class="anchor__link link" href="#1.5">#</a>Techniques for managing complexity
</h3>
<h4 id="1.5.1" class="anchor">
<a class="anchor__link link" href="#1.5.1">#</a>Black box abstraction
</h4>
<p>Take something and build a box around it. The important thing is that you don’t care what is going on inside the box – it’s not important. Black-box abstraction <em>suppresses detail</em>. This allows you to go on and build bigger boxes.</p>
<ul>
<li>Primitive objects: primitive procedures, primitive data.</li>
<li>Means of combination: procedure composition, construction of compound data.</li>
<li>Means of abstraction: procedure definition, simple data abstraction.</li>
<li>Capturing common patterns: higher-order procedures, data as procedures.</li>
</ul>
<h4 id="1.5.2" class="anchor">
<a class="anchor__link link" href="#1.5.2">#</a>Conventional interfaces
</h4>
<p>Agreed upon ways of connecting things together. Like standard impedances in electrical engineering.</p>
<ul>
<li>generic operations</li>
<li>large-scale structure and modularity</li>
<li>object-oriented programming</li>
<li>operations on aggregates</li>
</ul>
<h4 id="1.5.3" class="anchor">
<a class="anchor__link link" href="#1.5.3">#</a>Metalinguistic abstraction
</h4>
<p>Another way of controlling complexity is to choose a new design language (a domain-specific language, or DSL) that will highlight different aspects of the system. It will emphasize some kinds of details and suppress others. This is the technology for building new computer languages.</p>
<p>The process of interpreting Lisp in Lisp is like a giant wheel of two processes, <code>apply</code> and <code>eval</code>, which reduce expressions to each other. Very magical.</p>
<ul>
<li><code>apply</code> and <code>eval</code></li>
<li>logical programming</li>
<li>register machines</li>
</ul>
<h2 id="2" class="anchor">
<a class="anchor__link link" href="#2">#</a>Part 2
</h2>
<h3 id="2.1" class="anchor">
<a class="anchor__link link" href="#2.1">#</a>Three main features
</h3>
<h4 id="2.1.1" class="anchor">
<a class="anchor__link link" href="#2.1.1">#</a>Primitive elements
</h4>
<p>Here are some primitive elements is Lisp: <code>3</code>, <code>14.4</code>, <code>5</code>, <code>+</code>. These are all names that represents things. The first three represent numbers, and the last one represents the concept of addition.</p>
<h4 id="2.1.2" class="anchor">
<a class="anchor__link link" href="#2.1.2">#</a>Means of combination
</h4>
<ul>
<li>We can take the sum using a <em>combination</em>: <code class="sourceCode scheme">(<span class="op">+</span> <span class="dv">3</span> <span class="fl">14.4</span> <span class="dv">5</span>)</code>.</li>
<li>Combination: applying and operator to operands.</li>
<li>The operator and operands themselves can be combinations.</li>
<li>Lisp uses fully parenthesized (unambiguous) prefix notation.</li>
<li>Parentheses are very different in Lisp and in mathematics.</li>
<li>Nested combinations can be modelled as trees.</li>
<li>Parentheses are just a way to write trees as a linear sequence of characters.</li>
</ul>
<h4 id="2.1.3" class="anchor">
<a class="anchor__link link" href="#2.1.3">#</a>Means of abstraction
</h4>
<p>This is accomplished in Lisp with <code>define</code>. Defining something gives a name to an expression. We write this the same way as a regular combination, but <code>define</code> is not a procedure – it is a <em>special form</em>. We can also define procedures this way:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(square x) (<span class="op">*</span> x x))</span></code></pre></div>
<p>We can also make it more clear that we are naming something:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> square </span>(<span class="kw">lambda</span> (x) (<span class="op">*</span> x x)))</span></code></pre></div>
<p>The former notation is just syntactic sugar for the latter: a more convenient surface forms for typing something. The former <em>desugars</em> to the latter.</p>
<p>In Lisp, you do not make arbitrary distinctions between things that are defined in the language and things that happen to be built-in.</p>
<h3 id="2.2" class="anchor">
<a class="anchor__link link" href="#2.2">#</a>Case analysis
</h3>
<p>We do case analysis in Lisp using <code>cond</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">abs</span> x)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cond</span> ((<span class="op">&lt;</span> x <span class="dv">0</span>) (<span class="op">-</span> x))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        ((<span class="op">=</span> x <span class="dv">0</span>) <span class="dv">0</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        ((<span class="op">&gt;</span> x <span class="dv">0</span>) x)))</span></code></pre></div>
<p>Each line is a clause consisting of a predicate (true or false) and an action. We can use <code>if</code> if there is a single case:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">abs</span> x)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> (<span class="op">&lt;</span> x <span class="dv">0</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>      (<span class="op">-</span> x)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>      x))</span></code></pre></div>
<p>You can think of <code>if</code> as syntactic sugar for <code>cond</code> or vice versa.</p>
<h3 id="2.3" class="anchor">
<a class="anchor__link link" href="#2.3">#</a>Recursion
</h3>
<ul>
<li>We now know enough to implement any numerical procedure that you could implement in other languages.</li>
<li>We don’t need any looping constructs in Lisp. We can define things in terms of themselves using <em>recursion</em>.</li>
</ul>
<h3 id="2.4" class="anchor">
<a class="anchor__link link" href="#2.4">#</a>Block structure
</h3>
<ul>
<li>We can create a black box by packaging internals inside of a definition. This is called <em>block structure</em>.</li>
</ul>
<nav class="pagenav pagenav--bottom">
  <div class="pagenav__item pagenav__item--prev"><a class="pagenav__link link" href="quote.html">← Prev</a></div>
  <div class="pagenav__item pagenav__item--up"><a class="pagenav__link link" href="index.html">↑ Up</a></div>
  <div class="pagenav__item pagenav__item--next"><a class="pagenav__link link" href="1b.html">Next →</a></div>
</nav>
<footer class="footer">© 2020 Mitchell Kember</footer>
</body>
</html>
