<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Mitchell Kember">
  <title>SICP Lecture 2B Notes</title>
  <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
<header class="header ">
  <a class="title link" href="../index.html">SICP Study</a>
  <span class="gap"></span>
  <nav class="sitenav">
    <a class="sitenav__item link "
      href="../text/index.html">Text</a>
    <a class="sitenav__item link  sitenav__item--active"
      href="../lecture/index.html">Lecture</a>
    <a class="sitenav__item link "
      href="../exercise/index.html">Exercise</a>
    <a class="sitenav__item link" href="https://github.com/mk12/sicp">
      Source&nbsp;<svg class="github-mark" width="25" height="25" viewBox="0 0 136 133">
  <g transform="matrix(1,0,0,1,-568.001,-447.669)">
    <g transform="matrix(4.16667,0,0,4.16667,0,0)">
      <g transform="matrix(1,0,0,1,152.608,139.345)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.778 -11.354,-8.279 -11.354,-8.279C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.154 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.237C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.839 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.839 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904"/>
      </g>
    </g>
  </g>
</svg>
    </a>
  </nav>
</header>
<nav class="pagenav pagenav--top">
  <div class="pagenav__item pagenav__item--prev">
    <a class="pagenav__link link" href="2a.html">
      <svg class="arrow" width="18" height="18" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="5" y1="12" x2="19" y2="12"/>
  <line x1="5" y1="12" x2="11" y2="18"/>
  <line x1="5" y1="12" x2="11" y2="6"/>
</svg>&nbsp;Prev
    </a>
  </div>
  <div class="pagenav__item pagenav__item--up">
    <a class="pagenav__link link" href="index.html"><svg class="arrow" width="18" height="18" viewBox="0 0 24 24" stroke-width="1.75" stroke="currentColor" fill="none">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="12" y1="5" x2="12" y2="19"/>
  <line x1="18" y1="11" x2="12" y2="5"/>
  <line x1="6" y1="11" x2="12" y2="5"/>
</svg>&nbsp;Up</a>
  </div>
  <div class="pagenav__item pagenav__item--next">
    <a class="pagenav__link link" href="3a.html">
      Next&nbsp;<svg class="arrow" width="18" height="18" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="5" y1="12" x2="19" y2="12"/>
  <line x1="13" y1="18" x2="19" y2="12"/>
  <line x1="13" y1="6" x2="19" y2="12"/>
</svg>
    </a>
  </div>
</nav>
<h1>
<small class="number">2B</small>Compound Data
</h1>
<h2 id="1" class="anchor">
<a class="anchor__link link" href="#1">#</a>Part 1
</h2>
<h3 id="1.1" class="anchor">
<a class="anchor__link link" href="#1.1">#</a>Recap
</h3>
<p>In the beginning, we learned about</p>
<ul>
<li>primitive forms</li>
<li>means of combination</li>
<li>means of abstraction</li>
</ul>
<p>Then, we learned how to use higher-order procedures to represent general methods of computation. This gave us extraordinary expressive power.</p>
<h3 id="1.2" class="anchor">
<a class="anchor__link link" href="#1.2">#</a>Layered system
</h3>
<ul>
<li>When we wrote the square root procedure, we used layers of abstraction. Someone else could have written <code>good-enough?</code>.</li>
</ul>
<blockquote>
<p>The crucial idea is that when we’re building things, we divorce the task of building things from the task implementing the parts.</p>
</blockquote>
<ul>
<li>In a large system, we have lots of <em>abstraction barriers</em>.</li>
<li>Now we will look at the same issues for data.</li>
<li>There are means of combination for data as well, allowing us to combine primitive data into compound data.</li>
<li>We will also see a methodology for abstraction with data.</li>
<li>Key idea: build the system in layers, with abstraction barriers.</li>
</ul>
<h3 id="1.3" class="anchor">
<a class="anchor__link link" href="#1.3">#</a>Rational number arithmetic
</h3>
<ul>
<li>We already know how to express the arithmetic operators for fractions in math.</li>
<li>Combining two fractions with addition, subtraction, multiplication, or division produces another fraction.</li>
<li>The computations are easy – but how to we represent a rational number? They are not primitive numbers.</li>
<li>We need to apply the strategy of wishful thinking: let’s imagine that we have procedures <code>make-rat</code>, <code>numer</code>, and <code>denom</code>.</li>
<li>We can implement a procedure for adding rationals like so:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(+rat x y)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  (make-rat</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   (<span class="op">+</span> (<span class="op">*</span> (numer x) (denom y))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      (<span class="op">*</span> (numer y) (denom x)))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>   (<span class="op">*</span> (denom x) (denom y))))</span></code></pre></div>
<ul>
<li>The procedure <code>make-rat</code> is called a <em>constructor</em>.</li>
<li>The procedures <code>numer</code> and <code>denom</code> are called <em>selectors</em>.</li>
</ul>
<h3 id="1.4" class="anchor">
<a class="anchor__link link" href="#1.4">#</a>Why do we need compound data?
</h3>
<ul>
<li>Why bother with these data objects instead of just passing in four numbers? It doesn’t scale, and there is no abstraction.</li>
<li>We would have to worry about all these temporary numbers.</li>
<li>It’s confusing. We need abstraction.</li>
<li>We need to create compound data objects for the same reason that we separate our program into procedures built on abstractions.</li>
</ul>
<h2 id="2" class="anchor">
<a class="anchor__link link" href="#2">#</a>Part 2
</h2>
<h3 id="2.1" class="anchor">
<a class="anchor__link link" href="#2.1">#</a>Pairs
</h3>
<ul>
<li>How do we actually make one of these “clouds”?</li>
<li>We need a kind of glue to connect things.</li>
<li>Lisp provides this: it is called <em>list structure</em>.</li>
<li>The primitive <code>cons</code> allows us to construct <em>pairs</em>.</li>
<li><code>cons</code> is obviously the <strong>cons</strong>tructor.</li>
<li><code>car</code> and <code>cdr</code> are the selectors for pairs.</li>
<li>For any <code>x</code> and <code>y</code>, <code class="sourceCode scheme">(<span class="kw">car</span> (<span class="kw">cons</span> x y))</code> is <code>x</code>.</li>
<li>For any <code>x</code> and <code>y</code>, <code class="sourceCode scheme">(<span class="kw">cdr</span> (<span class="kw">cons</span> x y))</code> is <code>y</code>.</li>
<li>We can represent conses with two boxes side by side with an arrow coming from each.</li>
<li>This is called <em>box-and-pointer notation</em>.</li>
</ul>
<h3 id="2.2" class="anchor">
<a class="anchor__link link" href="#2.2">#</a>Lowest terms
</h3>
<ul>
<li>When we use the system to add a half and a quarter, it gives us six eights instead of three quarters. This isn’t what we want.</li>
<li>This isn’t the problem of the addition procedure; the <code>make-rat</code> procedure should be responsible for reducing to lowest terms.</li>
<li>We can use the greatest common divisor to fix this:</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-rat n d)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((g (<span class="kw">gcd</span> n d)))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">cons</span> (<span class="op">/</span> n g) (<span class="op">/</span> d g))))</span></code></pre></div>
<ul>
<li>Now our fractions will always be reduced to lowest terms.</li>
</ul>
<h3 id="2.3" class="anchor">
<a class="anchor__link link" href="#2.3">#</a>Abstraction layer
</h3>
<ul>
<li>The important thing with our rational arithmetic system is the abstraction layer.</li>
<li>We have the rational arithmetic operators on one side and the pair constructor and selectors on the other.</li>
<li>The procedures <code>make-rat</code>, <code>numer</code>, and <code>denom</code> are an abstraction barrier between the two.</li>
<li>We always want to separate <em>use</em> from <em>representation</em>.</li>
<li>This methodology is called <em>data abstraction</em>.</li>
</ul>
<h3 id="2.4" class="anchor">
<a class="anchor__link link" href="#2.4">#</a>Why use data abstraction?
</h3>
<ul>
<li>We didn’t have to do it this way.</li>
<li>We could have used <code>cons</code>, <code>car</code>, and <code>cdr</code> directly in the rational arithmetic procedures.</li>
<li>Is this talk of data abstraction just self-righteous BS?</li>
<li>Maybe it would be marginally more efficient to skip the data abstraction!</li>
<li>It goes back to naming. If you have the name of the spirit, you have control over it.</li>
<li>One advantage: you might want to have alternative representations. If we use <code>cons</code> directly, we would have to reduce to lowest terms every time we make a rational number.</li>
<li>With the data abstraction, we could even move the lowest terms stuff to the selectors – no other change in the code required.</li>
<li>Data abstraction lets us postpone decisions.</li>
</ul>
<h3 id="2.5" class="anchor">
<a class="anchor__link link" href="#2.5">#</a>Designing systems
</h3>
<blockquote>
<p>See, in general, as systems designers, you’re forced with the necessity to make decisions about how you’re going to do things. And in general, the way to retain flexibility is to never make up your mind about anything until you’re forced to do it. The problem is, there’s a very, very narrow line between deferring decisions and outright procrastination. So you’d like to make progress, but also at the same time never be bound by the consequences of your decisions.</p>
</blockquote>
<blockquote>
<p>I said that computer science is a lot like magic, and it’s sort of good that it’s like magic. There’s a bad part of computer that’s a lot like religion.</p>
</blockquote>
<h2 id="3" class="anchor">
<a class="anchor__link link" href="#3">#</a>Part 3
</h2>
<h3 id="3.1" class="anchor">
<a class="anchor__link link" href="#3.1">#</a>Data abstraction
</h3>
<ul>
<li>Data abstraction is a way of controlling complexity in large systems.</li>
<li>Like all ways of controlling complexity, the real power comes from their use as building blocks for more complicated things.</li>
</ul>
<h3 id="3.2" class="anchor">
<a class="anchor__link link" href="#3.2">#</a>Points and line segments
</h3>
<ul>
<li>We could also use pairs to represent points on a plane.</li>
<li>The constructor and accessors could use <code>cons</code>, <code>car</code>, and <code>cdr</code>, just like in the rational number system.</li>
<li>We could use points (or vectors) as a building block to make line segments. This would be a multi-layered system.</li>
<li>Segments, vectors, and pairs are all separated.</li>
<li>Without data abstraction, the procedure for calculating the length of a line segment is very hard to read; worse, it locks you into decisions about representation.</li>
<li><code>cons</code> can combine anything, not just numbers. With line segments, we combine two pairs.</li>
<li><em>Closure</em> means we can make pairs of pairs, not just pairs of numbers. We say that the means of combinations closes over the things that it makes.</li>
</ul>
<h2 id="4" class="anchor">
<a class="anchor__link link" href="#4">#</a>Part 4
</h2>
<h3 id="4.1" class="anchor">
<a class="anchor__link link" href="#4.1">#</a>Abstract data and contracts
</h3>
<ul>
<li>We’ve done a few simple examples. Now we’re going to talk about what it <em>means</em>, which is much harder.</li>
<li>At the beginning, we assumed the constructors and selectors for rational numbers existed (without knowing about pairs).</li>
<li>We had defined a rational number representation in terms of <em>abstract data</em>.</li>
<li>There’s a way of saying whether three procedures are suitable as a basis for rational number representation.</li>
<li>We had a contract that the procedures have to fulfill: given a rational number <code>x</code> created with <code class="sourceCode scheme">(make-rat n d)</code>, we must have <code class="sourceCode scheme">(<span class="op">=</span> (<span class="op">/</span> (numer x) (denom x)) (<span class="op">/</span> n d))</code>.</li>
</ul>
<h3 id="4.2" class="anchor">
<a class="anchor__link link" href="#4.2">#</a>Implementation of pairs
</h3>
<ul>
<li>Rational numbers <em>really</em> are just this contract, this axiom.</li>
<li>They might be realized as pairs in a particular implementation, but that has nothing to do with what pairs really are.</li>
<li>Pairs are the same: they happen to satisfy the contract that <code class="sourceCode scheme">(<span class="kw">car</span> (<span class="kw">cons</span> x y))</code> is <code>x</code> and <code class="sourceCode scheme">(<span class="kw">cdr</span> (<span class="kw">cons</span> x y))</code> is <code>y</code>.</li>
<li>We can implement pairs with procedures. We don’t even need special primitives – all we need are lambdas:</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cons</span> a b)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">lambda</span> (pick)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">cond</span> ((<span class="op">=</span> pick <span class="dv">1</span>) a)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>          ((<span class="op">=</span> pick <span class="dv">2</span>) b))))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">car</span> x) (x <span class="dv">1</span>))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cdr</span> x) (x <span class="dv">2</span>))</span></code></pre></div>
<ul>
<li>All we need to do is show that this satisfies the axiom.</li>
<li>We can do that with the substitution model. It works.</li>
<li>You couldn’t tell if <code>cons</code>, <code>car</code>, and <code>cdr</code> were implemented in this way or not.</li>
</ul>
<h3 id="4.3" class="anchor">
<a class="anchor__link link" href="#4.3">#</a>Conclusion
</h3>
<ul>
<li>We don’t need data at all for data abstraction: we can do everything with procedures.</li>
<li>This blurs the line between code and data.</li>
<li>Procedures are not just the act of doing something.</li>
<li>Procedures are conceptual entities or objects.</li>
</ul>
<nav class="pagenav pagenav--bottom">
  <div class="pagenav__item pagenav__item--prev">
    <a class="pagenav__link link" href="2a.html">
      <svg class="arrow" width="18" height="18" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="5" y1="12" x2="19" y2="12"/>
  <line x1="5" y1="12" x2="11" y2="18"/>
  <line x1="5" y1="12" x2="11" y2="6"/>
</svg>&nbsp;Prev
    </a>
  </div>
  <div class="pagenav__item pagenav__item--up">
    <a class="pagenav__link link" href="index.html"><svg class="arrow" width="18" height="18" viewBox="0 0 24 24" stroke-width="1.75" stroke="currentColor" fill="none">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="12" y1="5" x2="12" y2="19"/>
  <line x1="18" y1="11" x2="12" y2="5"/>
  <line x1="6" y1="11" x2="12" y2="5"/>
</svg>&nbsp;Up</a>
  </div>
  <div class="pagenav__item pagenav__item--next">
    <a class="pagenav__link link" href="3a.html">
      Next&nbsp;<svg class="arrow" width="18" height="18" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <line x1="5" y1="12" x2="19" y2="12"/>
  <line x1="13" y1="18" x2="19" y2="12"/>
  <line x1="13" y1="6" x2="19" y2="12"/>
</svg>
    </a>
  </div>
</nav>
<footer class="footer">
  © 2020 Mitchell Kember
</footer>
</body>
</html>
