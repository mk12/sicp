<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mitchell Kember" />
  <title>SICP Lecture Notes</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<a class="index-link" href="index.html">Index</a>
|
<a class="index-link" href="https://github.com/mk12/sicp">GitHub</a>
<header id="title-block-header">
<h1 class="title">SICP Lecture Notes</h1>
<p class="subtitle">Notes on <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/"><em>Structure and Interpretation of Computer Programs</em> lectures</a></p>
<p class="author">Mitchell Kember</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#a-overview-and-introduction-to-lisp">1A: Overview and Introduction to Lisp</a></li>
<li><a href="#b-procedures-and-processes-substitution-model">1B: Procedures and Processes; Substitution Model</a></li>
<li><a href="#a-higher-order-procedures">2A: Higher-order Procedures</a></li>
<li><a href="#b-compound-data">2B: Compound Data</a></li>
<li><a href="#a-henderson-escher-example">3A: Henderson Escher Example</a></li>
<li><a href="#b-symbolic-differentiation-quotation">3B: Symbolic Differentiation; Quotation</a></li>
<li><a href="#a-pattern-matching-and-rule-based-substitution">4A: Pattern Matching and Rule-based Substitution</a></li>
<li><a href="#b-generic-operators">4B: Generic Operators</a></li>
<li><a href="#a-assignment-state-and-side-effects">5A: Assignment, State, and Side-effects</a></li>
<li><a href="#b-computational-objects">5B: Computational Objects</a></li>
<li><a href="#a-streams-part-1">6A: Streams, Part 1</a></li>
<li><a href="#b-streams-part-2">6B: Streams, Part 2</a></li>
<li><a href="#a-metacircular-evaluator-part-1">7A: Metacircular Evaluator, Part 1</a></li>
<li><a href="#b-metacircular-evaluator-part-2">7B: Metacircular Evaluator, Part 2</a></li>
</ul>
</nav>
<h1 id="a-overview-and-introduction-to-lisp">1A: Overview and Introduction to Lisp</h1>
<h2 id="part-1">Part 1</h2>
<h3 id="computer-science">Computer science</h3>
<ul>
<li>It’s not a science, and it’s not <em>really</em> about computers.</li>
<li>It’s not about computers in the same way that astronomy isn’t about telescopes.</li>
<li>The ancient Egyptians began geometry using surveying instruments. We now know that the essence of geometry is much bigger than the act of using these primitive tools.</li>
<li>We often conflate the essence of a field with its tools.</li>
<li>In a thousand years, they will look back on us in a similar way to how we look at the ancient Egyptians: “They were playing around with these digital computers, but that was only the beginning of the much broader ideas about computation.”</li>
</ul>
<h3 id="declarative-vs.-imperative">Declarative vs. imperative</h3>
<p>Mathematical declarative statement (what-is knowledge): The square root of <span class="math inline">x</span> is the <span class="math inline">y</span> such that <span class="math inline">y ≥ 0</span> and <span class="math inline">y^2 = x</span>.</p>
<p>Imperative instructions (how-to knowledge): approximate the square root of <span class="math inline">x</span> with the following steps:</p>
<ol type="1">
<li>Make a guess, <span class="math inline">G</span>.</li>
<li>Improve the guess by averaging <span class="math inline">G</span> and <span class="math inline">x/G</span>.</li>
<li>Keep improving until the guess is good enough.</li>
</ol>
<h3 id="processes-and-lisp">Processes and Lisp</h3>
<ul>
<li>The above is an algorithm. More generally, it is a <em>process</em>.</li>
<li>What is a process? It’s like a magical spirit that lives in the computer and does something.</li>
<li>The process is directed by a pattern of rules called a procedure (procedure is the spell that controls the spirit).</li>
<li>We conjure our spirits in a language called Lisp.</li>
<li>Lisp is easy to learn just as chess is easy to learn.</li>
<li>Rules stated in minutes, but there are many implications.</li>
<li>Much more difficult to become a master programmer: understanding all the implications, knowing how to approach problems.</li>
</ul>
<h3 id="complexity-and-computer-science">Complexity and computer science</h3>
<ul>
<li>The real problems in CS come when developing huge software with so much code that you can’t hold it all in your head at once.</li>
<li>This is possible thanks to techniques for controlling the complexity of large systems.</li>
<li>Computer scientists are in the business of controlling complexity.</li>
<li>This is different from the complexity that others, for example aeronautical engineers, deal with, because the complexity in CS in a sense is not real.</li>
<li>Computer science deals with <em>idealized</em> components.</li>
<li>We know as much as we want about the components; we don’t need to worry about tolerance.</li>
<li>Not much difference between what I can <em>build</em> and what I can <em>image</em>.</li>
<li>Other disciplines have physical constraints; in CS, the only constraint is your mind.</li>
<li>CS is an abstract kind of engineering – ignore the constraints imposed by reality.</li>
</ul>
<h3 id="techniques-for-managing-complexity">Techniques for managing complexity</h3>
<h4 id="black-box-abstraction">Black box abstraction</h4>
<p>Take something and build a box around it. The important thing is that you don’t care what is going on inside the box – it’s not important. Black-box abstraction <em>suppresses detail</em>. This allows you to go on and build bigger boxes.</p>
<ul>
<li>Primitive objects: primitive procedures, primitive data.</li>
<li>Means of combination: procedure composition, construction of compound data.</li>
<li>Means of abstraction: procedure definition, simple data abstraction.</li>
<li>Capturing common patterns: higher-order procedures, data as procedures.</li>
</ul>
<h4 id="conventional-interfaces">Conventional interfaces</h4>
<p>Agreed upon ways of connecting things together. Like standard impedances in electrical engineering.</p>
<ul>
<li>generic operations</li>
<li>large-scale structure and modularity</li>
<li>object-oriented programming</li>
<li>operations on aggregates</li>
</ul>
<h4 id="metalinguistic-abstraction">Metalinguistic abstraction</h4>
<p>Another way of controlling complexity is to choose a new design language (a domain-specific language, or DSL) that will highlight different aspects of the system. It will emphasize some kinds of details and suppress others. This is the technology for building new computer languages.</p>
<p>The process of interpreting Lisp in Lisp is like a giant wheel of two processes, <code>apply</code> and <code>eval</code>, which reduce expressions to each other. Very magical.</p>
<ul>
<li><code>apply</code> and <code>eval</code></li>
<li>logical programming</li>
<li>register machines</li>
</ul>
<h2 id="part-2">Part 2</h2>
<h3 id="three-main-features">Three main features</h3>
<h4 id="primitive-elements">Primitive elements</h4>
<p>Here are some primitive elements is Lisp: <code>3</code>, <code>14.4</code>, <code>5</code>, <code>+</code>. These are all names that represents things. The first three represent numbers, and the last one represents the concept of addition.</p>
<h4 id="means-of-combination">Means of combination</h4>
<ul>
<li>We can take the sum using a <em>combination</em>: <code>(+ 3 14.4 5)</code>.</li>
<li>Combination: applying and operator to operands.</li>
<li>The operator and operands themselves can be combinations.</li>
<li>Lisp uses fully parenthesized (unambiguous) prefix notation.</li>
<li>Parentheses are very different in Lisp and in mathematics.</li>
<li>Nested combinations can be modelled as trees.</li>
<li>Parentheses are just a way to write trees as a linear sequence of characters.</li>
</ul>
<h4 id="means-of-abstraction">Means of abstraction</h4>
<p>This is accomplished in Lisp with <code>define</code>. Defining something gives a name to an expression. We write this the same way as a regular combination, but <code>define</code> is not a procedure – it is a <em>special form</em>. We can also define procedures this way:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1"></a>(<span class="ex">define</span><span class="fu"> </span>(square x) (* x x))</span></code></pre></div>
<p>We can also make it more clear that we are naming something:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1"></a>(<span class="ex">define</span><span class="fu"> square </span>(<span class="kw">lambda</span> (x) (* x x)))</span></code></pre></div>
<p>The former notation is just syntactic sugar for the latter: a more convenient surface forms for typing something. The former <em>desugars</em> to the latter.</p>
<p>In Lisp, you do not make arbitrary distinctions between things that are defined in the language and things that happen to be built-in.</p>
<h3 id="case-analysis">Case analysis</h3>
<p>We do case analysis in Lisp using <code>cond</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">abs</span> x)</span>
<span id="cb3-2"><a href="#cb3-2"></a>  (<span class="kw">cond</span> ((<span class="op">&lt;</span> x <span class="dv">0</span>) (<span class="op">-</span> x))</span>
<span id="cb3-3"><a href="#cb3-3"></a>        ((<span class="op">=</span> x <span class="dv">0</span>) <span class="dv">0</span>)</span>
<span id="cb3-4"><a href="#cb3-4"></a>        ((<span class="op">&gt;</span> x <span class="dv">0</span>) x)))</span></code></pre></div>
<p>Each line is a clause consisting of a predicate (true or false) and an action. We can use <code>if</code> if there is a single case:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">abs</span> x)</span>
<span id="cb4-2"><a href="#cb4-2"></a>  (<span class="kw">if</span> (<span class="op">&lt;</span> x <span class="dv">0</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>      (<span class="op">-</span> x)</span>
<span id="cb4-4"><a href="#cb4-4"></a>      x))</span></code></pre></div>
<p>You can think of <code>if</code> as syntactic sugar for <code>cond</code> or vice versa.</p>
<h3 id="recursion">Recursion</h3>
<ul>
<li>We now know enough to implement any numerical procedure that you could implement in other languages.</li>
<li>We don’t need any looping constructs in Lisp. We can define things in terms of themselves using <em>recursion</em>.</li>
</ul>
<h3 id="block-structure">Block structure</h3>
<ul>
<li>We can create a black box by packaging internals inside of a definition. This is called <em>block structure</em>.</li>
</ul>
<h1 id="b-procedures-and-processes-substitution-model">1B: Procedures and Processes; Substitution Model</h1>
<h2 id="part-1-1">Part 1</h2>
<h3 id="programs-and-processes">Programs and processes</h3>
<ul>
<li>The job of a programmer is to design processes that accomplish particular goals (like finding the square root of a number).</li>
<li>You do this by constructing spells (procedures, expressions) which direct a process to accomplish the desired goal.</li>
<li>You must understand the relationship between the particular spells you cast and the process you’re trying to control.</li>
<li>How do particular patterns of procedures and expressions cause particular patterns of execution and behaviour in the process?</li>
</ul>
<h3 id="kinds-of-expressions">Kinds of expressions</h3>
<p>So far we’ve seen three main kinds of expressions:</p>
<ul>
<li>numbers</li>
<li>symbols</li>
<li>combinations</li>
</ul>
<p>These are also expressions, but they are <em>special forms</em>, so we will worry about them later:</p>
<ul>
<li>lambdas</li>
<li>definitions</li>
<li>conditionals</li>
</ul>
<h3 id="evaluating-combinations">Evaluating combinations</h3>
<p>These are the substitution rules for evaluating a combination. Note that the order does not matter for steps 1 and 2.</p>
<ol type="1">
<li>Evaluate the operator to get the procedure.</li>
<li>Evaluate the operands to get the arguments.</li>
<li>Apply the procedure to the arguments.
<ol type="1">
<li>Copy the body of the procedure.</li>
<li>Substitute the arguments supplied for the formal parameters of the procedure.</li>
<li>Evaluate the resulting body.</li>
</ol></li>
</ol>
<h4 id="example">Example</h4>
<p>The <code>sos</code> procedure takes the sum of the squares:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1"></a>(<span class="ex">define</span><span class="fu"> </span>(sq a) (* a a))</span>
<span id="cb5-2"><a href="#cb5-2"></a>(<span class="ex">define</span><span class="fu"> </span>(sos x y) (<span class="op">+</span> (sq x) (sq y)))</span></code></pre></div>
<p>Let’s evaluate the sum of the square of 3 and the square of 4:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1"></a>(sos <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a>(<span class="op">+</span> (sq <span class="dv">3</span>) (sq <span class="dv">4</span>))</span>
<span id="cb6-3"><a href="#cb6-3"></a>(<span class="op">+</span> (sq <span class="dv">3</span>) (* <span class="dv">4</span> <span class="dv">4</span>))</span>
<span id="cb6-4"><a href="#cb6-4"></a>(<span class="op">+</span> (sq <span class="dv">3</span>) <span class="dv">16</span>)</span>
<span id="cb6-5"><a href="#cb6-5"></a>(<span class="op">+</span> (* <span class="dv">3</span> <span class="dv">3</span>) <span class="dv">16</span>)</span>
<span id="cb6-6"><a href="#cb6-6"></a>(<span class="op">+</span> <span class="dv">9</span> <span class="dv">16</span>)</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="dv">25</span></span></code></pre></div>
<p>This is not a perfect description of what the computer does. But it is a good enough model for now.</p>
<blockquote>
<p>But one of the things he have to learn how to do is to ignore details. The key to understanding complex things is knowing what not to look at, and what not to compute, and what not to think.</p>
</blockquote>
<h3 id="evaluating-conditionals">Evaluating conditionals</h3>
<p>To evaluate <code>(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)</code>, follow these steps:</p>
<ol type="1">
<li>Evaluate the predicate expression.
<ol type="1">
<li>If it yields true, evaluate the consequent expression.</li>
<li>If it yields false, evaluate the alternative expression.</li>
</ol></li>
</ol>
<h4 id="example-1">Example</h4>
<p>The addition operator in Peano arithmetic uses a conditional:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb7-1"><a href="#cb7-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="op">+</span> x y)</span>
<span id="cb7-2"><a href="#cb7-2"></a>  (<span class="kw">if</span> (<span class="op">=</span> x <span class="dv">0</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a>      y</span>
<span id="cb7-4"><a href="#cb7-4"></a>      (<span class="op">+</span> (-<span class="dv">1</span>+ x) (<span class="dv">1</span>+ y))))</span></code></pre></div>
<p>Now we can evaluate <code>(+ 3 4)</code> like so:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb8-1"><a href="#cb8-1"></a>(<span class="op">+</span> <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb8-2"><a href="#cb8-2"></a>(<span class="kw">if</span> (<span class="op">=</span> <span class="dv">3</span> <span class="dv">0</span>) <span class="dv">4</span> (<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">3</span>) (<span class="dv">1</span>+ <span class="dv">4</span>)))</span>
<span id="cb8-3"><a href="#cb8-3"></a>(<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">3</span>) (<span class="dv">1</span>+ <span class="dv">4</span>))</span>
<span id="cb8-4"><a href="#cb8-4"></a>(<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">3</span>) <span class="dv">5</span>)</span>
<span id="cb8-5"><a href="#cb8-5"></a>(<span class="op">+</span> <span class="dv">2</span> <span class="dv">5</span>)</span>
<span id="cb8-6"><a href="#cb8-6"></a>(<span class="kw">if</span> (<span class="op">=</span> <span class="dv">2</span> <span class="dv">0</span>) <span class="dv">5</span> (<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">2</span>) (<span class="dv">1</span>+ <span class="dv">5</span>)))</span>
<span id="cb8-7"><a href="#cb8-7"></a>(<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">2</span>) (<span class="dv">1</span>+ <span class="dv">5</span>))</span>
<span id="cb8-8"><a href="#cb8-8"></a>(<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">2</span>) <span class="dv">6</span>)</span>
<span id="cb8-9"><a href="#cb8-9"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">6</span>)</span>
<span id="cb8-10"><a href="#cb8-10"></a>(<span class="kw">if</span> (<span class="op">=</span> <span class="dv">1</span> <span class="dv">0</span>) <span class="dv">6</span> (<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">1</span>) (<span class="dv">1</span>+ <span class="dv">6</span>)))</span>
<span id="cb8-11"><a href="#cb8-11"></a>(<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">1</span>) (<span class="dv">1</span>+ <span class="dv">6</span>))</span>
<span id="cb8-12"><a href="#cb8-12"></a>(<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">1</span>) <span class="dv">7</span>)</span>
<span id="cb8-13"><a href="#cb8-13"></a>(<span class="op">+</span> <span class="dv">0</span> <span class="dv">7</span>)</span>
<span id="cb8-14"><a href="#cb8-14"></a>(<span class="kw">if</span> (<span class="op">=</span> <span class="dv">0</span> <span class="dv">0</span>) <span class="dv">7</span> (<span class="op">+</span> (-<span class="dv">1</span>+ <span class="dv">0</span>) (<span class="dv">1</span>+ <span class="dv">7</span>)))</span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="dv">7</span></span></code></pre></div>
<h2 id="part-2-1">Part 2</h2>
<h3 id="pre-visualization">Pre-visualization</h3>
<ul>
<li>A program made of procedures and expression evolves a process.</li>
<li>But how do particular programs evolve particle processes?</li>
<li>We want to be able to go from particularly shaped programs to particularly shaped processes.</li>
<li>We want to pre-visualize the process like a photographer pre-visualizes the photo before taking the shot.</li>
</ul>
<h3 id="peano-arithmetic">Peano arithmetic</h3>
<p>There are two ways to add whole numbers in Peano arithmetic.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb9-1"><a href="#cb9-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="op">+</span> x y)</span>
<span id="cb9-2"><a href="#cb9-2"></a>  (<span class="kw">if</span> (<span class="op">=</span> x <span class="dv">0</span>)</span>
<span id="cb9-3"><a href="#cb9-3"></a>      y</span>
<span id="cb9-4"><a href="#cb9-4"></a>      (<span class="op">+</span> (-<span class="dv">1</span>+ x) (<span class="dv">1</span>+ y))))</span>
<span id="cb9-5"><a href="#cb9-5"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="op">+</span> x y)</span>
<span id="cb9-6"><a href="#cb9-6"></a>  (<span class="kw">if</span> (<span class="op">=</span> x <span class="dv">0</span>)</span>
<span id="cb9-7"><a href="#cb9-7"></a>      y</span>
<span id="cb9-8"><a href="#cb9-8"></a>      (<span class="dv">1</span>+ (<span class="op">+</span> (-<span class="dv">1</span>+ x) y))))</span></code></pre></div>
<p>Both are written using recursion, but they are different: the first generates a <em>linear iterative</em> process with <span class="math inline">Θ(n)</span> time and <span class="math inline">Θ(n)</span> space; the second generates a <em>linear recursive</em> process with <span class="math inline">Θ(n)</span> time and <span class="math inline">Θ(1)</span> space.</p>
<p>The iteration has all of its state in explicit variables. The recursion does not.</p>
<h2 id="part-3">Part 3</h2>
<h3 id="perturbation-analysis">Perturbation analysis</h3>
<p>Make small changes to the program, see how it affects the process.</p>
<h3 id="fibonacci-sequence">Fibonacci sequence</h3>
<p>We can represent the Fibonacci numbers 0, 1, 1, 2, 3, 5, 8, 13, 21, … in Lisp:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb10-1"><a href="#cb10-1"></a>(<span class="ex">define</span><span class="fu"> </span>(fib n)</span>
<span id="cb10-2"><a href="#cb10-2"></a>  (<span class="kw">if</span> (<span class="op">&lt;</span> n <span class="dv">2</span>)</span>
<span id="cb10-3"><a href="#cb10-3"></a>      n</span>
<span id="cb10-4"><a href="#cb10-4"></a>      (<span class="op">+</span> (fib (<span class="op">-</span> n <span class="dv">1</span>))</span>
<span id="cb10-5"><a href="#cb10-5"></a>        (fib (<span class="op">-</span> n <span class="dv">2</span>)))))</span></code></pre></div>
<p>This is a <em>tree-recursive</em> process. We can represent the evaluation with a tree. This is a terribly inefficient process because their is so much redundant computation. The time complexity of this is actually the Fibonacci numbers. The space complexity is linear.</p>
<blockquote>
<p>The reason why people think programming is hard is because you’re writing down a general rule which is going to be used for lots of instances – it’s going to control all of those instances.</p>
</blockquote>
<h3 id="tower-of-hanoi">Tower of Hanoi</h3>
<blockquote>
<p>The way in which you construct a recursive process is by wishful thinking. You have to believe.</p>
</blockquote>
<p>Move an n-high tower from spike <code>from</code> to spike <code>to</code> using spike <code>spare</code> as a spare:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb11-1"><a href="#cb11-1"></a>(<span class="ex">define</span><span class="fu"> </span>(move n from to spare)</span>
<span id="cb11-2"><a href="#cb11-2"></a>  (<span class="kw">cond</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    ((<span class="op">=</span> n <span class="dv">0</span>) <span class="st">&quot;DONE&quot;</span>)</span>
<span id="cb11-4"><a href="#cb11-4"></a>    (<span class="kw">else</span> (move (-<span class="dv">1</span>+ n) from spare to)</span>
<span id="cb11-5"><a href="#cb11-5"></a>          (print-move from to)</span>
<span id="cb11-6"><a href="#cb11-6"></a>          (move (-<span class="dv">1</span>+m) spare to from))))</span></code></pre></div>
<h1 id="a-higher-order-procedures">2A: Higher-order Procedures</h1>
<h2 id="part-1-2">Part 1</h2>
<h3 id="dont-repeat-yourself">Don’t repeat yourself</h3>
<ul>
<li>So far Lisp might just seem like a different language with funny syntax. It’s time to shatter that illusion.</li>
<li>We are already familiar with creating recursive procedures that, for example, calculate the sum of integers from <span class="math inline">A</span> to <span class="math inline">B</span>.</li>
<li>What about the sum of the squares of the integers from <span class="math inline">A</span> to <span class="math inline">B</span>? That’s almost the same program! We don’t like repetition.</li>
</ul>
<blockquote>
<p>Whenever you see yourself writing the same thing down more than once, there’s something wrong and you shouldn’t be doing it. And the reason is not because it’s a waste of time to write something down more than once. It’s because there’s some idea here, a very simple idea….</p>
</blockquote>
<ul>
<li>It is crucial to divide problems up into as many pieces as is reasonable. We must be able to understand each in isolation.</li>
<li>No repetition means you only write it once, but also only understand and debug it once!</li>
<li>Any time you see things that are almost identical, think of an abstraction to cover them.</li>
<li>An <em>idiom</em> is a common pattern in a language that is useful to know. In Lisp, we can give idioms names and abstract them.</li>
<li>There is nothing very special about numbers. Numbers are just one kind of data. Procedures are also data.</li>
</ul>
<h3 id="summation">Summation</h3>
<p>We can represent the sigma notation with a procedure that takes other procedures as arguments:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb12-1"><a href="#cb12-1"></a>(<span class="ex">define</span><span class="fu"> </span>(sum term a next b)</span>
<span id="cb12-2"><a href="#cb12-2"></a>  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</span>
<span id="cb12-3"><a href="#cb12-3"></a>      <span class="dv">0</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>      (<span class="op">+</span> (term a)</span>
<span id="cb12-5"><a href="#cb12-5"></a>        (sum term (next a) next b))))</span></code></pre></div>
<p>Now we can write particular cases easily, without repeating ourselves:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb13-1"><a href="#cb13-1"></a>(<span class="ex">define</span><span class="fu"> </span>(sum-int a b)</span>
<span id="cb13-2"><a href="#cb13-2"></a>  (<span class="ex">define</span><span class="fu"> </span>(identity x) x)</span>
<span id="cb13-3"><a href="#cb13-3"></a>  (sum identity a <span class="dv">1</span>+ b))</span>
<span id="cb13-4"><a href="#cb13-4"></a>(<span class="ex">define</span><span class="fu"> </span>(sum-sq a b)</span>
<span id="cb13-5"><a href="#cb13-5"></a>  (sum square a <span class="dv">1</span>+ b))</span>
<span id="cb13-6"><a href="#cb13-6"></a>(<span class="ex">define</span><span class="fu"> </span>(pi-sum a b)</span>
<span id="cb13-7"><a href="#cb13-7"></a>  (sum (<span class="kw">lambda</span> (i) (<span class="op">/</span> i (* i (<span class="op">+</span> i <span class="dv">2</span>))))</span>
<span id="cb13-8"><a href="#cb13-8"></a>       a</span>
<span id="cb13-9"><a href="#cb13-9"></a>       (<span class="kw">lambda</span> (i) (<span class="op">+</span> i <span class="dv">4</span>))</span>
<span id="cb13-10"><a href="#cb13-10"></a>       b))</span></code></pre></div>
<p>We are separating the things we are adding up from the method of doing the addition. Now, we can change the sum procedure so that it generates an iterative process, and all the specific procedures using sum will benefit.</p>
<h2 id="part-2-2">Part 2</h2>
<h3 id="higher-order-procedures">Higher-order procedures</h3>
<ul>
<li>We use abstraction for the purpose of making programs easier to read and write.</li>
<li>Abstraction helps us to clarify what’s going on.</li>
<li>Our square root algorithm was a specific instance of the more general fixed-point search.</li>
<li>The damping part is also a general signal processing strategy, and we can also treat is as a separate thing using a higher-order procedure.</li>
<li>Higher-order procedures can take procedures as arguments and they can return new procedures.</li>
</ul>
<h2 id="part-3-1">Part 3</h2>
<h3 id="newtons-method">Newton’s method</h3>
<ul>
<li>Newton’s method: general method to find the zeros (an <span class="math inline">x</span> such that <span class="math inline">f(x) = 0</span>).</li>
<li>We can use the fixed-point procedure to define a procedure for computing zeros using Newton’s method.</li>
</ul>
<blockquote>
<p>Wishful thinking: essential to good engineering. And especially essential to good computer science.</p>
</blockquote>
<ul>
<li>We can use names of procedures that we haven’t defined yet while writing a program (top-down design).</li>
</ul>
<h3 id="the-rights-and-privileges-of-first-class-citizens">The rights and privileges of first-class citizens</h3>
<ul>
<li>To be named by variables.</li>
<li>To be passed as arguments to procedures.</li>
<li>To be returned as values of procedures.</li>
<li>To be incorporating into data structures.</li>
</ul>
<h1 id="b-compound-data">2B: Compound Data</h1>
<h2 id="part-1-3">Part 1</h2>
<h3 id="recap">Recap</h3>
<p>In the beginning, we learned about</p>
<ul>
<li>primitive forms</li>
<li>means of combination</li>
<li>means of abstraction</li>
</ul>
<p>Then, we learned how to use higher-order procedures to represent general methods of computation. This gave us extraordinary expressive power.</p>
<h3 id="layered-system">Layered system</h3>
<ul>
<li>When we wrote the square root procedure, we used layers of abstraction. Someone else could have written <code>good-enough?</code>.</li>
</ul>
<blockquote>
<p>The crucial idea is that when we’re building things, we divorce the task of building things from the task implementing the parts.</p>
</blockquote>
<ul>
<li>In a large system, we have lots of <em>abstraction barriers</em>.</li>
<li>Now we will look at the same issues for data.</li>
<li>There are means of combination for data as well, allowing us to combine primitive data into compound data.</li>
<li>We will also see a methodology for abstraction with data.</li>
<li>Key idea: build the system in layers, with abstraction barriers.</li>
</ul>
<h3 id="rational-number-arithmetic">Rational number arithmetic</h3>
<ul>
<li>We already know how to express the arithmetic operators for fractions in math.</li>
<li>Combining two fractions with addition, subtraction, multiplication, or division produces another fraction.</li>
<li>The computations are easy – but how to we represent a rational number? They are not primitive numbers.</li>
<li>We need to apply the strategy of wishful thinking: let’s imagine that we have procedures <code>make-rat</code>, <code>numer</code>, and <code>denom</code>.</li>
<li>We can implement a procedure for adding rationals like so:</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb14-1"><a href="#cb14-1"></a>(<span class="ex">define</span><span class="fu"> </span>(+rat x y)</span>
<span id="cb14-2"><a href="#cb14-2"></a>  (make-rat</span>
<span id="cb14-3"><a href="#cb14-3"></a>    (<span class="op">+</span> (* (numer x) (denom y))</span>
<span id="cb14-4"><a href="#cb14-4"></a>       (* (numer y) (denom x)))</span>
<span id="cb14-5"><a href="#cb14-5"></a>    (* (denom x) (denom y))))</span></code></pre></div>
<ul>
<li>The procedure <code>make-rat</code> is called a <em>constructor</em>.</li>
<li>The procedures <code>numer</code> and <code>denom</code> are called <em>selectors</em>.</li>
</ul>
<h3 id="why-do-we-need-compound-data">Why do we need compound data?</h3>
<ul>
<li>Why bother with these data objects instead of just passing in four numbers? It doesn’t scale, and there is no abstraction.</li>
<li>We would have to worry about all these temporary numbers.</li>
<li>It’s confusing. We need abstraction.</li>
<li>We need to create compound data objects for the same reason that we separate our program into procedures built on abstractions.</li>
</ul>
<h2 id="part-2-3">Part 2</h2>
<h3 id="pairs">Pairs</h3>
<ul>
<li>How do we actually make one of these “clouds”?</li>
<li>We need a kind of glue to connect things.</li>
<li>Lisp provides this: it is called <em>list structure</em>.</li>
<li>The primitive <code>cons</code> allows us to construct <em>pairs</em>.</li>
<li><code>cons</code> is obviously the <strong>cons</strong>tructor.</li>
<li><code>car</code> and <code>cdr</code> are the selectors for pairs.</li>
<li>For any <code>x</code> and <code>y</code>, <code>(car (cons x y))</code> is <code>x</code>.</li>
<li>For any <code>x</code> and <code>y</code>, <code>(cdr (cons x y))</code> is <code>y</code>.</li>
<li>We can represent conses with two boxes side by side with an arrow coming from each.</li>
<li>This is called <em>box-and-pointer notation</em>.</li>
</ul>
<h3 id="lowest-terms">Lowest terms</h3>
<ul>
<li>When we use the system to add a half and a quarter, it gives us six eights instead of three quarters. This isn’t what we want.</li>
<li>This isn’t the problem of the addition procedure; the <code>make-rat</code> procedure should be responsible for reducing to lowest terms.</li>
<li>We can use the greatest common divisor to fix this:</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb15-1"><a href="#cb15-1"></a>(<span class="ex">define</span><span class="fu"> </span>(make-rat n d)</span>
<span id="cb15-2"><a href="#cb15-2"></a>  (<span class="kw">let</span> ((g (<span class="kw">gcd</span> n d)))</span>
<span id="cb15-3"><a href="#cb15-3"></a>    (<span class="kw">cons</span> (<span class="op">/</span> n g) (<span class="op">/</span> d g))))</span></code></pre></div>
<ul>
<li>Now our fractions will always be reduced to lowest terms.</li>
</ul>
<h3 id="abstraction-layer">Abstraction layer</h3>
<ul>
<li>The important thing with our rational arithmetic system is the abstraction layer.</li>
<li>We have the rational arithmetic operators on one side and the pair constructor and selectors on the other.</li>
<li>The procedures <code>make-rat</code>, <code>numer</code>, and <code>denom</code> are an abstraction barrier between the two.</li>
<li>We always want to separate <em>use</em> from <em>representation</em>.</li>
<li>This methodology is called <em>data abstraction</em>.</li>
</ul>
<h3 id="why-use-data-abstraction">Why use data abstraction?</h3>
<ul>
<li>We didn’t have to do it this way.</li>
<li>We could have used <code>cons</code>, <code>car</code>, and <code>cdr</code> directly in the rational arithmetic procedures.</li>
<li>Is this talk of data abstraction just self-righteous BS?</li>
<li>Maybe it would be marginally more efficient to skip the data abstraction!</li>
<li>It goes back to naming. If you have the name of the spirit, you have control over it.</li>
<li>One advantage: you might want to have alternative representations. If we use <code>cons</code> directly, we would have to reduce to lowest terms every time we make a rational number.</li>
<li>With the data abstraction, we could even move the lowest terms stuff to the selectors – no other change in the code required.</li>
<li>Data abstraction lets us postpone decisions.</li>
</ul>
<h3 id="designing-systems">Designing systems</h3>
<blockquote>
<p>See, in general, as systems designers, you’re forced with the necessity to make decisions about how you’re going to do things. And in general, the way to retain flexibility is to never make up your mind about anything until you’re forced to do it. The problem is, there’s a very, very narrow line between deferring decisions and outright procrastination. So you’d like to make progress, but also at the same time never be bound by the consequences of your decisions.</p>
</blockquote>
<blockquote>
<p>I said that computer science is a lot like magic, and it’s sort of good that it’s like magic. There’s a bad part of computer since that’s a lot like religion.</p>
</blockquote>
<h2 id="part-3-2">Part 3</h2>
<h3 id="data-abstraction">Data abstraction</h3>
<ul>
<li>Data abstraction is a way of controlling complexity in large systems.</li>
<li>Like all ways of controlling complexity, the real power comes from their use as building blocks for more complicated things.</li>
</ul>
<h3 id="points-and-line-segments">Points and line segments</h3>
<ul>
<li>We could also use pairs to represent points on a plane.</li>
<li>The constructor and accessors could use <code>cons</code>, <code>car</code>, and <code>cdr</code>, just like in the rational number system.</li>
<li>We could use points (or vectors) as a building block to make line segments. This would be a multi-layered system.</li>
<li>Segments, vectors, and pairs are all separated.</li>
<li>Without data abstraction, the procedure for calculating the length of a line segment is very hard to read; worse, it locks you into decisions about representation.</li>
<li><code>cons</code> can combine anything, not just numbers. With line segments, we combine two pairs.</li>
<li><em>Closure</em> means we can make pairs of pairs, not just pairs of numbers. We say that the means of combinations closes over the things that it makes.</li>
</ul>
<h2 id="part-4">Part 4</h2>
<h3 id="abstract-data-and-contracts">Abstract data and contracts</h3>
<ul>
<li>We’ve done a few simple examples. Now we’re going to talk about what it <em>means</em>, which is much harder.</li>
<li>At the beginning, we assumed the constructors and selectors for rational numbers existed (without knowing about pairs).</li>
<li>We had defined a rational number representation in terms of <em>abstract data</em>.</li>
<li>There’s a way of saying whether three procedures are suitable as a basis for rational number representation.</li>
<li>We had a contract that the procedures have to fulfill: given a rational number <code>x</code> created with <code>(make-rat n d)</code>, we must have <code>(= (/ (numer x) (denom x)) (/ n d))</code>.</li>
</ul>
<h3 id="implementation-of-pairs">Implementation of pairs</h3>
<ul>
<li>Rational numbers <em>really</em> are just this contract, this axiom.</li>
<li>They might be realized as pairs in a particular implementation, but that has nothing to do with what pairs really are.</li>
<li>Pairs are the same: they happen to satisfy the contract that <code>(car (cons x y))</code> is <code>x</code> and <code>(cdr (cons x y))</code> is <code>y</code>.</li>
<li>We can implement pairs with procedures. We don’t even need special primitives – all we need are lambdas:</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb16-1"><a href="#cb16-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cons</span> a b)</span>
<span id="cb16-2"><a href="#cb16-2"></a>  (<span class="kw">lambda</span> (pick)</span>
<span id="cb16-3"><a href="#cb16-3"></a>    (<span class="kw">cond</span> ((<span class="op">=</span> pick <span class="dv">1</span>) a)</span>
<span id="cb16-4"><a href="#cb16-4"></a>          ((<span class="op">=</span> pick <span class="dv">2</span>) b))))</span>
<span id="cb16-5"><a href="#cb16-5"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">car</span> x) (x <span class="dv">1</span>))</span>
<span id="cb16-6"><a href="#cb16-6"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cdr</span> x) (x <span class="dv">2</span>))</span></code></pre></div>
<ul>
<li>All we need to do is show that this satisfies the axiom.</li>
<li>We can do that with the substitution model. It works.</li>
<li>You couldn’t tell if <code>cons</code>, <code>car</code>, and <code>cdr</code> were implemented in this way or not.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<ul>
<li>We don’t need data at all for data abstraction: we can do everything with procedures.</li>
<li>This blurs the line between code and data.</li>
<li>Procedures are not just the act of doing something.</li>
<li>Procedures are conceptual entities or objects.</li>
</ul>
<h1 id="a-henderson-escher-example">3A: Henderson Escher Example</h1>
<h2 id="part-1-4">Part 1</h2>
<h3 id="recap-1">Recap</h3>
<ul>
<li>Now we know about procedural abstract and data abstraction.</li>
<li>We can isolate the way data objects are <em>used</em> from the way that they are <em>represented</em>.</li>
<li>We learned how to make pairs with <code>cons</code>, <code>car</code>, and <code>cdr</code>.</li>
<li>We looked at examples: interval arithmetic and vectors.</li>
<li>We can glue together arbitrary things with <code>cons</code>, not just numbers.</li>
<li>We learned about closure: the things that we combine can themselves be combined. This allows us to build complexity.</li>
</ul>
<h3 id="lists">Lists</h3>
<ul>
<li>Their are a lot of different ways of building list structure.</li>
<li>Lisp has a particular convention for representing a sequence as chained pairs: a list.</li>
<li>The car of the pair is the first item. The <code>cdr</code> of the pair is the rest of the sequence.</li>
<li>The <code>cdr</code> of the last pair has a special marker. This is the empty list, also called nil or null. It is printed as <code>()</code>.</li>
<li>The predicate <code>null?</code> checks if a list is empty (is nil).</li>
<li>Lisp has a procedure called <code>list</code>, which is just an abbreviation for the nested conses.</li>
</ul>
<h3 id="mapping-lists">Mapping lists</h3>
<ul>
<li>It is common to write a procedure that does the same thing to each item in a list and returns a new list.</li>
<li>The recursive strategy is to apply the operation to the car of the list, and then cons that onto the rest of the list which has already been mapped (wishful thinking).</li>
<li>Rather than doing the recursive strategy manually each time, we use the higher-order procedure <code>map</code>.</li>
<li>Thinking in terms of operations on aggregates is a powerful idea. We don’t worry about recursion or other details.</li>
<li><code>for-each</code> is like map, but it doesn’t build up a new list. It is just for side-effects.</li>
</ul>
<h2 id="part-2-4">Part 2</h2>
<h3 id="henderson-escher-example">Henderson Escher example</h3>
<ul>
<li>A language for describing self-similar, fractal-like figures.</li>
<li>This example will blur the line between procedures and data.</li>
<li>There is only one primitive: a painter. A painter draws its image within a frame (a parallelogram).</li>
<li>We have means of combination: <code>rotate</code>, <code>beside</code>, and <code>below</code>.</li>
<li>Thanks to the closure property, we are able to build up complexity in this language quickly.</li>
<li>A frame is defined by an origin vector and two side vectors.</li>
<li>All frames are based on transformations from the unit square.</li>
<li>We can build primitive painters from lists of line segments.</li>
<li>A painter is a procedure that takes a frame and draws its image within the frame.</li>
</ul>
<h2 id="part-3-3">Part 3</h2>
<h3 id="importance-of-closure">Importance of closure</h3>
<ul>
<li>This representation is nice because, once primitives are implemented in this way, the means of combination just fall out because you automatically get the closure property.</li>
<li>The procedures <code>beside</code> and <code>below</code> are trivial to write.</li>
<li>The operation <code>rotate</code> is similarly simple.</li>
<li>The real punchline comes when you look at the means of abstraction. Since painters are just procedures, everything that Lisp supplies for procedures is automatically available to us in this painting language.</li>
<li>We can write recursive painters without ever having purposely built recursion into the painting language.</li>
<li>We can even write higher-order painters.</li>
</ul>
<h3 id="the-power-of-lisp">The power of Lisp</h3>
<ul>
<li>The difference between merely implementing something in a language and embedding something in the language: you don’t lost the original power of the language.</li>
<li>Lisp is a lousy language for any particular problem. But it’s good for figuring out the right language and embedding that in Lisp. That’s the real power of this approach to design.</li>
<li>There is no difference between procedures and data.</li>
</ul>
<h3 id="software-engineering">Software engineering</h3>
<ul>
<li>We have been creating a sequence of layers of language.</li>
<li>The methodology (or mythology) of software engineering is this: figure out your task, break it into three sub-tasks, and repeat for each sub-task. Work your way up to the top and you’ll end up with this beautiful edifice.</li>
<li>Each of these nodes in the tree is supposed to fit perfectly into the whole thing.</li>
<li>The Henderson example didn’t work like that.</li>
<li>Instead, we had a sequence of layers of language. Each layer depends on the layers beneath it, but it can’t see their details because there is an abstraction barrier in the way.</li>
</ul>
<blockquote>
<p>So what you have is, at each level, the objects that are being talked about are the things that were erected at the previous level.</p>
</blockquote>
<ul>
<li>With the top-down tree, each part does a specific task.</li>
<li>In the Henderson example, we had a full range of linguistic power at each level. Each level does a whole range of things, not a single task.</li>
<li>This makes the system more robust, meaning that changes are easy to make and the system can adapt to them.</li>
<li>A small change in the top-down tree might cause the whole thing to fall down unless you reconstruct it.</li>
<li>We are talking about levels of language rather than a strict hierarchy. Each level has its own vocabulary.</li>
<li>The design process is not so much implementing programs as implementing languages. That’s the powerful idea of Lisp.</li>
</ul>
<h1 id="b-symbolic-differentiation-quotation">3B: Symbolic Differentiation; Quotation</h1>
<h2 id="part-1-5">Part 1</h2>
<h3 id="recap-2">Recap</h3>
<ul>
<li>In order to make a robust system, it needs to be insensitive to small changes.</li>
<li>A small change in the problem leads to a small change in the solution.</li>
<li>Don’t solve a particular problem at each level; solve a class of problems in the neighbourhood of the particular problem by building a language suited to them.</li>
<li>We’ve seen the power of embedding languages.</li>
<li>We are going to confuse the distinction between procedures and data even more badly.</li>
</ul>
<h3 id="derivatives-and-integrals">Derivatives and integrals</h3>
<ul>
<li>Instead of doing a numerical approximation of the derivative, we want to apply the rules of calculus to algebraic expressions.</li>
<li>Producing derivatives of arbitrary expressions is easy; producing integrals, the inverse operation, is hard.</li>
<li>Why is it easy to go one way but not the other? Because the rules for differentiation are reduction rules.</li>
<li>Big problems turn into multiple simpler problems.</li>
</ul>
<h3 id="differentiation-procedure">Differentiation procedure</h3>
<ul>
<li>The reduction rules of differentiation are appropriate for recursion.</li>
<li>We can write the rules as a case analysis.</li>
<li>But, we need to be able to <em>represent</em> the expressions.</li>
<li>The differentiation procedure that takes an <em>expression</em> as an argument is different from the one that takes a function.</li>
<li>You can’t open up a function. You can only get answers from it.</li>
<li>An expression is an object representing the algebraic expression that defines a function.</li>
<li>We can write the procedure <code>deriv</code> using a lot of wishful thinking.</li>
</ul>
<h3 id="expression-representation">Expression representation</h3>
<ul>
<li>To represent sums, products, quotients, etc., why not use the same language we’re writing the program in?</li>
<li>We can just use list structure.</li>
<li>There are more built-in predicates we haven’t seen yet: <code>atom?</code> and <code>eq?</code>.</li>
</ul>
<h3 id="quotation">Quotation</h3>
<ul>
<li>We are also introducing <em>quotation</em>. The words of English are ambiguous: <em>say your name</em> is different from <em>say “your name”</em>.</li>
<li>The notation in Lisp is to precede the expression with a single quotation mark.</li>
<li>Quotation makes a language more complex because we can no longer substitute equals for equals (see Bertrand Russell’s “On Denoting”).</li>
<li>The names <code>car</code> and <code>cdr</code> have survived (originally the address register and the decrement register) because we can do things like <code>cadddr</code> and <code>cadar</code>.</li>
</ul>
<h2 id="part-2-5">Part 2</h2>
<h3 id="simplifying-expressions">Simplifying expressions</h3>
<ul>
<li>The expressions we get from the <code>deriv</code> procedure are ugly.</li>
<li>Nothing is simplified, and it is hard to read.</li>
</ul>
<blockquote>
<p>The form of the process is expanded from the local rules that you see in the procedure.</p>
</blockquote>
<ul>
<li>There is nothing wrong with the rules. The solutions is to change the representation to add a simplification step.</li>
</ul>
<blockquote>
<p>This is one the pieces of artillery we have in our war against complexity.</p>
</blockquote>
<ul>
<li>We have an abstraction barrier between the rules of differentiation and the representation of algebraic expressions (list structure).</li>
</ul>
<h3 id="conclusion-1">Conclusion</h3>
<ul>
<li>Quotation stops and says, “I’m talking about this expression itself.”</li>
<li>We can write languages that are not only embedded in Lisp, that are completely different, using quotation.</li>
<li>Quotation gives us tremendous power.</li>
</ul>
<h1 id="a-pattern-matching-and-rule-based-substitution">4A: Pattern Matching and Rule-based Substitution</h1>
<h2 id="part-1-6">Part 1</h2>
<h3 id="recap-3">Recap</h3>
<ul>
<li>We wrote a program to differentiate expressions that had a highly stylized behaviour and structure.</li>
<li>We used quotation to represent symbolic math expressions.</li>
<li>Why did we have to translate the rules of differential calculus into the language of the computer?</li>
<li>Our program was a conditional dispatch on the type of the expression.</li>
<li>Is there some other, more clear way of writing this program?</li>
</ul>
<h3 id="rules">Rules</h3>
<ul>
<li>We follow rules to differentiate expressions. What is a rule, exactly?</li>
<li>A rule has a left-hand side and a right-hand side.
<ul>
<li>The LHS is what you compare your expression to.</li>
<li>The RHS is the replacement expression.</li>
</ul></li>
<li>A rule is an arrow from a <em>pattern</em> to a <em>skeleton</em>.</li>
<li>We match the source expression to the pattern, and following the rule, we instantiate the skeleton to get the target expression.</li>
<li>We want to build a language that allows us to directly express these rules. We will work bottom-up, like before.</li>
</ul>
<h3 id="representation">Representation</h3>
<ul>
<li>We can represent the differentiation rules like this:</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb17-1"><a href="#cb17-1"></a>(<span class="ex">define</span><span class="fu"> deriv-rules</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>  &#39;(((dd (?c c) (? v) <span class="dv">0</span>)</span>
<span id="cb17-3"><a href="#cb17-3"></a>    ((dd (?v v) (? v) <span class="dv">1</span>)</span>
<span id="cb17-4"><a href="#cb17-4"></a>    ((dd (?v u) (? v) <span class="dv">0</span>)</span>
<span id="cb17-5"><a href="#cb17-5"></a>    ((dd (<span class="op">+</span> (? x1) (? x2)) (? v))</span>
<span id="cb17-6"><a href="#cb17-6"></a>     (<span class="op">+</span> (dd (: x1) (: v))</span>
<span id="cb17-7"><a href="#cb17-7"></a>        (dd (: x2) (: v))))</span>
<span id="cb17-8"><a href="#cb17-8"></a>    ((dd (* (? x1) (? x2)) (? v))</span>
<span id="cb17-9"><a href="#cb17-9"></a>     (<span class="op">+</span> (* (: x1) (dd (: x2) (: v)))</span>
<span id="cb17-10"><a href="#cb17-10"></a>        (* (dd (: x1) (: v)) (: x2))))</span>
<span id="cb17-11"><a href="#cb17-11"></a>    ((dd (** (? x) (?c n)) (? v))</span>
<span id="cb17-12"><a href="#cb17-12"></a>     (* (* (: n)</span>
<span id="cb17-13"><a href="#cb17-13"></a>           (** *: x) (: (<span class="op">-</span> n <span class="dv">1</span>))))</span>
<span id="cb17-14"><a href="#cb17-14"></a>        (dd (: x) (: v))))))</span></code></pre></div>
<ul>
<li>It could be prettier, but that doesn’t matter. What matters is that we are writing rules directly in our language.</li>
<li><code>deriv-rules</code> is simply a list of rules.</li>
<li>Each rule is of the form <code>(LHS RHS)</code>. <code>LHS</code> is a pattern; <code>RHS</code> is a skeleton.</li>
<li>The forms beginning with question marks in the LHS are called <em>pattern variables</em>. We have invented them for our language.</li>
<li>The forms beginning with colons in the RHS are called <em>substitution objects</em>. They are skeleton evaluations.</li>
<li>Once we have this language, we can use it for many things. Here is an example, for algebraic simplification:</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb18-1"><a href="#cb18-1"></a>(<span class="ex">define</span><span class="fu"> algebra-rules</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>  &#39;((((? op) (?c e1) (?c e2))</span>
<span id="cb18-3"><a href="#cb18-3"></a>     (: (op e1 e2)))</span>
<span id="cb18-4"><a href="#cb18-4"></a>    (((? op) (? e1) (?c e2))</span>
<span id="cb18-5"><a href="#cb18-5"></a>     ((: op) (: e2) (: e1)))</span>
<span id="cb18-6"><a href="#cb18-6"></a>    ((<span class="op">+</span> <span class="dv">0</span> (? e)) (: e))</span>
<span id="cb18-7"><a href="#cb18-7"></a>    ((* <span class="dv">1</span> (? e)) (: e))</span>
<span id="cb18-8"><a href="#cb18-8"></a>    ((* <span class="dv">0</span> (? e)) <span class="dv">0</span>)))</span></code></pre></div>
<h3 id="syntax">Syntax</h3>
<h4 id="patterns">Patterns</h4>
<ul>
<li><code>foo</code> <em>matches</em> exactly <code>foo</code>.</li>
<li><code>(f a b)</code> <em>matches</em> a list of three elements with first, second, and third elements being <code>f</code>, <code>a</code>, and <code>b</code>, respectively.</li>
<li><code>(? x)</code> <em>matches</em> anything, and calls it <code>x</code>.</li>
<li><code>(?c x)</code> <em>matches</em> a constant, and calls it <code>x</code>.</li>
<li><code>(?v x)</code> <em>matches</em> a variable, and calls it <code>x</code>.</li>
</ul>
<h4 id="skeletons">Skeletons</h4>
<ul>
<li><code>foo</code> <em>instantiates</em> to exactly <code>foo</code>.</li>
<li><code>(f a b)</code> <em>instantiates</em> to a list of three elements, the results of instantiating each of <code>f</code>, <code>a</code>, and <code>b</code>.</li>
<li><code>(: x)</code> <em>instantiates</em> to the value of <code>x</code> in the pattern matched.</li>
</ul>
<h3 id="simplification-process">Simplification process</h3>
<ul>
<li>We can imagine the rules as a deck of cards, each one with a pattern and a skeleton.</li>
<li>The patterns feed into the matcher, and the skeletons feed into the instantiator.</li>
<li>The matcher passes a dictionary to the instantiator. This consists of the pattern variables and their matched values.</li>
<li>The output of the instantiator goes back into the matcher.</li>
<li>All of the rules must be tried on the expression, and on all its subexpressions. We can stop when it no longer changes.</li>
<li>If you don’t write your rules carefully, there is a danger of going into an infinite loop.</li>
</ul>
<h2 id="part-2-6">Part 2</h2>
<h3 id="matcher">Matcher</h3>
<ul>
<li>The matcher takes an expression, a pattern, and a pattern as input. It outputs another, augmented dictionary.</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb19-1"><a href="#cb19-1"></a>(<span class="ex">define</span><span class="fu"> </span>(match pat <span class="kw">exp</span> dict)</span>
<span id="cb19-2"><a href="#cb19-2"></a>  (<span class="kw">cond</span> ((<span class="kw">eq?</span> dict &#39;failed) &#39;failed)</span>
<span id="cb19-3"><a href="#cb19-3"></a>        ((atom? pat)</span>
<span id="cb19-4"><a href="#cb19-4"></a>         (<span class="kw">if</span> (<span class="kw">and</span> (atom? <span class="kw">exp</span>) (<span class="kw">eq?</span> pat <span class="kw">exp</span>))</span>
<span id="cb19-5"><a href="#cb19-5"></a>             dict</span>
<span id="cb19-6"><a href="#cb19-6"></a>             &#39;failed))</span>
<span id="cb19-7"><a href="#cb19-7"></a>        ((arbitrary-constant? pat)</span>
<span id="cb19-8"><a href="#cb19-8"></a>         (<span class="kw">if</span> (constant? <span class="kw">exp</span>)</span>
<span id="cb19-9"><a href="#cb19-9"></a>             (extend-dict pat <span class="kw">exp</span> dict)</span>
<span id="cb19-10"><a href="#cb19-10"></a>             &#39;failed))</span>
<span id="cb19-11"><a href="#cb19-11"></a>        ((arbitrary-variable? pat)</span>
<span id="cb19-12"><a href="#cb19-12"></a>         (<span class="kw">if</span> (variable? <span class="kw">exp</span>)</span>
<span id="cb19-13"><a href="#cb19-13"></a>             (extend-dict pat <span class="kw">exp</span> dict)</span>
<span id="cb19-14"><a href="#cb19-14"></a>             &#39;failed))</span>
<span id="cb19-15"><a href="#cb19-15"></a>        ((arbitrary-expression? pat)</span>
<span id="cb19-16"><a href="#cb19-16"></a>         (extend-dict pat <span class="kw">exp</span> dict))</span>
<span id="cb19-17"><a href="#cb19-17"></a>        ((atom? <span class="kw">exp</span>) &#39;failed)</span>
<span id="cb19-18"><a href="#cb19-18"></a>        (<span class="kw">else</span></span>
<span id="cb19-19"><a href="#cb19-19"></a>         (match (<span class="kw">cdr</span> pat)</span>
<span id="cb19-20"><a href="#cb19-20"></a>                (<span class="kw">cdr</span> <span class="kw">exp</span>)</span>
<span id="cb19-21"><a href="#cb19-21"></a>                (match (<span class="kw">car</span> pat)</span>
<span id="cb19-22"><a href="#cb19-22"></a>                       (<span class="kw">car</span> <span class="kw">exp</span>)</span>
<span id="cb19-23"><a href="#cb19-23"></a>                       dict)))))</span></code></pre></div>
<ul>
<li>The <code>else</code> clause recursion is very important.</li>
<li>We examine two trees simultaneously: the tree of the expression, and that of the pattern.</li>
<li>Consider this pattern: <code>(+ (* (? x) (? y)) (? y))</code>. We could draw this as a tree.</li>
<li>The expression matching it, <code>(+ (* 3 x)) x)</code>, has a very similar tree structure.</li>
<li>We want to traverse both trees simultaneously and compare them.</li>
<li>The matcher can fail at any point. The first clause checks this and propagates the failure. (This could be done more efficiently in continuation-passing style.)</li>
<li>If the pattern is an atom, we make sure the expression is the same atom.</li>
<li>If the pattern is an arbitrary expression variable like <code>(? x)</code>, we simply add the expression to the dictionary.</li>
<li>If it is an arbitrary constant or variable, we make sure it is the correct one before adding to the dictionary.</li>
</ul>
<h3 id="instantiator">Instantiator</h3>
<ul>
<li>The instantiator takes a dictionary and a skeleton as input and outputs an expression.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb20-1"><a href="#cb20-1"></a>(<span class="ex">define</span><span class="fu"> </span>(instantiate skeleton dict)</span>
<span id="cb20-2"><a href="#cb20-2"></a>  (<span class="ex">define</span><span class="fu"> </span>(loop s)</span>
<span id="cb20-3"><a href="#cb20-3"></a>    (<span class="kw">cond</span> ((atom? s) s)</span>
<span id="cb20-4"><a href="#cb20-4"></a>          ((skeleton-evaluation? s)</span>
<span id="cb20-5"><a href="#cb20-5"></a>           (evaluate (eval-exp s) dict))</span>
<span id="cb20-6"><a href="#cb20-6"></a>          (<span class="kw">else</span> (<span class="kw">cons</span> (loop (<span class="kw">car</span> s))</span>
<span id="cb20-7"><a href="#cb20-7"></a>                      (loop (<span class="kw">cdr</span> s))))))</span>
<span id="cb20-8"><a href="#cb20-8"></a>  (loop skeleton))</span></code></pre></div>
<ul>
<li>We do a recursive tree walk on the skeleton.</li>
<li>It is simpler than the matcher because the parts of the tree can be instantiated independently (we don’t change the dictionary).</li>
<li>The only reason we have the internal procedure is to avoid passing the same <code>dict</code> on every recursive call.</li>
<li>The skeleton evaluation forms like <code>(: x)</code> use <code>evaluate</code>:</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb21-1"><a href="#cb21-1"></a>(<span class="ex">define</span><span class="fu"> </span>(evaluate form dict)</span>
<span id="cb21-2"><a href="#cb21-2"></a>  (<span class="kw">if</span> (atom? form)</span>
<span id="cb21-3"><a href="#cb21-3"></a>      (lookup form dict)</span>
<span id="cb21-4"><a href="#cb21-4"></a>      (apply (<span class="kw">eval</span> (lookup (<span class="kw">car</span> form) dict)</span>
<span id="cb21-5"><a href="#cb21-5"></a>                   user-initial-environment)</span>
<span id="cb21-6"><a href="#cb21-6"></a>            (mapcar (<span class="kw">lambda</span> (v) (lookup v dict))</span>
<span id="cb21-7"><a href="#cb21-7"></a>                    (<span class="kw">cdr</span> form)))))</span></code></pre></div>
<ul>
<li>Atoms (variable names) are simply looked up in the dictionary.</li>
<li>For more complicated expressions, we lookup and evaluate the <code>car</code> of the form (the operator) and apply it to the result of looking up everything from the <code>cdr</code> (the operands).</li>
<li>This is magic. We don’t know everything going on with <code>apply</code> and <code>eval</code> yet. We will later.</li>
</ul>
<h2 id="part-3-4">Part 3</h2>
<h3 id="plan">Plan</h3>
<ul>
<li>We’ve seen the two halves of the rule system: the matcher and the instantiator.</li>
<li>Now we will create the control structure by which the rules are applied to the expressions.</li>
<li>We want to apply all of the rules to every node.</li>
<li>We call the basic idea <em>garbage in, garbage out</em> (GIGO).</li>
</ul>
<h3 id="simplifier">Simplifier</h3>
<ul>
<li>We want to be able to evaluate <code>(simplifier rules)</code> and get a procedure that simplifies expressions according to the rules:</li>
<li>For <code>deriv-rules</code>, this would be <code>(define dsimp (simplifier deriv-rules))</code>.</li>
<li>This is the <code>simplifier</code> procedure:</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb22-1"><a href="#cb22-1"></a>(<span class="ex">define</span><span class="fu"> </span>(simplifier the-rules)</span>
<span id="cb22-2"><a href="#cb22-2"></a>  (<span class="ex">define</span><span class="fu"> </span>(simplify-exp <span class="kw">exp</span>)</span>
<span id="cb22-3"><a href="#cb22-3"></a>    (try-rules (<span class="kw">if</span> (compound? <span class="kw">exp</span>)</span>
<span id="cb22-4"><a href="#cb22-4"></a>                   (simplify-parts <span class="kw">exp</span>)</span>
<span id="cb22-5"><a href="#cb22-5"></a>                   <span class="kw">exp</span>)))</span>
<span id="cb22-6"><a href="#cb22-6"></a>  (<span class="ex">define</span><span class="fu"> </span>(simplify-parts <span class="kw">exp</span>)</span>
<span id="cb22-7"><a href="#cb22-7"></a>    (<span class="kw">if</span> (<span class="kw">null?</span> <span class="kw">exp</span>)</span>
<span id="cb22-8"><a href="#cb22-8"></a>        &#39;()</span>
<span id="cb22-9"><a href="#cb22-9"></a>        (<span class="kw">cons</span> (simplify-exp (<span class="kw">car</span> <span class="kw">exp</span>))</span>
<span id="cb22-10"><a href="#cb22-10"></a>              (simplify-parts (<span class="kw">cdr</span> <span class="kw">exp</span>)))))</span>
<span id="cb22-11"><a href="#cb22-11"></a>  (<span class="ex">define</span><span class="fu"> </span>(try-rules <span class="kw">exp</span>)</span>
<span id="cb22-12"><a href="#cb22-12"></a>    (<span class="ex">define</span><span class="fu"> </span>(scan rules)</span>
<span id="cb22-13"><a href="#cb22-13"></a>      (<span class="kw">if</span> (<span class="kw">null?</span> rules)</span>
<span id="cb22-14"><a href="#cb22-14"></a>          <span class="kw">exp</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>          (<span class="kw">let</span> ((dict (match (pattern (<span class="kw">car</span> rules))</span>
<span id="cb22-16"><a href="#cb22-16"></a>                             <span class="kw">exp</span></span>
<span id="cb22-17"><a href="#cb22-17"></a>                             (empty-dictionary))))</span>
<span id="cb22-18"><a href="#cb22-18"></a>            (<span class="kw">if</span> (<span class="kw">eq?</span> dict &#39;failed)</span>
<span id="cb22-19"><a href="#cb22-19"></a>                (scan (<span class="kw">cdr</span> rules))</span>
<span id="cb22-20"><a href="#cb22-20"></a>                (simplify-exp</span>
<span id="cb22-21"><a href="#cb22-21"></a>                  (instantiate (skeleton (<span class="kw">car</span> rules))</span>
<span id="cb22-22"><a href="#cb22-22"></a>                               dict))))))</span>
<span id="cb22-23"><a href="#cb22-23"></a>    (scan the-rules))</span>
<span id="cb22-24"><a href="#cb22-24"></a>  simplify-exp)</span></code></pre></div>
<ul>
<li>The procedures <code>simplify-exp</code> and <code>simplify-parts</code> call each other recursively.</li>
<li>Since the <code>exp</code> in <code>simplify-exp</code> can be either atomic or compound, this naturally recurses through a tree of expressions.</li>
<li>We could have just used one procedure, using <code>map</code>:</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb23-1"><a href="#cb23-1"></a>(<span class="ex">define</span><span class="fu"> </span>(simplify-exp <span class="kw">exp</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a>  (try-rules</span>
<span id="cb23-3"><a href="#cb23-3"></a>    (<span class="kw">if</span> (compound? <span class="kw">exp</span>)</span>
<span id="cb23-4"><a href="#cb23-4"></a>        (map simplify-exp <span class="kw">exp</span>)</span>
<span id="cb23-5"><a href="#cb23-5"></a>        <span class="kw">exp</span>)))</span></code></pre></div>
<ul>
<li>This is a different idiom; it works the same way, but you think about it a bit differently.</li>
<li>It is better because otherwise we are basically reinventing the wheel by hiding a definition of <code>map</code> in one of our procedures. It is best to extract those common patterns.</li>
<li>The <code>try-rules</code> procedure scans the rules and tries each one. It returns the original expression if none matched.</li>
<li>When a rule’s pattern matches, <code>try-rules</code> instantiates the skeleton and tries to simplify that further.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<ul>
<li>The pattern of recursions here is very complicated.</li>
<li>We shouldn’t try to think about it all at once. Instead, we make a modular system where we can focus on one part at a time.</li>
<li>As long as we know what a procedure application is supposed to do, we can use it without thinking how it will work.</li>
</ul>
<blockquote>
<p>The key to very good programming, and very good design, is to know what not to think about.</p>
</blockquote>
<h3 id="dictionaries">Dictionaries</h3>
<ul>
<li>The implementation of the dictionary is pretty simple:</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb24-1"><a href="#cb24-1"></a>(<span class="ex">define</span><span class="fu"> </span>(empty-dictionary) &#39;())</span>
<span id="cb24-2"><a href="#cb24-2"></a>(<span class="ex">define</span><span class="fu"> </span>(extend-dictionary pat dat dict)</span>
<span id="cb24-3"><a href="#cb24-3"></a>  (<span class="kw">let</span> ((name (variable-name pat)))</span>
<span id="cb24-4"><a href="#cb24-4"></a>    (<span class="kw">let</span> ((v ((<span class="kw">assq</span> name dict)))</span>
<span id="cb24-5"><a href="#cb24-5"></a>      (<span class="kw">cond</span> ((<span class="kw">null?</span> v)</span>
<span id="cb24-6"><a href="#cb24-6"></a>             (<span class="kw">cons</span> (<span class="kw">list</span> name dat) dict))</span>
<span id="cb24-7"><a href="#cb24-7"></a>            ((<span class="kw">eq?</span> (<span class="kw">cadr</span> v) dat) dict)</span>
<span id="cb24-8"><a href="#cb24-8"></a>            (<span class="kw">else</span> &#39;failed)))))</span>
<span id="cb24-9"><a href="#cb24-9"></a>(<span class="ex">define</span><span class="fu"> </span>(lookup var dict)</span>
<span id="cb24-10"><a href="#cb24-10"></a>  (<span class="kw">let</span> ((v (<span class="kw">assq</span> var dict)))</span>
<span id="cb24-11"><a href="#cb24-11"></a>    (<span class="kw">if</span> (<span class="kw">null?</span> v) var (<span class="kw">cadr</span> v))))</span></code></pre></div>
<ul>
<li>When extending the dictionary, we check if the name is already present in the dictionary.</li>
<li>If not, we add it. If it is, but has the same value, we return the dictionary unchanged.</li>
<li>If we are trying to give it a different value, we fail.</li>
</ul>
<h1 id="b-generic-operators">4B: Generic Operators</h1>
<h2 id="part-1-7">Part 1</h2>
<h3 id="limits-of-data-abstraction">Limits of data abstraction</h3>
<ul>
<li>So far, we’ve talked a lot about data abstraction.</li>
<li>We’ve had these horizontal abstract barriers that separate use from representation.</li>
<li>This is powerful, but not sufficient for really complex systems.</li>
<li>The problem is that sometimes we to use need multiple, incompatible representations.</li>
<li>We want some kind of vertical barrier in addition to the horizontal barriers.</li>
<li>We want <em>generic operators</em>. What these operators precisely do depends on the data format it is looking at.</li>
<li>It should be easy to add new data types to the system, so that the generic operators work on them, too, with minimal changes.</li>
</ul>
<h3 id="complex-number-arithmetic">Complex number arithmetic</h3>
<ul>
<li>We can represent a complex number in two ways:
<ul>
<li>real part and imaginary part (rectangular form);</li>
<li>magnitude and angle (polar form).</li>
</ul></li>
<li>The rectangular form <span class="math inline">x + iy</span> and the polar form <span class="math inline">re^{i\theta}</span> are related:
<ul>
<li><span class="math inline">x = r\cos\theta</span> and <span class="math inline">y = r\sin\theta</span>.</li>
<li><span class="math inline">r = \sqrt{x^2 + y^2}</span> and <span class="math inline">\theta = \arctan(y,x)</span>.</li>
</ul></li>
<li>We add complex numbers in rectangular form by adding the real parts and imaginary parts in parallel.</li>
<li>We multiply complex numbers in polar form by multiplying the magnitudes and adding the angles.</li>
</ul>
<h3 id="incompatible-representations">Incompatible representations</h3>
<ul>
<li>We could expose rectangular and polar functions but still use on particular representation under the hood. This isn’t really new.</li>
<li>What if we want <em>both</em> representations? Data abstraction allows us to postpone the representation decision, but we don’t want to make a decision at all!</li>
<li>We need a vertical barrier between rectangular and polar forms.</li>
<li>The selectors for complex numbers – <code>real-part</code>, <code>imag-part</code>, <code>magnitude</code>, and <code>angle</code> – must be generic operators.</li>
<li>For this to work, we need <em>typed data</em>. We need to tag our data objects with labels telling us the type of their contents.</li>
<li>We can simply <code>cons</code> the symbol <code>'rectangular</code> or <code>'polar</code> to the complex number data.</li>
<li>The generic procedures check the type of their argument, strip off the type information, and dispatch the contents to the appropriate specific procedure.</li>
</ul>
<h2 id="part-2-7">Part 2</h2>
<h3 id="problems-with-the-manager">Problems with the manager</h3>
<ul>
<li>The strategy we just looked at is called <em>dispatch on type</em>.</li>
<li>One annoyance is that we had to change the names of the specific procedures (adding a suffix) to avoid naming conflicts.</li>
<li>We’ll talk about namespaces to fix that problem later.</li>
<li>What happens when you add a new type to the system?
<ul>
<li>The other types don’t care. They can remain the same.</li>
<li>The manager needs to add a new clause to every generic procedure that should be able to work with the new type.</li>
<li>This is annoying because the generic procedure case analyses are very repetitive.</li>
</ul></li>
</ul>
<h3 id="data-directed-programming">Data-directed programming</h3>
<ul>
<li>Our system has a table with types on the horizontal axis and operators on the vertical axis.</li>
<li>Instead of writing these generic procedures manually, we should just use a table directly.</li>
<li>We introduce two new procedures: <code>(put key1 key2 value)</code> and <code>(get key1 key2)</code>. This is a map, or associative list.</li>
<li>Now we just need to use <code>put</code> to insert our specific procedures into the table, and the rest will be automated.</li>
<li>We wouldn’t even have to name our procedures – we could just pass a lambda expression as the last argument.</li>
<li>It is the procedures that go in the table, not their names.</li>
<li>The key procedure in this whole system is <code>operate</code>:</li>
</ul>
<div class="sourceCode" id="cb25"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb25-1"><a href="#cb25-1"></a>(<span class="ex">define</span><span class="fu"> </span>(operate op obj)</span>
<span id="cb25-2"><a href="#cb25-2"></a>  (<span class="kw">let</span> ((proc (get (type obj) op)))</span>
<span id="cb25-3"><a href="#cb25-3"></a>    (<span class="kw">if</span> (<span class="kw">null?</span> proc)</span>
<span id="cb25-4"><a href="#cb25-4"></a>        (error <span class="st">&quot;undefined OP&quot;</span>)</span>
<span id="cb25-5"><a href="#cb25-5"></a>        (proc (contents obj)))))</span></code></pre></div>
<ul>
<li>This uses the table to look up the correct procedure, and applies it to the given object.</li>
<li>This is what happens when we try to extract the real part of a complex number in polar form:</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb26-1"><a href="#cb26-1"></a>(<span class="kw">real-part</span> z)</span>
<span id="cb26-2"><a href="#cb26-2"></a>(operate &#39;real-part z)</span>
<span id="cb26-3"><a href="#cb26-3"></a>((get &#39;polar &#39;real-part) (contents z))</span>
<span id="cb26-4"><a href="#cb26-4"></a>(real-part-polar &#39;(<span class="dv">1</span> . <span class="dv">2</span>))</span>
<span id="cb26-5"><a href="#cb26-5"></a>(* <span class="dv">1</span> (<span class="kw">cos</span> <span class="dv">2</span>))</span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="fl">-0.4161468365</span></span></code></pre></div>
<ul>
<li>This style of programming called <em>data-directed</em> programming.</li>
<li>The data objects themselves are carrying the information about how you should operate on them.</li>
</ul>
<h2 id="part-3-5">Part 3</h2>
<h3 id="generic-arithmetic-system">Generic arithmetic system</h3>
<ul>
<li>We just looked at data-directed programming for complex numbers.</li>
<li>The power of the methodology only becomes apparent when you embed this in a more complex system.</li>
<li>Let’s consider a generic arithmetic system with operations <code>add</code>, <code>sub</code>, <code>mil</code>, and <code>div</code>.</li>
<li>This should sit on top of ordinary Lisp numbers, rationals, and complex numbers.</li>
<li>We already made a rational number package; we just need to change the constructor <code>make-rat</code> so that it attaches the tag <code>'rational</code> to the data.</li>
<li>We can’t use <code>operate</code> anymore because that was designed for a single argument. <code>apply-generic</code> from SICP is better.</li>
<li>Now, our complex numbers will have two labels on them: <code>'complex</code> <em>and</em> either <code>'rectangular</code> or <code>'polar</code>.</li>
<li>At each level, we strip off a type tag and pass the data down to the level beneath. The chain of types leads you down.</li>
</ul>
<h3 id="polynomials">Polynomials</h3>
<ul>
<li>We could also add polynomials to the generic arithmetic system.</li>
<li>Our polynomials will have a variable (symbol) and a term list (list of ordered pairs).</li>
<li>We can add polynomials in the same variable by adding their term lists (collecting like terms).</li>
<li>By using <code>add</code> when we add term lists, we can use <em>any</em> kind of numbers as a coefficients, for free!</li>
<li>This includes polynomials whose coefficients are polynomials.</li>
<li>All because we wrote <code>add</code> instead of <code>+</code>, we have this recursive tower of types: the coefficients can be polynomials all the way down, or as far as we’d like.</li>
<li>If we use the generic arithmetic procedures in the rational number package, we can get rational functions (polynomials over polynomials) for free as well.</li>
</ul>
<h3 id="conclusion-2">Conclusion</h3>
<ul>
<li>We built a system that has decentralized control.</li>
<li>We don’t have to worry about how operations are actually performed.</li>
<li>This lets us build this complex hierarchy where all the operations sort of do the right thing automatically.</li>
<li>The true complexity comes in with <em>coercion</em> – when you add a complex and a rational, who worries about converting what?</li>
</ul>
<h1 id="a-assignment-state-and-side-effects">5A: Assignment, State, and Side-effects</h1>
<h2 id="part-1-8">Part 1</h2>
<h3 id="introducing-assignment">Introducing assignment</h3>
<ul>
<li>We’ve learned enough about programming in Lisp to do fairly complex things.</li>
<li>We have done all of this without an assignment statement.</li>
<li>Today, we’re going to add the assignment statement.</li>
<li>If we can do so much without it, why should we add it?</li>
<li>After all, we only add something to the language if we have a good reason for doing so.</li>
<li>We are adding assignment because it will allow us to break some problems up into certain sets of pieces, and this new means of decomposition would be impossible without assignment.</li>
</ul>
<h3 id="functional-programming">Functional programming</h3>
<ul>
<li>Functional programs encode mathematical truths.</li>
<li>Processes evolved by these programs can be understood by substitution, which preserves truth (equals for equals).</li>
<li>Methods may be distinguished by the choice of truths expressed.</li>
<li>Although functional, Lisp is not quite the same as math. Math is declarative, but Lisp is imperative.</li>
</ul>
<h3 id="assignment-and-time">Assignment and Time</h3>
<ul>
<li>To do assignment, we use <code>(set! &lt;variable&gt; &lt;value&gt;)</code>.</li>
<li>By convention, we suffix a bang to the names of procedures that do assignment-like things.</li>
<li><code>set!</code> is like <code>define</code>, but the latter is only used once to create the variable in the beginning; the former can only be used on existing variables.</li>
<li>When we add assignment, we also have to consider <em>time</em>.</li>
<li>The assignment produces a moment in time: a difference between a <em>before</em> and an <em>after</em> in time.</li>
<li>After the moment, <code>&lt;variable&gt;</code> has the value <code>&lt;value&gt;</code>, independent of what value it had before.</li>
<li>So far, calling procedures with the same inputs always produced the same outputs. These procedures are functions.</li>
<li>This isn’t the case when we have assignment. The same expression can lead to different answers because it depends on time.</li>
<li>The substitution model completely breaks down. It is static.</li>
<li>We need a new model of computation for this “bad thing.” We had better have a good reason for introducing assignment.</li>
</ul>
<h3 id="identity">Identity</h3>
<ul>
<li>Symbols for variables no longer refer directly to their values, but to some <em>place</em>.</li>
<li>A variable now refers to an <em>identity</em>. This is an entity associated with a series of causally related values over time.</li>
<li>The state of an identity is it’s current associated value.</li>
<li>When we talk about <em>time</em>, we mean the before/after ordering of causal values.</li>
</ul>
<h3 id="factorial-example">Factorial example</h3>
<ul>
<li>Here’s how we implemented factorial functionally:</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb27-1"><a href="#cb27-1"></a>(<span class="ex">define</span><span class="fu"> </span>(fact n)</span>
<span id="cb27-2"><a href="#cb27-2"></a>  (<span class="ex">define</span><span class="fu"> </span>(iter p i)</span>
<span id="cb27-3"><a href="#cb27-3"></a>    (<span class="kw">if</span> (<span class="op">&gt;</span> i n) m (iter (* i p) (<span class="op">+</span> i <span class="dv">1</span>))))</span>
<span id="cb27-4"><a href="#cb27-4"></a>  (iter <span class="dv">1</span> <span class="dv">1</span>))</span></code></pre></div>
<ul>
<li>We could instead write it with assignments:</li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb28-1"><a href="#cb28-1"></a>(<span class="ex">define</span><span class="fu"> </span>(fact n)</span>
<span id="cb28-2"><a href="#cb28-2"></a>  (<span class="kw">let</span> ((p <span class="dv">1</span>) (i <span class="dv">1</span>))</span>
<span id="cb28-3"><a href="#cb28-3"></a>    (<span class="ex">define</span><span class="fu"> </span>(loop)</span>
<span id="cb28-4"><a href="#cb28-4"></a>      (<span class="kw">cond</span> ((<span class="op">&gt;</span> i n) p)</span>
<span id="cb28-5"><a href="#cb28-5"></a>            (<span class="kw">else</span> (set! p (* i p))</span>
<span id="cb28-6"><a href="#cb28-6"></a>                  (set! i (<span class="op">+</span> i <span class="dv">1</span>))</span>
<span id="cb28-7"><a href="#cb28-7"></a>                  (loop))))</span>
<span id="cb28-8"><a href="#cb28-8"></a>    (loop)))</span></code></pre></div>
<ul>
<li>There are ways of making errors in the second program that simply didn’t exist when we couldn’t do assignment.</li>
<li>If we change the ordering of the assignments, the procedure calculates the wrong value.</li>
</ul>
<h2 id="part-2-8">Part 2</h2>
<h3 id="environment-model">Environment model</h3>
<ul>
<li>We need a new model of computation that can allow us to understand programs that use assignment.</li>
<li>The new model is called the <em>environment model</em>.</li>
<li>Unfortunately, it is significantly more complicated than the substitution model.</li>
</ul>
<h3 id="free-and-bound-variables">Free and bound variables</h3>
<ul>
<li>A variable <code>v</code> is <em>bound</em> in an expression <code>E</code> if the meaning of <code>E</code> is unchanged by the uniform replacement of a variable <code>w</code> not occurring in <code>E</code>, for every occurrence of <code>v</code> in <code>E</code>.</li>
<li>We use bound variables all the time.</li>
<li>The <code>lambda</code> is the essential thing that binds variables.</li>
<li>If a variable isn’t bound, we say it is a <em>free</em> variable.</li>
<li>If <code>x</code> is a bound variable in <code>E</code> then there is λ-expression where it is bound.</li>
<li>The list of formal parameters is called the <em>bound variable list</em>. The λ-expression <em>binds</em> the variables <em>declared</em> in its bound variable list.</li>
<li>The parts of the expression where a variable has a value defined by the λ-expression binding it is the <em>scope</em> of the variable.</li>
</ul>
<h3 id="environments-frames-and-bindings">Environments, frames, and bindings</h3>
<ul>
<li>Environments are a way of doing substitutions virtually.</li>
<li>It’s the place where the names of the variables are associated with values.</li>
<li>An environment is a pointer to a <em>frame</em>. A frame is a table of <em>bindings</em>, plus a parent/enclosing environment.</li>
<li>A binding is a variable name associated with a value.</li>
<li>We look up the value of a variable in an environment by traversing up the frames, finding the first one that has a binding for the variable, and reading its associated value.</li>
<li>If a variable is bound twice in an environment, the binding in the earlier (lower) frame <em>shadows</em> the other.</li>
</ul>
<h3 id="procedure-creation-and-application">Procedure creation and application</h3>
<ul>
<li>A procedure is a pair: some code, and (a pointer to) an environment. Free variables are found in this environment.</li>
<li>Procedure objects are created by evaluating λ-expressions.</li>
<li>A λ-expression is evaluated relative to a given environment as follows: a new procedure object is formed, combing the text (code) of the λ-expression with (a pointer to) the environment of evaluation.</li>
<li>A procedure is applied to a set of arguments by
<ol type="1">
<li>constructing a frame whose parent is the environment part of the procedure being applied,</li>
<li>binding the formal parameters of the procedure to the actual arguments of the call,</li>
<li>evaluating the body of the procedure in the context of the new environment.</li>
</ol></li>
<li>In other words we are taking the environment where the procedure was created, extending it with the frame for the parameters, and evaluating the body.</li>
</ul>
<h2 id="part-3-6">Part 3</h2>
<h3 id="counter-example">Counter example</h3>
<ul>
<li>We’ve introduced a very complicated thing, assignment, which destroys most of the interesting mathematical properties of our programs.</li>
<li>We wouldn’t have done this if there wasn’t a good reason.</li>
<li>Consider the following program:</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb29-1"><a href="#cb29-1"></a>(<span class="ex">define</span><span class="fu"> make-counter</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>  (<span class="kw">lambda</span> (n)</span>
<span id="cb29-3"><a href="#cb29-3"></a>    (<span class="kw">lambda</span> ()</span>
<span id="cb29-4"><a href="#cb29-4"></a>      (set! n (inc n))</span>
<span id="cb29-5"><a href="#cb29-5"></a>      n)))</span>
<span id="cb29-6"><a href="#cb29-6"></a>(<span class="ex">define</span><span class="fu"> c1 </span>(make-counter <span class="dv">0</span>))</span>
<span id="cb29-7"><a href="#cb29-7"></a>(<span class="ex">define</span><span class="fu"> c2 </span>(make-counter <span class="dv">10</span>))</span>
<span id="cb29-8"><a href="#cb29-8"></a>(c1)</span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="dv">1</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>(c1)</span>
<span id="cb29-11"><a href="#cb29-11"></a><span class="dv">2</span></span>
<span id="cb29-12"><a href="#cb29-12"></a>(c2)</span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="dv">11</span></span>
<span id="cb29-14"><a href="#cb29-14"></a>(c2)</span>
<span id="cb29-15"><a href="#cb29-15"></a><span class="dv">12</span></span></code></pre></div>
<ul>
<li>These two counters are independent and have their own state.</li>
<li>The environment of <code>c1</code> points to some frame with <code>n</code>. That of <code>c2</code> points to a different frame with a different <code>n</code>. The parent of both frames is the global environment.</li>
<li>The <em>global environment</em> is the topmost environment. Its frame contains <code>car</code>, <code>+</code>, <code>*</code>, etc., and all top-level definitions.</li>
</ul>
<h3 id="objects">Objects</h3>
<ul>
<li>We like to think about the world as being made up of independent objects, each having their own state.</li>
<li>The only way to see if two objects are the same (not just associated with an equal value) is to change one and see if the other changes in the same way.</li>
<li>The idea of objects, changed, and sameness raises deep problems.</li>
<li>If you cut off your fingernail, the “before” and “after” of you is enormously different in terms of atoms. You have changed and feel that you are the “same” person, but how do you know that?</li>
<li>By introducing assignment and therefore objects, we open ourselves up to all of these philosophical questions.</li>
</ul>
<h3 id="actions-and-identity">Actions and identity</h3>
<ul>
<li>An action <span class="math inline">A</span> had an effect on an object <span class="math inline">x</span> (or equivalently, that <span class="math inline">x</span> was changed by <span class="math inline">A</span>) if some property <span class="math inline">P</span> which was true of <span class="math inline">x</span> before <span class="math inline">A</span> became false of <span class="math inline">x</span> after <span class="math inline">A</span>.</li>
<li>Two objects <span class="math inline">x</span> and <span class="math inline">y</span> are the same if any action which has an effect on <span class="math inline">x</span> has the same effect on <span class="math inline">y</span>.</li>
</ul>
<h3 id="uses-of-objection-orientation">Uses of objection orientation</h3>
<ul>
<li>One of the nice things about objects is the way it lets us model the world. We like to think of the world as being made up of these independent objects.</li>
<li>If we want to understand the program well and we want small changes in the world to lead to small changes in the program, we would like isomorphisms between the world and the model.</li>
<li>For most things, objects and assignment are not the right way to think. We should only use them if we need them.</li>
<li>Sometimes, though, they are essential.</li>
<li>It can also improve modularity greatly – consider the procedure for a random number generator. Without an internal feedback loop via assignment, its state leaks out everywhere and we can’t decompose certain problems very well.</li>
</ul>
<h1 id="b-computational-objects">5B: Computational Objects</h1>
<h2 id="part-1-9">Part 1</h2>
<h3 id="recap-4">Recap</h3>
<ul>
<li>We’re going to do some complicated programming to illustrate what you can do with mutable state.</li>
<li>We were motivated by the need to model physical systems.</li>
<li>Programming this way buys us modularity, if done correctly.</li>
</ul>
<h3 id="electrical-systems">Electrical systems</h3>
<ul>
<li>We are going to model electrical systems.</li>
<li>We can consider the things wires are connected to as objects.</li>
<li>The connections can be made abstract. We use ideal wires.</li>
<li>We create wires with <code>(make-wire)</code>, and we connect them with gates: <code>and-gate</code>, <code>or-gate</code>, and <code>inverter</code>.</li>
<li><code>(inverter a b)</code> connects wires <code>a</code> and <code>b</code> with an inverter.</li>
<li>Our language will be embedded in Lisp, like the Henderson picture language.</li>
<li>We can wire up half adders and full adders with these gates.</li>
<li>We have primitives (wires), means of combination (gates), and means of abstraction (lambda). Lambda is the ultimate glue.</li>
</ul>
<h3 id="implementing-the-primitives">Implementing the primitives</h3>
<ul>
<li>All we have to do is implement the primitives. The rest is free.</li>
<li>An inverter works by adding an action to its input wire. When a new signal arrives, this action delays and then sets the signal of its output wire to the logical-not of its input signal.</li>
<li>And-gates and or-gates are implemented similarly. The action must be added to both input wires.</li>
<li>Each wires must remember its signals and its list of actions.</li>
<li>The actions procedures need to keep references to their wires. These are captured by the lambda inside the gate procedures.</li>
<li>We implement wires with the message-passing style. It responds to <code>get-signal</code>, <code>set-signal!</code>, and <code>add-action!</code>.</li>
<li>The wire executes all actions after its signal is set.</li>
</ul>
<h3 id="scheduling-delayed-tasks">Scheduling delayed tasks</h3>
<ul>
<li>The agenda is a schedule of actions to run. Whenever <code>after-delay</code> is used in an action, a task is added to the agenda.</li>
<li>These get executed in the proper order, with a time variable maintaining the correct time.</li>
<li>The <code>propagate</code> procedure executers everything the agenda, emptying it as it goes.</li>
</ul>
<h2 id="part-2-9">Part 2</h2>
<h3 id="implementing-the-agenda">Implementing the agenda</h3>
<ul>
<li>We’ve made a simulation where objects and state changed in the computer match the objects and state changes in the world.</li>
<li>We’re going to use agendas (priority queues) to organize time.</li>
<li>We have a constructor <code>make-agenda</code>; selector <code>current-time</code> and <code>first-item</code>; predicate <code>empty-agenda?</code>; and mutators <code>add-to-agenda!</code> and <code>remove-first-item!</code>.</li>
<li>We will represent it as a list a segments. Each segment is a time <code>cons</code> ed to a queue of tasks (procedures of no arguments).</li>
<li>To add a task, we either add it to the queue of the appropriate segment, or create a new segment with that time.</li>
</ul>
<h4 id="queues">Queues</h4>
<ul>
<li>We construct queues with <code>(make-queue)</code>.</li>
<li>There are two mutators, <code>(insert-queue! q x)</code> and <code>(delete-queue! q)</code>; a selector, <code>(front-queue q)</code>; and a predicate, <code>(empty-queue? q)</code>.</li>
<li>A queue is represented as a front pointer of a list <code>cons</code> ed to the rear pointer of the same list.</li>
<li>The mutators use <code>set-car!</code> and <code>set-cdr!</code>.</li>
</ul>
<h2 id="part-3-7">Part 3</h2>
<h3 id="identity-of-pairs">Identity of pairs</h3>
<ul>
<li>Before, all we needed to know about <code>cons</code> was that for all values of <code>x</code> and <code>y</code>, <code>(= x (car (cons x y)))</code> and <code>(= y (cdr (cons x y)))</code>. This says nothing about identity.</li>
<li>These no longer tell the whole story, now that we have mutators.</li>
<li>This raises a question: if you change the <code>car</code> of a pair, do all pairs that look the same also change?</li>
<li>Cons pairs now have an identity.</li>
<li>When we have multiple names for the same object, they are called <em>aliases</em>. Changing one changes them all.</li>
<li>Sometimes sharing is what we want. But inadvertent sharing is a great source of bugs in complicated programs.</li>
</ul>
<h3 id="lambda-calculus">Lambda calculus</h3>
<ul>
<li>Assignment and mutators are equally powerful. We can implement the cons mutators in terms of <code>set!</code>.</li>
<li>We’ve already seen Alonzo Church’s way of creating pairs just with lambda expressions:</li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb30-1"><a href="#cb30-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cons</span> x y)</span>
<span id="cb30-2"><a href="#cb30-2"></a>  (<span class="kw">lambda</span> (m)</span>
<span id="cb30-3"><a href="#cb30-3"></a>    (m x y)))</span>
<span id="cb30-4"><a href="#cb30-4"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">car</span> x) (x (<span class="kw">lambda</span> (a d) a)))</span>
<span id="cb30-5"><a href="#cb30-5"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cdr</span> x) (x (<span class="kw">lambda</span> (a d) d)))</span></code></pre></div>
<ul>
<li>We can change it to allow mutation:</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb31-1"><a href="#cb31-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cons</span> x y)</span>
<span id="cb31-2"><a href="#cb31-2"></a>  (<span class="kw">lambda</span> (m)</span>
<span id="cb31-3"><a href="#cb31-3"></a>    (m x</span>
<span id="cb31-4"><a href="#cb31-4"></a>       y</span>
<span id="cb31-5"><a href="#cb31-5"></a>       (<span class="kw">lambda</span> (n) (set! x n))</span>
<span id="cb31-6"><a href="#cb31-6"></a>       (<span class="kw">lambda</span> (n) (set! y n)))))</span>
<span id="cb31-7"><a href="#cb31-7"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">car</span> x)</span>
<span id="cb31-8"><a href="#cb31-8"></a>  (x (<span class="kw">lambda</span> (a d sa sd) a)))</span>
<span id="cb31-9"><a href="#cb31-9"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">cdr</span> x)</span>
<span id="cb31-10"><a href="#cb31-10"></a>  (x (<span class="kw">lambda</span> (a d sa sd) d)))</span>
<span id="cb31-11"><a href="#cb31-11"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">set-car!</span> x v)</span>
<span id="cb31-12"><a href="#cb31-12"></a>  (x (<span class="kw">lambda</span> (a d sa sd) (sa v))))</span>
<span id="cb31-13"><a href="#cb31-13"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="kw">set-cdr!</span> x v)</span>
<span id="cb31-14"><a href="#cb31-14"></a>  (x (<span class="kw">lambda</span> (a d sa sd) (sd v))))</span></code></pre></div>
<ul>
<li>(I just realized that creating objects this way, where you apply the object to a procedure that is passed all the state variables, is just like pattern matching.)</li>
</ul>
<h1 id="a-streams-part-1">6A: Streams, Part 1</h1>
<h2 id="part-1-10">Part 1</h2>
<h3 id="recap-5">Recap</h3>
<ul>
<li>We’ve learned about assignment and its frightening implications.</li>
<li>The substitution model of evaluation breaks down; we have to use the much more complicated environment model.</li>
<li>Worry about: assignment, state, change, time, identity, objects, sharing.</li>
<li>Suddenly a variable doesn’t just stand for a value; it specifies a place that holds a value.</li>
<li>Our goal was <em>modularity</em>, writing programs that mirror reality.</li>
<li>Maybe we have the wrong view of reality; maybe time is an illusion and nothing changes.</li>
</ul>
<h3 id="motivation">Motivation</h3>
<ul>
<li>We’re going to look at another way to decompose systems: <em>stream processing</em>.</li>
<li>Consider summing the odd squares in a binary tree of integers:</li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb32-1"><a href="#cb32-1"></a>(<span class="ex">define</span><span class="fu"> </span>(sum-odd-squares tree)</span>
<span id="cb32-2"><a href="#cb32-2"></a>  (<span class="kw">if</span> (leaf-node? tree)</span>
<span id="cb32-3"><a href="#cb32-3"></a>      (<span class="kw">if</span> (<span class="kw">odd?</span> tree)</span>
<span id="cb32-4"><a href="#cb32-4"></a>          (square tree)</span>
<span id="cb32-5"><a href="#cb32-5"></a>          <span class="dv">0</span>)</span>
<span id="cb32-6"><a href="#cb32-6"></a>      (<span class="op">+</span> (sum-odd-squares (left-branch tree))</span>
<span id="cb32-7"><a href="#cb32-7"></a>         (sum-odd-squares (right-branch tree)))))</span></code></pre></div>
<ul>
<li>And contrast with collecting the odd Fibonacci numbers:</li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb33-1"><a href="#cb33-1"></a>(<span class="ex">define</span><span class="fu"> </span>(odd-fibs n)</span>
<span id="cb33-2"><a href="#cb33-2"></a>  (<span class="ex">define</span><span class="fu"> </span>(next k)</span>
<span id="cb33-3"><a href="#cb33-3"></a>    (<span class="kw">if</span> (<span class="op">&gt;</span> k n)</span>
<span id="cb33-4"><a href="#cb33-4"></a>        &#39;()</span>
<span id="cb33-5"><a href="#cb33-5"></a>        (<span class="kw">let</span> ((f (fib k)))</span>
<span id="cb33-6"><a href="#cb33-6"></a>          (<span class="kw">if</span> (<span class="kw">odd?</span> f)</span>
<span id="cb33-7"><a href="#cb33-7"></a>              (<span class="kw">cons</span> f (next (<span class="dv">1</span>+ k)))</span>
<span id="cb33-8"><a href="#cb33-8"></a>              (next (<span class="dv">1</span>+ k))))))</span>
<span id="cb33-9"><a href="#cb33-9"></a>  (next <span class="dv">1</span>))</span></code></pre></div>
<ul>
<li>1st procedure: enumerate leaves → filter <code>odd?</code> → map <code>square</code> → accumulate <code>+</code>, 0.</li>
<li>2nd procedure: enumerate interval → map <code>fib</code> → filter <code>odd?</code> → accumulate <code>cons</code>, <code>'()</code>.</li>
<li>These are similar, but the commonality is obscured by how we wrote the procedures.</li>
</ul>
<blockquote>
<p>Going back to this fundamental principle of computer science that in order to control something you need the name of it.</p>
</blockquote>
<h3 id="defining-streams">Defining streams</h3>
<ul>
<li>The arrows between the boxes represent data structures called <em>streams</em>.</li>
<li><code>(cons-stream x y)</code> and <code>the-empty-stream</code> construct streams.</li>
<li>For any <code>x</code> and <code>y</code>, <code>(head (cons-stream x y))</code> is <code>x</code>.</li>
<li>For any <code>x</code> and <code>y</code>, <code>(tail (cons-stream x y))</code> is <code>y</code>.</li>
<li>We can define higher-order procedures like we did for lists:</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb34-1"><a href="#cb34-1"></a>(<span class="ex">define</span><span class="fu"> </span>(map-stream proc s)</span>
<span id="cb34-2"><a href="#cb34-2"></a>  (<span class="kw">if</span> (empty-stream? s)</span>
<span id="cb34-3"><a href="#cb34-3"></a>      the-empty-stream</span>
<span id="cb34-4"><a href="#cb34-4"></a>      (cons-stream (proc (head s))</span>
<span id="cb34-5"><a href="#cb34-5"></a>                   (map-stream proc (tail se)))))</span></code></pre></div>
<h3 id="using-the-language">Using the language</h3>
<ul>
<li>Now we can reimplement those problems with explicit stream processing:</li>
</ul>
<div class="sourceCode" id="cb35"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb35-1"><a href="#cb35-1"></a>(<span class="ex">define</span><span class="fu"> </span>(sum-odd-squares tree)</span>
<span id="cb35-2"><a href="#cb35-2"></a>  (accumulate <span class="op">+</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>              <span class="dv">0</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>              (map square</span>
<span id="cb35-5"><a href="#cb35-5"></a>                   (filter odd</span>
<span id="cb35-6"><a href="#cb35-6"></a>                           (enumerate-tree tree)))))</span>
<span id="cb35-7"><a href="#cb35-7"></a>(<span class="ex">define</span><span class="fu"> </span>(odd-fibs n)</span>
<span id="cb35-8"><a href="#cb35-8"></a>  (accumulate <span class="kw">cons</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>              &#39;()</span>
<span id="cb35-10"><a href="#cb35-10"></a>              (filter odd</span>
<span id="cb35-11"><a href="#cb35-11"></a>                      (map fib</span>
<span id="cb35-12"><a href="#cb35-12"></a>                           (enumerate-interval <span class="dv">1</span> n)))))</span></code></pre></div>
<ul>
<li>This reveals their commonality, and makes it easy to mix and match boxes.</li>
<li>The advantage of stream processing is that it establishes <em>conventional interfaces</em>.</li>
<li>Conventional interfaces are powerful because we can easily glue things together.</li>
</ul>
<h2 id="part-2-10">Part 2</h2>
<h3 id="more-complicated-stream-processing">More complicated stream processing</h3>
<ul>
<li>Suppose we have a stream of streams <span class="math inline">\{\{1,2,3,\dots\},\{10,20,30,\dots\},\dots\}</span>.</li>
<li>We can define a procedure <code>flatten</code> to accumulate them into a single flat stream.</li>
<li>Problem: Given <span class="math inline">N</span>, find all pairs <span class="math inline">0&lt;j&lt;i≤N</span> such that <span class="math inline">i+j</span> is prime.</li>
</ul>
<div class="sourceCode" id="cb36"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb36-1"><a href="#cb36-1"></a>(<span class="ex">define</span><span class="fu"> </span>(prime-sum-pairs n)</span>
<span id="cb36-2"><a href="#cb36-2"></a>  (map</span>
<span id="cb36-3"><a href="#cb36-3"></a>    (<span class="kw">lambda</span> (p)</span>
<span id="cb36-4"><a href="#cb36-4"></a>      (<span class="kw">list</span> (<span class="kw">car</span> p) (<span class="kw">cadr</span> p) (<span class="op">+</span> (<span class="kw">car</span> p) (<span class="kw">cadr</span>  p))))</span>
<span id="cb36-5"><a href="#cb36-5"></a>    (filter</span>
<span id="cb36-6"><a href="#cb36-6"></a>      (<span class="kw">lambda</span> (p)</span>
<span id="cb36-7"><a href="#cb36-7"></a>        (prime (<span class="op">+</span> (<span class="kw">car</span> p) (<span class="kw">cadr</span> p))))</span>
<span id="cb36-8"><a href="#cb36-8"></a>      (flatmap</span>
<span id="cb36-9"><a href="#cb36-9"></a>        (<span class="kw">lambda</span> (i)</span>
<span id="cb36-10"><a href="#cb36-10"></a>          (map</span>
<span id="cb36-11"><a href="#cb36-11"></a>            (<span class="kw">lambda</span> (j) (<span class="kw">list</span> i j))</span>
<span id="cb36-12"><a href="#cb36-12"></a>            (enumerate-interval <span class="dv">1</span> (-<span class="dv">1</span>+ i))))</span>
<span id="cb36-13"><a href="#cb36-13"></a>        (enumerate-interval <span class="dv">1</span> n)))))</span></code></pre></div>
<ul>
<li><code>flatmap</code> takes the place of nested loops in most other languages.</li>
<li>We can simplify it with syntactic sugar <code>collect</code>:</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb37-1"><a href="#cb37-1"></a>(<span class="ex">define</span><span class="fu"> </span>(prime-sum-pairs n)</span>
<span id="cb37-2"><a href="#cb37-2"></a>  (collect</span>
<span id="cb37-3"><a href="#cb37-3"></a>    (<span class="kw">list</span> i j (<span class="op">+</span> i j))</span>
<span id="cb37-4"><a href="#cb37-4"></a>    ((i (enumerate-interval <span class="dv">1</span> n))</span>
<span id="cb37-5"><a href="#cb37-5"></a>     (j (enumerate-interval <span class="dv">1</span> (-<span class="dv">1</span>+ i))))</span>
<span id="cb37-6"><a href="#cb37-6"></a>    (prime? (<span class="op">+</span> i j))))</span></code></pre></div>
<h3 id="eight-queens-puzzle">Eight queens puzzle</h3>
<ul>
<li>Solving this typically uses a <em>backtracking search</em>, navigating up and down the tree of possibilities until we get to the bottom (all queens placed).</li>
<li>This is unnecessary – it’s inordinately concerned with <em>time</em>.</li>
<li>A simpler way is to employ <em>wishful thinking</em> and go from <span class="math inline">k</span> columns to <span class="math inline">k+1</span> columns.</li>
</ul>
<div class="sourceCode" id="cb38"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb38-1"><a href="#cb38-1"></a>(<span class="ex">define</span><span class="fu"> </span>(queens size)</span>
<span id="cb38-2"><a href="#cb38-2"></a>  (<span class="ex">define</span><span class="fu"> </span>(fill-cols k)</span>
<span id="cb38-3"><a href="#cb38-3"></a>    (<span class="kw">if</span> (<span class="op">=</span> k <span class="dv">0</span>)</span>
<span id="cb38-4"><a href="#cb38-4"></a>        (singleton empty-board)</span>
<span id="cb38-5"><a href="#cb38-5"></a>        (collect (adjoin-position try-row k rest-queens)</span>
<span id="cb38-6"><a href="#cb38-6"></a>                 ((rest-queens (fill-cols (-<span class="dv">1</span>+ k)))</span>
<span id="cb38-7"><a href="#cb38-7"></a>                  (try-row (enumerate-interval <span class="dv">1</span> size)))</span>
<span id="cb38-8"><a href="#cb38-8"></a>                 (safe? try-row k rest-queens))))</span>
<span id="cb38-9"><a href="#cb38-9"></a>  (fill-cols size))</span></code></pre></div>
<ul>
<li>This gives us <em>all solutions</em> to the <span class="math inline">k</span>-queens puzzle.</li>
<li>We changed our view from things that evolve in time and have state to a global view where we’re not concerned with time.</li>
</ul>
<h2 id="part-3-8">Part 3</h2>
<h3 id="streams-are-not-lists">Streams are not lists</h3>
<ul>
<li>By now you should be suspicious – what’s the catch?</li>
<li>Problem: Find the second prime between 10,000 and 1,000,000.</li>
<li>Stream solution: enumerate 10,000 to 1,000,000 → filter <code>prime?</code> → take 2nd.</li>
<li>This is ridiculously inefficient. Our earlier programs (before streams) were ugly because they mixed all the operations up, but because of this they were efficient.</li>
<li>But we can have our cake and eat it to! We can make it just as efficient.</li>
<li>The key to this is that streams are <em>not</em> lists.</li>
</ul>
<h3 id="implementing-streams">Implementing streams</h3>
<ul>
<li>We want the stream to compute itself incrementally, to be an “on demand” data structure.
<ul>
<li><code>(cons-stream x y)</code> is an abbreviation for <code>(cons x (delay y))</code></li>
<li><code>(head s)</code> is <code>(car s)</code></li>
<li><code>(tail s)</code> is <code>(force (cdr s))</code></li>
</ul></li>
<li><code>delay</code> creates a promise to compute something when <code>force</code> d.
<ul>
<li><code>(delay &lt;expr&gt;)</code> is an abbreviation for <code>(lambda () &lt;expr&gt;)</code></li>
<li><code>(force p)</code> is <code>(p)</code></li>
</ul></li>
<li><code>delay</code> decouples the apparent order of events from the actual order of events that happen in the machine. We give up the idea that our procedures mirror some clear notion of time.</li>
<li>One little hack: to be efficient, <code>(delay &lt;expr&gt;)</code> is <code>(memo-proc (lambda () &lt;expr&gt;))</code>.</li>
</ul>
<div class="sourceCode" id="cb39"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb39-1"><a href="#cb39-1"></a>(<span class="ex">define</span><span class="fu"> </span>(memo-proc proc)</span>
<span id="cb39-2"><a href="#cb39-2"></a>  (<span class="kw">let</span> ((already-run? nil) (result nil))</span>
<span id="cb39-3"><a href="#cb39-3"></a>    (<span class="kw">lambda</span> ()</span>
<span id="cb39-4"><a href="#cb39-4"></a>      (<span class="kw">if</span> (<span class="kw">not</span> already-run?)</span>
<span id="cb39-5"><a href="#cb39-5"></a>          (sequence (set! result (proc))</span>
<span id="cb39-6"><a href="#cb39-6"></a>                    (set! already-run? (<span class="kw">not</span> nil))</span>
<span id="cb39-7"><a href="#cb39-7"></a>                    result)</span>
<span id="cb39-8"><a href="#cb39-8"></a>          result))))</span></code></pre></div>
<ul>
<li>Streams blur the line between data structures and procedures.</li>
</ul>
<h1 id="b-streams-part-2">6B: Streams, Part 2</h1>
<h2 id="part-1-11">Part 1</h2>
<h3 id="recap-6">Recap</h3>
<ul>
<li>We’ve been looking at stream processing, an on-demand method of computation.</li>
<li>We don’t compute elements until we’ve asked for them. When do we “ask” for them?</li>
<li>Example: <code>nth-stream</code> forces the first <code>n</code> elements of a stream.</li>
</ul>
<div class="sourceCode" id="cb40"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb40-1"><a href="#cb40-1"></a>(<span class="ex">define</span><span class="fu"> </span>(nth-stream n s)</span>
<span id="cb40-2"><a href="#cb40-2"></a>  (<span class="kw">if</span> (<span class="op">=</span> n <span class="dv">0</span>)</span>
<span id="cb40-3"><a href="#cb40-3"></a>      (head s)</span>
<span id="cb40-4"><a href="#cb40-4"></a>      (nth-stream (-<span class="dv">1</span>+ n) (tail s))))</span></code></pre></div>
<h3 id="infinite-streams">Infinite streams</h3>
<ul>
<li>How long can a stream be? It can be <em>infinite</em>!</li>
</ul>
<div class="sourceCode" id="cb41"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb41-1"><a href="#cb41-1"></a>(<span class="ex">define</span><span class="fu"> </span>(integers-from n)</span>
<span id="cb41-2"><a href="#cb41-2"></a>  (cons-stream n (integers-from (<span class="dv">1</span>+ n))))</span>
<span id="cb41-3"><a href="#cb41-3"></a>(<span class="ex">define</span><span class="fu"> integers </span>(integers-from <span class="dv">1</span>))</span></code></pre></div>
<ul>
<li>Is this really all the integers, or is it just cleverly arranged so that whenever you look for an integer you find it there? This is a sort of philosophical question.</li>
</ul>
<h3 id="sieve-of-eratosthenes">Sieve of Eratosthenes</h3>
<ul>
<li>Start with 2, cross out larger multiples of 2; take next, 3, and cross out larger multiples of 3; and so on. What you’re left with is all the primes.</li>
</ul>
<div class="sourceCode" id="cb42"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb42-1"><a href="#cb42-1"></a>(<span class="ex">define</span><span class="fu"> </span>(sieve s)</span>
<span id="cb42-2"><a href="#cb42-2"></a>  (cons-stream</span>
<span id="cb42-3"><a href="#cb42-3"></a>    (head s)</span>
<span id="cb42-4"><a href="#cb42-4"></a>    (sieve (filter (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (divisible? x (head s))))</span>
<span id="cb42-5"><a href="#cb42-5"></a>                   (tail s)))))</span>
<span id="cb42-6"><a href="#cb42-6"></a>(<span class="ex">define</span><span class="fu"> primes </span>(sieve (integers-from <span class="dv">2</span>)))</span>
<span id="cb42-7"><a href="#cb42-7"></a>(nth-stream <span class="dv">20</span> primes)</span>
<span id="cb42-8"><a href="#cb42-8"></a><span class="dv">73</span></span></code></pre></div>
<h2 id="part-2-11">Part 2</h2>
<h3 id="defining-streams-implicitly">Defining streams implicitly</h3>
<ul>
<li>We’ve so far seen procedures that recursively create streams.</li>
<li>There’s another way. But first we need some additional procedures:</li>
</ul>
<div class="sourceCode" id="cb43"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb43-1"><a href="#cb43-1"></a>(<span class="ex">define</span><span class="fu"> </span>(add-streams s1 s2)</span>
<span id="cb43-2"><a href="#cb43-2"></a>  (<span class="kw">cond</span> ((empty-stream? s1) s2)</span>
<span id="cb43-3"><a href="#cb43-3"></a>        ((empty-stream? s2) s1)</span>
<span id="cb43-4"><a href="#cb43-4"></a>        (<span class="kw">else</span> (cons-stream (<span class="op">+</span> (head s1) (head s2))</span>
<span id="cb43-5"><a href="#cb43-5"></a>                           (add-streams (tail s1) (tail s2))))))</span>
<span id="cb43-6"><a href="#cb43-6"></a>(<span class="ex">define</span><span class="fu"> </span>(scale-stream c s)</span>
<span id="cb43-7"><a href="#cb43-7"></a>  (map-stream (<span class="kw">lambda</span> (x) (* x c)) s))</span></code></pre></div>
<ul>
<li>Now, we can define streams all at once:</li>
</ul>
<div class="sourceCode" id="cb44"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb44-1"><a href="#cb44-1"></a>(<span class="ex">define</span><span class="fu"> ones </span>(cons-stream <span class="dv">1</span> ones))</span>
<span id="cb44-2"><a href="#cb44-2"></a>(<span class="ex">define</span><span class="fu"> integers </span>(add-streams integers ones))</span></code></pre></div>
<h3 id="more-examples">More examples</h3>
<ul>
<li>We can calculate the integral <span class="math inline">\int s\,dt</span> the same way you would in signal processing:</li>
</ul>
<div class="sourceCode" id="cb45"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb45-1"><a href="#cb45-1"></a>(<span class="ex">define</span><span class="fu"> </span>(integral s initial-value dt)</span>
<span id="cb45-2"><a href="#cb45-2"></a>  (<span class="ex">define</span><span class="fu"> int</span></span>
<span id="cb45-3"><a href="#cb45-3"></a>    (cons-stream initial-value</span>
<span id="cb45-4"><a href="#cb45-4"></a>                 (add-streams (scale-stream dt s) int)))</span>
<span id="cb45-5"><a href="#cb45-5"></a>  int)</span></code></pre></div>
<ul>
<li>Another example, the Fibonacci numbers:</li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb46-1"><a href="#cb46-1"></a>(<span class="ex">define</span><span class="fu"> fibs</span></span>
<span id="cb46-2"><a href="#cb46-2"></a>  (cons-stream <span class="dv">0</span></span>
<span id="cb46-3"><a href="#cb46-3"></a>               (cons-stream <span class="dv">1</span></span>
<span id="cb46-4"><a href="#cb46-4"></a>                            (add-streams fibs (tail fibs)))))</span></code></pre></div>
<h3 id="explicit-delay">Explicit <code>delay</code></h3>
<ul>
<li>Let’s say we want to solve <span class="math inline">y&#39;=y^2,\;y(0)=1</span> using the step <span class="math inline">dt=0.001</span>.</li>
<li>We’d like to write a stream program to solve this:</li>
</ul>
<div class="sourceCode" id="cb47"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb47-1"><a href="#cb47-1"></a>(<span class="ex">define</span><span class="fu"> y </span>(integral dy <span class="dv">1</span> <span class="fl">0.001</span>))</span>
<span id="cb47-2"><a href="#cb47-2"></a>(<span class="ex">define</span><span class="fu"> dy </span>(map-stream square y))</span></code></pre></div>
<ul>
<li>This doesn’t work because <code>y</code> and <code>dy</code> each need the other defined first.</li>
<li>We can fix it the same way <code>cons-stream</code> allows self-referencing definitions: by introducing another <code>delay</code>, so that we can get the first value of the integral stream without knowing what stream it’s integrating.</li>
</ul>
<div class="sourceCode" id="cb48"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb48-1"><a href="#cb48-1"></a>(<span class="ex">define</span><span class="fu"> </span>(integral delayed-s initial-value dt)</span>
<span id="cb48-2"><a href="#cb48-2"></a>  (<span class="ex">define</span><span class="fu"> int</span></span>
<span id="cb48-3"><a href="#cb48-3"></a>    (cons-stream initial-value</span>
<span id="cb48-4"><a href="#cb48-4"></a>                 (<span class="kw">let</span> ((s (<span class="kw">force</span> delayed-s)))</span>
<span id="cb48-5"><a href="#cb48-5"></a>                   (add-streams (scale-stream dt s) int))))</span>
<span id="cb48-6"><a href="#cb48-6"></a>  int)</span>
<span id="cb48-7"><a href="#cb48-7"></a>(<span class="ex">define</span><span class="fu"> y </span>(integral (delay dy) <span class="dv">1</span> <span class="fl">0.001</span>))</span>
<span id="cb48-8"><a href="#cb48-8"></a>(<span class="ex">define</span><span class="fu"> dy </span>(map-stream square y))</span></code></pre></div>
<h2 id="part-3-9">Part 3</h2>
<h3 id="normal-order-evaluation">Normal-order evaluation</h3>
<ul>
<li>We’ve been divorcing time in the program from time in the computer.</li>
<li>Sometimes, to really take advantage of this method, you have to write explicit <code>delay</code> s. But in larger programs it can be very difficult to see where you need them.</li>
<li>Is there a way around this? Yes! By making <em>all</em> arguments to <em>every</em> procedure delayed.</li>
<li>This is <em>normal-order</em> evaluation, as opposed to <em>applicative-order</em> which we’ve been using.</li>
<li>We wouldn’t need <code>cons-stream</code> because it would be the same as <code>cons</code>.</li>
<li>But there’s a price. The language becomes more elegant, but less expressive. For example, we could no longer write iterative procedures.</li>
<li>You get these “dragging tails” of thunks that haven’t been evaluated, taking up 3 MB (!).</li>
<li>A more striking issue: normal-order evaluation and side effects just don’t mix.</li>
<li>The whole idea with streams was to throw away time; but with side effects we want time!</li>
<li><em>Functional</em> programming languages avoid this issue by disallowing side effects.</li>
</ul>
<h3 id="avoiding-mutable-state">Avoiding mutable state</h3>
<ul>
<li>What about generating random numbers? We wanted modularity, so we encapsulated the random number generation with local state.</li>
<li>Instead, we could create an infinite stream of random numbers.</li>
<li>With bank accounts, instead of using local state and message passing, we can have the bank account process a stream of transaction requests, and emit a stream of balances.</li>
<li>Can you do everything without assignment? No, there seem to be places where purely functional programming languages break down.</li>
<li>For example, how do we model a joint bank account with multiple users? We’d have to merge the request streams somehow.</li>
<li>The conflict between objects/state/time and <code>delay</code>/streams/functional programming might have very little to do with CS, and be more about different ways of viewing the world.</li>
</ul>
<h1 id="a-metacircular-evaluator-part-1">7A: Metacircular Evaluator, Part 1</h1>
<h2 id="part-1-12">Part 1</h2>
<h2 id="part-2-12">Part 2</h2>
<h2 id="part-3-10">Part 3</h2>
<h1 id="b-metacircular-evaluator-part-2">7B: Metacircular Evaluator, Part 2</h1>
<h2 id="part-1-13">Part 1</h2>
<h2 id="part-2-13">Part 2</h2>
<h2 id="part-3-11">Part 3</h2>
</body>
</html>
